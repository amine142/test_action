(self["webpackChunk"] = self["webpackChunk"] || []).push([["vendors-node_modules_duetds_date-picker_custom-element_index_js-node_modules_core-js_modules_-ff87da"],{

/***/ "./node_modules/@duetds/date-picker/custom-element/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@duetds/date-picker/custom-element/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "setAssetPath": () => (/* reexport safe */ _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.setAssetPath),
/* harmony export */   "setPlatformOptions": () => (/* reexport safe */ _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.setPlatformOptions),
/* harmony export */   "DuetDatePicker": () => (/* binding */ DuetDatePicker$1),
/* harmony export */   "defineCustomElements": () => (/* binding */ defineCustomElements)
/* harmony export */ });
/* harmony import */ var _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @stencil/core/internal/client */ "./node_modules/@stencil/core/internal/client/index.js");



const ISO_DATE_FORMAT = /^(\d{4})-(\d{2})-(\d{2})$/;
var DaysOfWeek;
(function (DaysOfWeek) {
  DaysOfWeek[DaysOfWeek["Sunday"] = 0] = "Sunday";
  DaysOfWeek[DaysOfWeek["Monday"] = 1] = "Monday";
  DaysOfWeek[DaysOfWeek["Tuesday"] = 2] = "Tuesday";
  DaysOfWeek[DaysOfWeek["Wednesday"] = 3] = "Wednesday";
  DaysOfWeek[DaysOfWeek["Thursday"] = 4] = "Thursday";
  DaysOfWeek[DaysOfWeek["Friday"] = 5] = "Friday";
  DaysOfWeek[DaysOfWeek["Saturday"] = 6] = "Saturday";
})(DaysOfWeek || (DaysOfWeek = {}));
function createDate(year, month, day) {
  var dayInt = parseInt(day, 10);
  var monthInt = parseInt(month, 10);
  var yearInt = parseInt(year, 10);
  const isValid = Number.isInteger(yearInt) && // all parts should be integers
    Number.isInteger(monthInt) &&
    Number.isInteger(dayInt) &&
    monthInt > 0 && // month must be 1-12
    monthInt <= 12 &&
    dayInt > 0 && // day must be 1-31
    dayInt <= 31 &&
    yearInt > 0;
  if (isValid) {
    return new Date(yearInt, monthInt - 1, dayInt);
  }
}
/**
 * @param value date string in ISO format YYYY-MM-DD
 */
function parseISODate(value) {
  if (!value) {
    return;
  }
  const matches = value.match(ISO_DATE_FORMAT);
  if (matches) {
    return createDate(matches[1], matches[2], matches[3]);
  }
}
/**
 * print date in format YYYY-MM-DD
 * @param date
 */
function printISODate(date) {
  if (!date) {
    return "";
  }
  var d = date.getDate().toString(10);
  var m = (date.getMonth() + 1).toString(10);
  var y = date.getFullYear().toString(10);
  // days are not zero-indexed, so pad if less than 10
  if (date.getDate() < 10) {
    d = `0${d}`;
  }
  // months *are* zero-indexed, pad if less than 9!
  if (date.getMonth() < 9) {
    m = `0${m}`;
  }
  return `${y}-${m}-${d}`;
}
/**
 * Compare if two dates are equal in terms of day, month, and year
 */
function isEqual(a, b) {
  if (a == null || b == null) {
    return false;
  }
  return isEqualMonth(a, b) && a.getDate() === b.getDate();
}
/**
 * Compare if two dates are in the same month of the same year.
 */
function isEqualMonth(a, b) {
  if (a == null || b == null) {
    return false;
  }
  return a.getFullYear() === b.getFullYear() && a.getMonth() === b.getMonth();
}
function addDays(date, days) {
  var d = new Date(date);
  d.setDate(d.getDate() + days);
  return d;
}
function startOfWeek(date, firstDayOfWeek = DaysOfWeek.Monday) {
  var d = new Date(date);
  var day = d.getDay();
  var diff = (day < firstDayOfWeek ? 7 : 0) + day - firstDayOfWeek;
  d.setDate(d.getDate() - diff);
  return d;
}
function endOfWeek(date, firstDayOfWeek = DaysOfWeek.Monday) {
  var d = new Date(date);
  var day = d.getDay();
  var diff = (day < firstDayOfWeek ? -7 : 0) + 6 - (day - firstDayOfWeek);
  d.setDate(d.getDate() + diff);
  return d;
}
function startOfMonth(date) {
  return new Date(date.getFullYear(), date.getMonth(), 1);
}
function endOfMonth(date) {
  return new Date(date.getFullYear(), date.getMonth() + 1, 0);
}
function setMonth(date, month) {
  const d = new Date(date);
  d.setMonth(month);
  return d;
}
function setYear(date, year) {
  const d = new Date(date);
  d.setFullYear(year);
  return d;
}
/**
 * Check if date is within a min and max
 */
function inRange(date, min, max) {
  return clamp(date, min, max) === date;
}
/**
 * Ensures date is within range, returns min or max if out of bounds
 */
function clamp(date, min, max) {
  const time = date.getTime();
  if (min && min instanceof Date && time < min.getTime()) {
    return min;
  }
  if (max && max instanceof Date && time > max.getTime()) {
    return max;
  }
  return date;
}
/**
 * given start and end date, return an (inclusive) array of all dates in between
 * @param start
 * @param end
 */
function getDaysInRange(start, end) {
  const days = [];
  let current = start;
  while (!isEqual(current, end)) {
    days.push(current);
    current = addDays(current, 1);
  }
  days.push(current);
  return days;
}
/**
 * given a date, return an array of dates from a calendar perspective
 * @param date
 * @param firstDayOfWeek
 */
function getViewOfMonth(date, firstDayOfWeek = DaysOfWeek.Monday) {
  const start = startOfWeek(startOfMonth(date), firstDayOfWeek);
  const end = endOfWeek(endOfMonth(date), firstDayOfWeek);
  return getDaysInRange(start, end);
}
/**
 * Form random hash
 */
function chr4() {
  return Math.random()
    .toString(16)
    .slice(-4);
}
/**
 * Create random identifier with a prefix
 * @param prefix
 */
function createIdentifier(prefix) {
  return `${prefix}-${chr4()}${chr4()}-${chr4()}-${chr4()}-${chr4()}-${chr4()}${chr4()}${chr4()}`;
}

const DatePickerInput = ({ onClick, dateFormatter, localization, name, formattedValue, valueAsDate, value, identifier, disabled, required, role, buttonRef, inputRef, onInput, onBlur, onFocus, }) => {
  return ((0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "duet-date__input-wrapper" },
    (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("input", { class: "duet-date__input", value: formattedValue, placeholder: localization.placeholder, id: identifier, disabled: disabled, role: role, required: required ? true : undefined, "aria-autocomplete": "none", onInput: onInput, onFocus: onFocus, onBlur: onBlur, autoComplete: "off", ref: inputRef }),
    (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("input", { type: "hidden", name: name, value: value }),
    (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("button", { class: "duet-date__toggle", onClick: onClick, disabled: disabled, ref: buttonRef, type: "button" },
      (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: "duet-date__toggle-icon" },
        (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("svg", { "aria-hidden": "true", height: "24", viewBox: "0 0 21 21", width: "24", xmlns: "http://www.w3.org/2000/svg" },
          (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("g", { fill: "none", "fill-rule": "evenodd", transform: "translate(2 2)" },
            (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("path", { d: "m2.5.5h12c1.1045695 0 2 .8954305 2 2v12c0 1.1045695-.8954305 2-2 2h-12c-1.1045695 0-2-.8954305-2-2v-12c0-1.1045695.8954305-2 2-2z", stroke: "currentColor", "stroke-linecap": "round", "stroke-linejoin": "round" }),
            (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("path", { d: "m.5 4.5h16", stroke: "currentColor", "stroke-linecap": "round", "stroke-linejoin": "round" }),
            (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("g", { fill: "currentColor" },
              (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("circle", { cx: "8.5", cy: "8.5", r: "1" }),
              (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("circle", { cx: "4.5", cy: "8.5", r: "1" }),
              (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("circle", { cx: "12.5", cy: "8.5", r: "1" }),
              (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("circle", { cx: "8.5", cy: "12.5", r: "1" }),
              (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("circle", { cx: "4.5", cy: "12.5", r: "1" }),
              (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("circle", { cx: "12.5", cy: "12.5", r: "1" }))))),
      (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: "duet-date__vhidden" },
        localization.buttonLabel,
        valueAsDate && ((0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("span", null,
          ", ",
          localization.selectedDateMessage,
          " ",
          dateFormatter.format(valueAsDate)))))));
};

const DatePickerDay = ({ focusedDay, today, day, onDaySelect, onKeyboardNavigation, focusedDayRef, disabled, inRange, isSelected, dateFormatter, }) => {
  const isToday = isEqual(day, today);
  const isMonth = isEqualMonth(day, focusedDay);
  const isFocused = isEqual(day, focusedDay);
  const isOutsideRange = !inRange;
  function handleClick(e) {
    onDaySelect(e, day);
  }
  return ((0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("button", { class: {
      "duet-date__day": true,
      "is-outside": isOutsideRange,
      "is-today": isToday,
      "is-month": isMonth,
      "is-disabled": disabled,
    }, tabIndex: isFocused ? 0 : -1, onClick: handleClick, onKeyDown: onKeyboardNavigation, "aria-disabled": disabled ? "true" : undefined, disabled: isOutsideRange, type: "button", "aria-pressed": isSelected ? "true" : "false", ref: el => {
      if (isFocused && el && focusedDayRef) {
        focusedDayRef(el);
      }
    } },
    (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("span", { "aria-hidden": "true" }, day.getDate()),
    (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: "duet-date__vhidden" }, dateFormatter.format(day))));
};

function chunk(array, chunkSize) {
  const result = [];
  for (let i = 0; i < array.length; i += chunkSize) {
    result.push(array.slice(i, i + chunkSize));
  }
  return result;
}
function mapWithOffset(array, startingOffset, mapFn) {
  return array.map((_, i) => {
    const adjustedIndex = (i + startingOffset) % array.length;
    return mapFn(array[adjustedIndex]);
  });
}
const DatePickerMonth = ({ selectedDate, focusedDate, labelledById, localization, firstDayOfWeek, min, max, dateFormatter, isDateDisabled, onDateSelect, onKeyboardNavigation, focusedDayRef, }) => {
  const today = new Date();
  const days = getViewOfMonth(focusedDate, firstDayOfWeek);
  return ((0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("table", { class: "duet-date__table", "aria-labelledby": labelledById },
    (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("thead", null,
      (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("tr", null, mapWithOffset(localization.dayNames, firstDayOfWeek, dayName => ((0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("th", { class: "duet-date__table-header", scope: "col" },
        (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("span", { "aria-hidden": "true" }, dayName.substr(0, 2)),
        (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: "duet-date__vhidden" }, dayName)))))),
    (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("tbody", null, chunk(days, 7).map(week => ((0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("tr", { class: "duet-date__row" }, week.map(day => ((0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("td", { class: "duet-date__cell" },
      (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(DatePickerDay, { day: day, today: today, focusedDay: focusedDate, isSelected: isEqual(day, selectedDate), disabled: isDateDisabled(day), inRange: inRange(day, min, max), onDaySelect: onDateSelect, dateFormatter: dateFormatter, onKeyboardNavigation: onKeyboardNavigation, focusedDayRef: focusedDayRef }))))))))));
};

const localization = {
  buttonLabel: "Choose date",
  placeholder: "YYYY-MM-DD",
  selectedDateMessage: "Selected date is",
  prevMonthLabel: "Previous month",
  nextMonthLabel: "Next month",
  monthSelectLabel: "Month",
  yearSelectLabel: "Year",
  closeLabel: "Close window",
  calendarHeading: "Choose a date",
  dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  monthNames: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December",
  ],
  monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  locale: "en-GB",
};

const isoAdapter = { parse: parseISODate, format: printISODate };

const duetDatePickerCss = ".duet-date *,.duet-date *::before,.duet-date *::after{box-sizing:border-box;margin:0;width:auto}.duet-date{box-sizing:border-box;color:var(--duet-color-text);display:block;font-family:var(--duet-font);margin:0;position:relative;text-align:left;width:100%}.duet-date__input{-webkit-appearance:none;appearance:none;background:var(--duet-color-surface);border:1px solid var(--duet-color-border, var(--duet-color-text));border-radius:var(--duet-radius);color:var(--duet-color-text);float:none;font-family:var(--duet-font);font-size:100%;line-height:normal;padding:14px 60px 14px 14px;width:100%}.duet-date__input:focus{border-color:var(--duet-color-primary);box-shadow:0 0 0 1px var(--duet-color-primary);outline:0}.duet-date__input::-webkit-input-placeholder{color:var(--duet-color-placeholder);opacity:1}.duet-date__input:-moz-placeholder{color:var(--duet-color-placeholder);opacity:1}.duet-date__input:-ms-input-placeholder{color:var(--duet-color-placeholder)}.duet-date__input-wrapper{position:relative;width:100%}.duet-date__toggle{-moz-appearance:none;-webkit-appearance:none;-webkit-user-select:none;align-items:center;appearance:none;background:var(--duet-color-button);border:0;border-radius:0;border-bottom-right-radius:var(--duet-radius);border-top-right-radius:var(--duet-radius);box-shadow:inset 1px 0 0 rgba(0, 0, 0, 0.1);color:var(--duet-color-text);cursor:pointer;display:flex;height:calc(100% - 2px);justify-content:center;padding:0;position:absolute;right:1px;top:1px;user-select:none;width:48px;z-index:2}.duet-date__toggle:focus{box-shadow:0 0 0 2px var(--duet-color-primary);outline:0}.duet-date__toggle-icon{display:flex;flex-basis:100%;justify-content:center;align-items:center}.duet-date__dialog{display:flex;left:0;min-width:320px;opacity:0;position:absolute;top:100%;transform:scale(0.96) translateZ(0) translateY(-20px);transform-origin:top right;transition:transform 300ms ease, opacity 300ms ease, visibility 300ms ease;visibility:hidden;width:100%;will-change:transform, opacity, visibility;z-index:var(--duet-z-index)}@media (max-width: 35.9375em){.duet-date__dialog{background:var(--duet-color-overlay);bottom:0;position:fixed;right:0;top:0;transform:translateZ(0);transform-origin:bottom center}}.duet-date__dialog.is-left{left:auto;right:0;width:auto}.duet-date__dialog.is-active{opacity:1;transform:scale(1.0001) translateZ(0) translateY(0);visibility:visible}.duet-date__dialog-content{background:var(--duet-color-surface);border:1px solid rgba(0, 0, 0, 0.1);border-radius:var(--duet-radius);box-shadow:0 4px 10px 0 rgba(0, 0, 0, 0.1);margin-left:auto;margin-top:8px;max-width:310px;min-width:290px;padding:16px 16px 20px;position:relative;transform:none;width:100%;z-index:var(--duet-z-index)}@media (max-width: 35.9375em){.duet-date__dialog-content{border:0;border-radius:0;border-top-left-radius:var(--duet-radius);border-top-right-radius:var(--duet-radius);bottom:0;left:0;margin:0;max-width:none;min-height:26em;opacity:0;padding:0 8% 20px;position:absolute;transform:translateZ(0) translateY(100%);transition:transform 400ms ease, opacity 400ms ease, visibility 400ms ease;visibility:hidden;will-change:transform, opacity, visibility}.is-active .duet-date__dialog-content{opacity:1;transform:translateZ(0) translateY(0);visibility:visible}}.duet-date__table{border-collapse:collapse;border-spacing:0;color:var(--duet-color-text);font-size:1rem;font-weight:var(--duet-font-normal);line-height:1.25;text-align:center;width:100%}.duet-date__table-header{font-size:0.75rem;font-weight:var(--duet-font-bold);letter-spacing:1px;line-height:1.25;padding-bottom:8px;text-decoration:none;text-transform:uppercase}.duet-date__cell{text-align:center}.duet-date__day{-moz-appearance:none;-webkit-appearance:none;appearance:none;background:transparent;border:0;border-radius:50%;color:var(--duet-color-text);cursor:pointer;display:inline-block;font-family:var(--duet-font);font-size:0.875rem;font-variant-numeric:tabular-nums;font-weight:var(--duet-font-normal);height:36px;line-height:1.25;padding:0 0 1px;position:relative;text-align:center;vertical-align:middle;width:36px;z-index:1}.duet-date__day.is-today{box-shadow:0 0 0 1px var(--duet-color-primary);position:relative;z-index:200}.duet-date__day:hover::before,.duet-date__day.is-today::before{background:var(--duet-color-primary);border-radius:50%;bottom:0;content:\"\";left:0;opacity:0.06;position:absolute;right:0;top:0}.duet-date__day[aria-pressed=true],.duet-date__day:focus{background:var(--duet-color-primary);box-shadow:none;color:var(--duet-color-text-active);outline:0}.duet-date__day:active{background:var(--duet-color-primary);box-shadow:0 0 5px var(--duet-color-primary);color:var(--duet-color-text-active);z-index:200}.duet-date__day:focus{box-shadow:0 0 5px var(--duet-color-primary);z-index:200}.duet-date__day:not(.is-month){box-shadow:none}.duet-date__day:not(.is-month),.duet-date__day[aria-disabled=true]{background:transparent;color:var(--duet-color-text);cursor:default;opacity:0.5}.duet-date__day[aria-disabled=true].is-today{box-shadow:0 0 0 1px var(--duet-color-primary)}.duet-date__day[aria-disabled=true].is-today:focus{box-shadow:0 0 5px var(--duet-color-primary);background:var(--duet-color-primary);color:var(--duet-color-text-active)}.duet-date__day[aria-disabled=true]:not(.is-today)::before{display:none}.duet-date__day.is-outside{background:var(--duet-color-button);box-shadow:none;color:var(--duet-color-text);cursor:default;opacity:0.6;pointer-events:none}.duet-date__day.is-outside::before{display:none}.duet-date__header{align-items:center;display:flex;justify-content:space-between;margin-bottom:16px;width:100%}.duet-date__nav{white-space:nowrap}.duet-date__prev,.duet-date__next{-moz-appearance:none;-webkit-appearance:none;align-items:center;appearance:none;background:var(--duet-color-button);border:0;border-radius:50%;color:var(--duet-color-text);cursor:pointer;display:inline-flex;height:32px;justify-content:center;margin-left:8px;padding:0;transition:background-color 300ms ease;width:32px}@media (max-width: 35.9375em){.duet-date__prev,.duet-date__next{height:40px;width:40px}}.duet-date__prev:focus,.duet-date__next:focus{box-shadow:0 0 0 2px var(--duet-color-primary);outline:0}.duet-date__prev:active:focus,.duet-date__next:active:focus{box-shadow:none}.duet-date__prev:disabled,.duet-date__next:disabled{cursor:default;opacity:0.5}.duet-date__prev svg,.duet-date__next svg{margin:0 auto}.duet-date__select{display:inline-flex;margin-top:4px;position:relative}.duet-date__select span{margin-right:4px}.duet-date__select select{cursor:pointer;font-size:1rem;height:100%;left:0;opacity:0;position:absolute;top:0;width:100%;z-index:2}.duet-date__select select:focus+.duet-date__select-label{box-shadow:0 0 0 2px var(--duet-color-primary)}.duet-date__select-label{align-items:center;border-radius:var(--duet-radius);color:var(--duet-color-text);display:flex;font-size:1.25rem;font-weight:var(--duet-font-bold);line-height:1.25;padding:0 4px 0 8px;pointer-events:none;position:relative;width:100%;z-index:1}.duet-date__select-label svg{width:16px;height:16px}.duet-date__mobile{align-items:center;border-bottom:1px solid rgba(0, 0, 0, 0.12);display:flex;justify-content:space-between;margin-bottom:20px;margin-left:-10%;overflow:hidden;padding:12px 20px;position:relative;text-overflow:ellipsis;white-space:nowrap;width:120%}@media (min-width: 36em){.duet-date__mobile{border:0;margin:0;overflow:visible;padding:0;position:absolute;right:-8px;top:-8px;width:auto}}.duet-date__mobile-heading{display:inline-block;font-weight:var(--duet-font-bold);max-width:84%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}@media (min-width: 36em){.duet-date__mobile-heading{display:none}}.duet-date__close{-webkit-appearance:none;align-items:center;appearance:none;background:var(--duet-color-button);border:0;border-radius:50%;color:var(--duet-color-text);cursor:pointer;display:flex;height:24px;justify-content:center;padding:0;width:24px}@media (min-width: 36em){.duet-date__close{opacity:0}}.duet-date__close:focus{box-shadow:0 0 0 2px var(--duet-color-primary);outline:none}@media (min-width: 36em){.duet-date__close:focus{opacity:1}}.duet-date__close svg{margin:0 auto}.duet-date__vhidden{border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;overflow:hidden;padding:0;position:absolute;top:0;width:1px}";

function range(from, to) {
  var result = [];
  for (var i = from; i <= to; i++) {
    result.push(i);
  }
  return result;
}
const keyCode = {
  TAB: 9,
  ESC: 27,
  SPACE: 32,
  PAGE_UP: 33,
  PAGE_DOWN: 34,
  END: 35,
  HOME: 36,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
};
function cleanValue(input, regex) {
  const value = input.value;
  const cursor = input.selectionStart;
  const beforeCursor = value.slice(0, cursor);
  const afterCursor = value.slice(cursor, value.length);
  const filteredBeforeCursor = beforeCursor.replace(regex, "");
  const filterAfterCursor = afterCursor.replace(regex, "");
  const newValue = filteredBeforeCursor + filterAfterCursor;
  const newCursor = filteredBeforeCursor.length;
  input.value = newValue;
  input.selectionStart = input.selectionEnd = newCursor;
  return newValue;
}
const DISALLOWED_CHARACTERS = /[^0-9\.\/\-]+/g;
const TRANSITION_MS = 300;
const DuetDatePicker = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.duetChange = (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.createEvent)(this, "duetChange", 7);
    this.duetBlur = (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.createEvent)(this, "duetBlur", 7);
    this.duetFocus = (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.createEvent)(this, "duetFocus", 7);
    this.duetOpen = (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.createEvent)(this, "duetOpen", 7);
    this.duetClose = (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.createEvent)(this, "duetClose", 7);
    /**
     * Own Properties
     */
    this.monthSelectId = createIdentifier("DuetDateMonth");
    this.yearSelectId = createIdentifier("DuetDateYear");
    this.dialogLabelId = createIdentifier("DuetDateLabel");
    this.initialTouchX = null;
    this.initialTouchY = null;
    /**
     * State() variables
     */
    this.activeFocus = false;
    this.focusedDay = new Date();
    this.open = false;
    /**
     * Public Property API
     */
    /**
     * Name of the date picker input.
     */
    this.name = "date";
    /**
     * Adds a unique identifier for the date picker input. Use this instead of html `id` attribute.
     */
    this.identifier = "";
    /**
     * Makes the date picker input component disabled. This prevents users from being able to
     * interact with the input, and conveys its inactive state to assistive technologies.
     */
    this.disabled = false;
    /**
     * Forces the opening direction of the calendar modal to be always left or right.
     * This setting can be useful when the input is smaller than the opening date picker
     * would be as by default the picker always opens towards right.
     */
    this.direction = "right";
    /**
     * Should the input be marked as required?
     */
    this.required = false;
    /**
     * Date value. Must be in IS0-8601 format: YYYY-MM-DD.
     */
    this.value = "";
    /**
     * Minimum date allowed to be picked. Must be in IS0-8601 format: YYYY-MM-DD.
     * This setting can be used alone or together with the max property.
     */
    this.min = "";
    /**
     * Maximum date allowed to be picked. Must be in IS0-8601 format: YYYY-MM-DD.
     * This setting can be used alone or together with the min property.
     */
    this.max = "";
    /**
     * Which day is considered first day of the week? `0` for Sunday, `1` for Monday, etc.
     * Default is Monday.
     */
    this.firstDayOfWeek = DaysOfWeek.Monday;
    /**
     * Button labels, day names, month names, etc, used for localization.
     * Default is English.
     */
    this.localization = localization;
    /**
     * Date adapter, for custom parsing/formatting.
     * Must be object with a `parse` function which accepts a `string` and returns a `Date`,
     * and a `format` function which accepts a `Date` and returns a `string`.
     * Default is IS0-8601 parsing and formatting.
     */
    this.dateAdapter = isoAdapter;
    /**
     * Controls which days are disabled and therefore disallowed.
     * For example, this can be used to disallow selection of weekends.
     */
    this.isDateDisabled = () => false;
    /**
     * Local methods.
     */
    this.enableActiveFocus = () => {
      this.activeFocus = true;
    };
    this.disableActiveFocus = () => {
      this.activeFocus = false;
    };
    this.toggleOpen = (e) => {
      e.preventDefault();
      this.open ? this.hide(false) : this.show();
    };
    this.handleEscKey = (event) => {
      if (event.keyCode === keyCode.ESC) {
        this.hide();
      }
    };
    this.handleBlur = (event) => {
      event.stopPropagation();
      this.duetBlur.emit({
        component: "duet-date-picker",
      });
    };
    this.handleFocus = (event) => {
      event.stopPropagation();
      this.duetFocus.emit({
        component: "duet-date-picker",
      });
    };
    this.handleTouchStart = (event) => {
      const touch = event.changedTouches[0];
      this.initialTouchX = touch.pageX;
      this.initialTouchY = touch.pageY;
    };
    this.handleTouchMove = (event) => {
      event.preventDefault();
    };
    this.handleTouchEnd = (event) => {
      const touch = event.changedTouches[0];
      const distX = touch.pageX - this.initialTouchX; // get horizontal dist traveled
      const distY = touch.pageY - this.initialTouchY; // get vertical dist traveled
      const threshold = 70;
      const isHorizontalSwipe = Math.abs(distX) >= threshold && Math.abs(distY) <= threshold;
      const isDownwardsSwipe = Math.abs(distY) >= threshold && Math.abs(distX) <= threshold && distY > 0;
      if (isHorizontalSwipe) {
        this.addMonths(distX < 0 ? 1 : -1);
      }
      else if (isDownwardsSwipe) {
        this.hide(false);
        event.preventDefault();
      }
      this.initialTouchY = null;
      this.initialTouchX = null;
    };
    this.handleNextMonthClick = (event) => {
      event.preventDefault();
      this.addMonths(1);
    };
    this.handlePreviousMonthClick = (event) => {
      event.preventDefault();
      this.addMonths(-1);
    };
    this.handleFirstFocusableKeydown = (event) => {
      // this ensures focus is trapped inside the dialog
      if (event.keyCode === keyCode.TAB && event.shiftKey) {
        this.focusedDayNode.focus();
        event.preventDefault();
      }
    };
    this.handleKeyboardNavigation = (event) => {
      // handle tab separately, since it needs to be treated
      // differently to other keyboard interactions
      if (event.keyCode === keyCode.TAB && !event.shiftKey) {
        event.preventDefault();
        this.firstFocusableElement.focus();
        return;
      }
      var handled = true;
      switch (event.keyCode) {
        case keyCode.RIGHT:
          this.addDays(1);
          break;
        case keyCode.LEFT:
          this.addDays(-1);
          break;
        case keyCode.DOWN:
          this.addDays(7);
          break;
        case keyCode.UP:
          this.addDays(-7);
          break;
        case keyCode.PAGE_UP:
          if (event.shiftKey) {
            this.addYears(-1);
          }
          else {
            this.addMonths(-1);
          }
          break;
        case keyCode.PAGE_DOWN:
          if (event.shiftKey) {
            this.addYears(1);
          }
          else {
            this.addMonths(1);
          }
          break;
        case keyCode.HOME:
          this.startOfWeek();
          break;
        case keyCode.END:
          this.endOfWeek();
          break;
        default:
          handled = false;
      }
      if (handled) {
        event.preventDefault();
        this.enableActiveFocus();
      }
    };
    this.handleDaySelect = (_event, day) => {
      const isInRange = inRange(day, parseISODate(this.min), parseISODate(this.max));
      const isAllowed = !this.isDateDisabled(day);
      if (isInRange && isAllowed) {
        this.setValue(day);
        this.hide();
      }
      else {
        // for consistency we should set the focused day in cases where
        // user has selected a day that has been specifically disallowed
        this.setFocusedDay(day);
      }
    };
    this.handleMonthSelect = e => {
      this.setMonth(parseInt(e.target.value, 10));
    };
    this.handleYearSelect = e => {
      this.setYear(parseInt(e.target.value, 10));
    };
    this.handleInputChange = () => {
      const target = this.datePickerInput;
      // clean up any invalid characters
      cleanValue(target, DISALLOWED_CHARACTERS);
      const parsed = this.dateAdapter.parse(target.value, createDate);
      if (parsed || target.value === "") {
        this.setValue(parsed);
      }
    };
    this.processFocusedDayNode = (element) => {
      this.focusedDayNode = element;
      if (this.activeFocus && this.open) {
        setTimeout(() => element.focus(), 0);
      }
    };
  }
  connectedCallback() {
    this.createDateFormatters();
  }
  createDateFormatters() {
    this.dateFormatShort = new Intl.DateTimeFormat(this.localization.locale, { day: "numeric", month: "long" });
    this.dateFormatLong = new Intl.DateTimeFormat(this.localization.locale, {
      day: "numeric",
      month: "long",
      year: "numeric",
    });
  }
  /**
   * Component event handling.
   */
  handleDocumentClick(e) {
    if (!this.open) {
      return;
    }
    // the dialog and the button aren't considered clicks outside.
    // dialog for obvious reasons, but the button needs to be skipped
    // so that two things are possible:
    //
    // a) clicking again on the button when dialog is open should close the modal.
    //    without skipping the button here, we would see a click outside
    //    _and_ a click on the button, so the `open` state goes
    //    open -> close (click outside) -> open (click button)
    //
    // b) clicking another date picker's button should close the current calendar
    //    and open the new one. this means we can't stopPropagation() on the button itself
    //
    // this was the only satisfactory combination of things to get the above to work
    const isClickOutside = e
      .composedPath()
      .every(node => node !== this.dialogWrapperNode && node !== this.datePickerButton);
    if (isClickOutside) {
      this.hide(false);
    }
  }
  /**
   * Public methods API
   */
  /**
   * Sets focus on the date picker's input. Use this method instead of the global `focus()`.
   */
  async setFocus() {
    return this.datePickerInput.focus();
  }
  /**
   * Show the calendar modal, moving focus to the calendar inside.
   */
  async show() {
    this.open = true;
    this.duetOpen.emit({
      component: "duet-date-picker",
    });
    this.setFocusedDay(parseISODate(this.value) || new Date());
    clearTimeout(this.focusTimeoutId);
    this.focusTimeoutId = setTimeout(() => this.monthSelectNode.focus(), TRANSITION_MS);
  }
  /**
   * Hide the calendar modal. Set `moveFocusToButton` to false to prevent focus
   * returning to the date picker's button. Default is true.
   */
  async hide(moveFocusToButton = true) {
    this.open = false;
    this.duetClose.emit({
      component: "duet-date-picker",
    });
    // in cases where calendar is quickly shown and hidden
    // we should avoid moving focus to the button
    clearTimeout(this.focusTimeoutId);
    if (moveFocusToButton) {
      // iOS VoiceOver needs to wait for all transitions to finish.
      setTimeout(() => this.datePickerButton.focus(), TRANSITION_MS + 200);
    }
  }
  addDays(days) {
    this.setFocusedDay(addDays(this.focusedDay, days));
  }
  addMonths(months) {
    this.setMonth(this.focusedDay.getMonth() + months);
  }
  addYears(years) {
    this.setYear(this.focusedDay.getFullYear() + years);
  }
  startOfWeek() {
    this.setFocusedDay(startOfWeek(this.focusedDay, this.firstDayOfWeek));
  }
  endOfWeek() {
    this.setFocusedDay(endOfWeek(this.focusedDay, this.firstDayOfWeek));
  }
  setMonth(month) {
    const min = setMonth(startOfMonth(this.focusedDay), month);
    const max = endOfMonth(min);
    const date = setMonth(this.focusedDay, month);
    this.setFocusedDay(clamp(date, min, max));
  }
  setYear(year) {
    const min = setYear(startOfMonth(this.focusedDay), year);
    const max = endOfMonth(min);
    const date = setYear(this.focusedDay, year);
    this.setFocusedDay(clamp(date, min, max));
  }
  setFocusedDay(day) {
    this.focusedDay = clamp(day, parseISODate(this.min), parseISODate(this.max));
  }
  setValue(date) {
    this.value = printISODate(date);
    this.duetChange.emit({
      component: "duet-date-picker",
      value: this.value,
      valueAsDate: date,
    });
  }
  /**
   * render() function
   * Always the last one in the class.
   */
  render() {
    const valueAsDate = parseISODate(this.value);
    const formattedDate = valueAsDate && this.dateAdapter.format(valueAsDate);
    const selectedYear = (valueAsDate || this.focusedDay).getFullYear();
    const focusedMonth = this.focusedDay.getMonth();
    const focusedYear = this.focusedDay.getFullYear();
    const minDate = parseISODate(this.min);
    const maxDate = parseISODate(this.max);
    const prevMonthDisabled = minDate != null && minDate.getMonth() === focusedMonth && minDate.getFullYear() === focusedYear;
    const nextMonthDisabled = maxDate != null && maxDate.getMonth() === focusedMonth && maxDate.getFullYear() === focusedYear;
    const minYear = minDate ? minDate.getFullYear() : selectedYear - 10;
    const maxYear = maxDate ? maxDate.getFullYear() : selectedYear + 10;
    return ((0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.Host, null, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "duet-date" }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(DatePickerInput, { dateFormatter: this.dateFormatLong, value: this.value, valueAsDate: valueAsDate, formattedValue: formattedDate, onInput: this.handleInputChange, onBlur: this.handleBlur, onFocus: this.handleFocus, onClick: this.toggleOpen, name: this.name, disabled: this.disabled, role: this.role, required: this.required, identifier: this.identifier, localization: this.localization, buttonRef: element => (this.datePickerButton = element), inputRef: element => (this.datePickerInput = element) }), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: {
        "duet-date__dialog": true,
        "is-left": this.direction === "left",
        "is-active": this.open,
      }, role: "dialog", "aria-modal": "true", "aria-hidden": this.open ? "false" : "true", "aria-labelledby": this.dialogLabelId, onTouchMove: this.handleTouchMove, onTouchStart: this.handleTouchStart, onTouchEnd: this.handleTouchEnd }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "duet-date__dialog-content", onKeyDown: this.handleEscKey, ref: element => (this.dialogWrapperNode = element) }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "duet-date__mobile", onFocusin: this.disableActiveFocus }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("label", { class: "duet-date__mobile-heading" }, this.localization.calendarHeading), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("button", { class: "duet-date__close", ref: element => (this.firstFocusableElement = element), onKeyDown: this.handleFirstFocusableKeydown, onClick: () => this.hide(), type: "button" }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("svg", { "aria-hidden": "true", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", width: "16", height: "16", viewBox: "0 0 24 24" }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("path", { d: "M0 0h24v24H0V0z", fill: "none" }), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("path", { d: "M18.3 5.71c-.39-.39-1.02-.39-1.41 0L12 10.59 7.11 5.7c-.39-.39-1.02-.39-1.41 0-.39.39-.39 1.02 0 1.41L10.59 12 5.7 16.89c-.39.39-.39 1.02 0 1.41.39.39 1.02.39 1.41 0L12 13.41l4.89 4.89c.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41L13.41 12l4.89-4.89c.38-.38.38-1.02 0-1.4z" })), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: "duet-date__vhidden" }, this.localization.closeLabel))), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "duet-date__header", onFocusin: this.disableActiveFocus }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("h2", { id: this.dialogLabelId, class: "duet-date__vhidden", "aria-live": "polite", "aria-atomic": "true" }, this.localization.monthNames[focusedMonth], " ", this.focusedDay.getFullYear()), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("label", { htmlFor: this.monthSelectId, class: "duet-date__vhidden" }, this.localization.monthSelectLabel), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "duet-date__select" }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("select", { id: this.monthSelectId, class: "duet-date__select--month", ref: element => (this.monthSelectNode = element), onChange: this.handleMonthSelect }, this.localization.monthNames.map((month, i) => ((0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("option", { key: month, value: i, selected: i === focusedMonth, disabled: !inRange(new Date(focusedYear, i, 1), minDate ? startOfMonth(minDate) : null, maxDate ? endOfMonth(maxDate) : null) }, month)))), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "duet-date__select-label", "aria-hidden": "true" }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("span", null, this.localization.monthNamesShort[focusedMonth]), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("svg", { fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", width: "16", height: "16", viewBox: "0 0 24 24" }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("path", { d: "M8.12 9.29L12 13.17l3.88-3.88c.39-.39 1.02-.39 1.41 0 .39.39.39 1.02 0 1.41l-4.59 4.59c-.39.39-1.02.39-1.41 0L6.7 10.7c-.39-.39-.39-1.02 0-1.41.39-.38 1.03-.39 1.42 0z" })))), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("label", { htmlFor: this.yearSelectId, class: "duet-date__vhidden" }, this.localization.yearSelectLabel), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "duet-date__select" }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("select", { id: this.yearSelectId, class: "duet-date__select--year", onChange: this.handleYearSelect }, range(minYear, maxYear).map(year => ((0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("option", { key: year, selected: year === focusedYear }, year)))), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "duet-date__select-label", "aria-hidden": "true" }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("span", null, this.focusedDay.getFullYear()), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("svg", { fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", width: "16", height: "16", viewBox: "0 0 24 24" }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("path", { d: "M8.12 9.29L12 13.17l3.88-3.88c.39-.39 1.02-.39 1.41 0 .39.39.39 1.02 0 1.41l-4.59 4.59c-.39.39-1.02.39-1.41 0L6.7 10.7c-.39-.39-.39-1.02 0-1.41.39-.38 1.03-.39 1.42 0z" }))))), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "duet-date__nav" }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("button", { class: "duet-date__prev", onClick: this.handlePreviousMonthClick, disabled: prevMonthDisabled, type: "button" }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("svg", { "aria-hidden": "true", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", width: "21", height: "21", viewBox: "0 0 24 24" }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("path", { d: "M14.71 15.88L10.83 12l3.88-3.88c.39-.39.39-1.02 0-1.41-.39-.39-1.02-.39-1.41 0L8.71 11.3c-.39.39-.39 1.02 0 1.41l4.59 4.59c.39.39 1.02.39 1.41 0 .38-.39.39-1.03 0-1.42z" })), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: "duet-date__vhidden" }, this.localization.prevMonthLabel)), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("button", { class: "duet-date__next", onClick: this.handleNextMonthClick, disabled: nextMonthDisabled, type: "button" }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("svg", { "aria-hidden": "true", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", width: "21", height: "21", viewBox: "0 0 24 24" }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("path", { d: "M9.29 15.88L13.17 12 9.29 8.12c-.39-.39-.39-1.02 0-1.41.39-.39 1.02-.39 1.41 0l4.59 4.59c.39.39.39 1.02 0 1.41L10.7 17.3c-.39.39-1.02.39-1.41 0-.38-.39-.39-1.03 0-1.42z" })), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: "duet-date__vhidden" }, this.localization.nextMonthLabel)))), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(DatePickerMonth, { dateFormatter: this.dateFormatShort, selectedDate: valueAsDate, focusedDate: this.focusedDay, onDateSelect: this.handleDaySelect, onKeyboardNavigation: this.handleKeyboardNavigation, labelledById: this.dialogLabelId, localization: this.localization, firstDayOfWeek: this.firstDayOfWeek, focusedDayRef: this.processFocusedDayNode, min: minDate, max: maxDate, isDateDisabled: this.isDateDisabled }))))));
  }
  get element() { return this; }
  static get watchers() { return {
    "localization": ["createDateFormatters"]
  }; }
  static get style() { return duetDatePickerCss; }
};

const DuetDatePicker$1 = /*@__PURE__*/(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.proxyCustomElement)(DuetDatePicker, [0,"duet-date-picker",{"name":[1],"identifier":[1],"disabled":[516],"role":[1],"direction":[1],"required":[4],"value":[1537],"min":[1],"max":[1],"firstDayOfWeek":[2,"first-day-of-week"],"localization":[16],"dateAdapter":[16],"isDateDisabled":[16],"activeFocus":[32],"focusedDay":[32],"open":[32]},[[6,"click","handleDocumentClick"]]]);
const defineCustomElements = (opts) => {
  if (typeof customElements !== 'undefined') {
    [
      DuetDatePicker$1
    ].forEach(cmp => {
      if (!customElements.get(cmp.is)) {
        customElements.define(cmp.is, cmp, opts);
      }
    });
  }
};




/***/ }),

/***/ "./node_modules/@stencil/core/internal/client/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@stencil/core/internal/client/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BUILD": () => (/* reexport safe */ _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD),
/* harmony export */   "Env": () => (/* reexport safe */ _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.Env),
/* harmony export */   "NAMESPACE": () => (/* reexport safe */ _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.NAMESPACE),
/* harmony export */   "Build": () => (/* binding */ Build),
/* harmony export */   "CSS": () => (/* binding */ CSS),
/* harmony export */   "Context": () => (/* binding */ Context),
/* harmony export */   "Fragment": () => (/* binding */ Fragment),
/* harmony export */   "H": () => (/* binding */ H),
/* harmony export */   "HTMLElement": () => (/* binding */ H),
/* harmony export */   "Host": () => (/* binding */ Host),
/* harmony export */   "STENCIL_DEV_MODE": () => (/* binding */ STENCIL_DEV_MODE),
/* harmony export */   "addHostEventListeners": () => (/* binding */ addHostEventListeners),
/* harmony export */   "attachShadow": () => (/* binding */ attachShadow),
/* harmony export */   "bootstrapLazy": () => (/* binding */ bootstrapLazy),
/* harmony export */   "cmpModules": () => (/* binding */ cmpModules),
/* harmony export */   "connectedCallback": () => (/* binding */ connectedCallback),
/* harmony export */   "consoleDevError": () => (/* binding */ consoleDevError),
/* harmony export */   "consoleDevInfo": () => (/* binding */ consoleDevInfo),
/* harmony export */   "consoleDevWarn": () => (/* binding */ consoleDevWarn),
/* harmony export */   "consoleError": () => (/* binding */ consoleError),
/* harmony export */   "createEvent": () => (/* binding */ createEvent),
/* harmony export */   "defineCustomElement": () => (/* binding */ defineCustomElement),
/* harmony export */   "disconnectedCallback": () => (/* binding */ disconnectedCallback),
/* harmony export */   "doc": () => (/* binding */ doc),
/* harmony export */   "forceModeUpdate": () => (/* binding */ forceModeUpdate),
/* harmony export */   "forceUpdate": () => (/* binding */ forceUpdate),
/* harmony export */   "getAssetPath": () => (/* binding */ getAssetPath),
/* harmony export */   "getConnect": () => (/* binding */ getConnect),
/* harmony export */   "getContext": () => (/* binding */ getContext),
/* harmony export */   "getElement": () => (/* binding */ getElement),
/* harmony export */   "getHostRef": () => (/* binding */ getHostRef),
/* harmony export */   "getMode": () => (/* binding */ getMode),
/* harmony export */   "getRenderingRef": () => (/* binding */ getRenderingRef),
/* harmony export */   "getValue": () => (/* binding */ getValue),
/* harmony export */   "h": () => (/* binding */ h),
/* harmony export */   "insertVdomAnnotations": () => (/* binding */ insertVdomAnnotations),
/* harmony export */   "isMemberInElement": () => (/* binding */ isMemberInElement),
/* harmony export */   "loadModule": () => (/* binding */ loadModule),
/* harmony export */   "modeResolutionChain": () => (/* binding */ modeResolutionChain),
/* harmony export */   "nextTick": () => (/* binding */ nextTick),
/* harmony export */   "parsePropertyValue": () => (/* binding */ parsePropertyValue),
/* harmony export */   "plt": () => (/* binding */ plt),
/* harmony export */   "postUpdateComponent": () => (/* binding */ postUpdateComponent),
/* harmony export */   "promiseResolve": () => (/* binding */ promiseResolve),
/* harmony export */   "proxyComponent": () => (/* binding */ proxyComponent),
/* harmony export */   "proxyCustomElement": () => (/* binding */ proxyCustomElement),
/* harmony export */   "readTask": () => (/* binding */ readTask),
/* harmony export */   "registerHost": () => (/* binding */ registerHost),
/* harmony export */   "registerInstance": () => (/* binding */ registerInstance),
/* harmony export */   "renderVdom": () => (/* binding */ renderVdom),
/* harmony export */   "setAssetPath": () => (/* binding */ setAssetPath),
/* harmony export */   "setErrorHandler": () => (/* binding */ setErrorHandler),
/* harmony export */   "setMode": () => (/* binding */ setMode),
/* harmony export */   "setPlatformHelpers": () => (/* binding */ setPlatformHelpers),
/* harmony export */   "setPlatformOptions": () => (/* binding */ setPlatformOptions),
/* harmony export */   "setValue": () => (/* binding */ setValue),
/* harmony export */   "styles": () => (/* binding */ styles),
/* harmony export */   "supportsConstructibleStylesheets": () => (/* binding */ supportsConstructibleStylesheets),
/* harmony export */   "supportsListenerOptions": () => (/* binding */ supportsListenerOptions),
/* harmony export */   "supportsShadow": () => (/* binding */ supportsShadow),
/* harmony export */   "win": () => (/* binding */ win),
/* harmony export */   "writeTask": () => (/* binding */ writeTask)
/* harmony export */ });
/* harmony import */ var _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @stencil/core/internal/app-data */ "./node_modules/@stencil/core/internal/app-data/index.js");
let scopeId;
let contentRef;
let hostTagName;
let customError;
let i = 0;
let useNativeShadowDom = false;
let checkSlotFallbackVisibility = false;
let checkSlotRelocate = false;
let isSvgMode = false;
let renderingRef = null;
let queueCongestion = 0;
let queuePending = false;
/*
 Stencil Client Platform v2.6.0 | MIT Licensed | https://stenciljs.com
 */

const win = typeof window !== 'undefined' ? window : {};
const CSS = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cssVarShim ? win.CSS : null;
const doc = win.document || { head: {} };
const H = (win.HTMLElement || class {
});
const plt = {
    $flags$: 0,
    $resourcesUrl$: '',
    jmp: h => h(),
    raf: h => requestAnimationFrame(h),
    ael: (el, eventName, listener, opts) => el.addEventListener(eventName, listener, opts),
    rel: (el, eventName, listener, opts) => el.removeEventListener(eventName, listener, opts),
    ce: (eventName, opts) => new CustomEvent(eventName, opts),
};
const setPlatformHelpers = (helpers) => {
    Object.assign(plt, helpers);
};
const supportsShadow = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDomShim && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom ? /*@__PURE__*/ (() => (doc.head.attachShadow + '').indexOf('[native') > -1)() : true;
const supportsListenerOptions = /*@__PURE__*/ (() => {
    let supportsListenerOptions = false;
    try {
        doc.addEventListener('e', null, Object.defineProperty({}, 'passive', {
            get() {
                supportsListenerOptions = true;
            },
        }));
    }
    catch (e) { }
    return supportsListenerOptions;
})();
const promiseResolve = (v) => Promise.resolve(v);
const supportsConstructibleStylesheets = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.constructableCSS
    ? /*@__PURE__*/ (() => {
        try {
            new CSSStyleSheet();
            return typeof (new CSSStyleSheet()).replace === 'function';
        }
        catch (e) { }
        return false;
    })()
    : false;
const Context = {};
const addHostEventListeners = (elm, hostRef, listeners, attachParentListeners) => {
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListener && listeners) {
        // this is called immediately within the element's constructor
        // initialize our event listeners on the host element
        // we do this now so that we can listen to events that may
        // have fired even before the instance is ready
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListenerTargetParent) {
            // this component may have event listeners that should be attached to the parent
            if (attachParentListeners) {
                // this is being ran from within the connectedCallback
                // which is important so that we know the host element actually has a parent element
                // filter out the listeners to only have the ones that ARE being attached to the parent
                listeners = listeners.filter(([flags]) => flags & 32 /* TargetParent */);
            }
            else {
                // this is being ran from within the component constructor
                // everything BUT the parent element listeners should be attached at this time
                // filter out the listeners that are NOT being attached to the parent
                listeners = listeners.filter(([flags]) => !(flags & 32 /* TargetParent */));
            }
        }
        listeners.map(([flags, name, method]) => {
            const target = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListenerTarget ? getHostListenerTarget(elm, flags) : elm;
            const handler = hostListenerProxy(hostRef, method);
            const opts = hostListenerOpts(flags);
            plt.ael(target, name, handler, opts);
            (hostRef.$rmListeners$ = hostRef.$rmListeners$ || []).push(() => plt.rel(target, name, handler, opts));
        });
    }
};
const hostListenerProxy = (hostRef, methodName) => (ev) => {
    try {
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad) {
            if (hostRef.$flags$ & 256 /* isListenReady */) {
                // instance is ready, let's call it's member method for this event
                hostRef.$lazyInstance$[methodName](ev);
            }
            else {
                (hostRef.$queuedListeners$ = hostRef.$queuedListeners$ || []).push([methodName, ev]);
            }
        }
        else {
            hostRef.$hostElement$[methodName](ev);
        }
    }
    catch (e) {
        consoleError(e);
    }
};
const getHostListenerTarget = (elm, flags) => {
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListenerTargetDocument && flags & 4 /* TargetDocument */)
        return doc;
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListenerTargetWindow && flags & 8 /* TargetWindow */)
        return win;
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListenerTargetBody && flags & 16 /* TargetBody */)
        return doc.body;
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListenerTargetParent && flags & 32 /* TargetParent */)
        return elm.parentElement;
    return elm;
};
// prettier-ignore
const hostListenerOpts = (flags) => supportsListenerOptions
    ? ({
        passive: (flags & 1 /* Passive */) !== 0,
        capture: (flags & 2 /* Capture */) !== 0,
    })
    : (flags & 2 /* Capture */) !== 0;
const CONTENT_REF_ID = 'r';
const ORG_LOCATION_ID = 'o';
const SLOT_NODE_ID = 's';
const TEXT_NODE_ID = 't';
const HYDRATE_ID = 's-id';
const HYDRATED_STYLE_ID = 'sty-id';
const HYDRATE_CHILD_ID = 'c-id';
const HYDRATED_CSS = '{visibility:hidden}.hydrated{visibility:inherit}';
const XLINK_NS = 'http://www.w3.org/1999/xlink';
const createTime = (fnName, tagName = '') => {
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.profile && performance.mark) {
        const key = `st:${fnName}:${tagName}:${i++}`;
        // Start
        performance.mark(key);
        // End
        return () => performance.measure(`[Stencil] ${fnName}() <${tagName}>`, key);
    }
    else {
        return () => {
            return;
        };
    }
};
const uniqueTime = (key, measureText) => {
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.profile && performance.mark) {
        if (performance.getEntriesByName(key).length === 0) {
            performance.mark(key);
        }
        return () => {
            if (performance.getEntriesByName(measureText).length === 0) {
                performance.measure(measureText, key);
            }
        };
    }
    else {
        return () => {
            return;
        };
    }
};
const inspect = (ref) => {
    const hostRef = getHostRef(ref);
    if (!hostRef) {
        return undefined;
    }
    const flags = hostRef.$flags$;
    const hostElement = hostRef.$hostElement$;
    return {
        renderCount: hostRef.$renderCount$,
        flags: {
            hasRendered: !!(flags & 2 /* hasRendered */),
            hasConnected: !!(flags & 1 /* hasConnected */),
            isWaitingForChildren: !!(flags & 4 /* isWaitingForChildren */),
            isConstructingInstance: !!(flags & 8 /* isConstructingInstance */),
            isQueuedForUpdate: !!(flags & 16 /* isQueuedForUpdate */),
            hasInitializedComponent: !!(flags & 32 /* hasInitializedComponent */),
            hasLoadedComponent: !!(flags & 64 /* hasLoadedComponent */),
            isWatchReady: !!(flags & 128 /* isWatchReady */),
            isListenReady: !!(flags & 256 /* isListenReady */),
            needsRerender: !!(flags & 512 /* needsRerender */),
        },
        instanceValues: hostRef.$instanceValues$,
        ancestorComponent: hostRef.$ancestorComponent$,
        hostElement,
        lazyInstance: hostRef.$lazyInstance$,
        vnode: hostRef.$vnode$,
        modeName: hostRef.$modeName$,
        onReadyPromise: hostRef.$onReadyPromise$,
        onReadyResolve: hostRef.$onReadyResolve$,
        onInstancePromise: hostRef.$onInstancePromise$,
        onInstanceResolve: hostRef.$onInstanceResolve$,
        onRenderResolve: hostRef.$onRenderResolve$,
        queuedListeners: hostRef.$queuedListeners$,
        rmListeners: hostRef.$rmListeners$,
        ['s-id']: hostElement['s-id'],
        ['s-cr']: hostElement['s-cr'],
        ['s-lr']: hostElement['s-lr'],
        ['s-p']: hostElement['s-p'],
        ['s-rc']: hostElement['s-rc'],
        ['s-sc']: hostElement['s-sc'],
    };
};
const installDevTools = () => {
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.devTools) {
        const stencil = (win.stencil = win.stencil || {});
        const originalInspect = stencil.inspect;
        stencil.inspect = (ref) => {
            let result = inspect(ref);
            if (!result && typeof originalInspect === 'function') {
                result = originalInspect(ref);
            }
            return result;
        };
    }
};
const rootAppliedStyles = new WeakMap();
const registerStyle = (scopeId, cssText, allowCS) => {
    let style = styles.get(scopeId);
    if (supportsConstructibleStylesheets && allowCS) {
        style = (style || new CSSStyleSheet());
        style.replace(cssText);
    }
    else {
        style = cssText;
    }
    styles.set(scopeId, style);
};
const addStyle = (styleContainerNode, cmpMeta, mode, hostElm) => {
    let scopeId = getScopeId(cmpMeta, mode);
    let style = styles.get(scopeId);
    if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.attachStyles) {
        return scopeId;
    }
    // if an element is NOT connected then getRootNode() will return the wrong root node
    // so the fallback is to always use the document for the root node in those cases
    styleContainerNode = styleContainerNode.nodeType === 11 /* DocumentFragment */ ? styleContainerNode : doc;
    if (style) {
        if (typeof style === 'string') {
            styleContainerNode = styleContainerNode.head || styleContainerNode;
            let appliedStyles = rootAppliedStyles.get(styleContainerNode);
            let styleElm;
            if (!appliedStyles) {
                rootAppliedStyles.set(styleContainerNode, (appliedStyles = new Set()));
            }
            if (!appliedStyles.has(scopeId)) {
                if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateClientSide && styleContainerNode.host && (styleElm = styleContainerNode.querySelector(`[${HYDRATED_STYLE_ID}="${scopeId}"]`))) {
                    // This is only happening on native shadow-dom, do not needs CSS var shim
                    styleElm.innerHTML = style;
                }
                else {
                    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cssVarShim && plt.$cssShim$) {
                        styleElm = plt.$cssShim$.createHostStyle(hostElm, scopeId, style, !!(cmpMeta.$flags$ & 10 /* needsScopedEncapsulation */));
                        const newScopeId = styleElm['s-sc'];
                        if (newScopeId) {
                            scopeId = newScopeId;
                            // we don't want to add this styleID to the appliedStyles Set
                            // since the cssVarShim might need to apply several different
                            // stylesheets for the same component
                            appliedStyles = null;
                        }
                    }
                    else {
                        styleElm = doc.createElement('style');
                        styleElm.innerHTML = style;
                    }
                    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hotModuleReplacement) {
                        styleElm.setAttribute(HYDRATED_STYLE_ID, scopeId);
                    }
                    styleContainerNode.insertBefore(styleElm, styleContainerNode.querySelector('link'));
                }
                if (appliedStyles) {
                    appliedStyles.add(scopeId);
                }
            }
        }
        else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.constructableCSS && !styleContainerNode.adoptedStyleSheets.includes(style)) {
            styleContainerNode.adoptedStyleSheets = [...styleContainerNode.adoptedStyleSheets, style];
        }
    }
    return scopeId;
};
const attachStyles = (hostRef) => {
    const cmpMeta = hostRef.$cmpMeta$;
    const elm = hostRef.$hostElement$;
    const flags = cmpMeta.$flags$;
    const endAttachStyles = createTime('attachStyles', cmpMeta.$tagName$);
    const scopeId = addStyle(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom && supportsShadow && elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(), cmpMeta, hostRef.$modeName$, elm);
    if ((_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.scoped) && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cssAnnotations && flags & 10 /* needsScopedEncapsulation */) {
        // only required when we're NOT using native shadow dom (slot)
        // or this browser doesn't support native shadow dom
        // and this host element was NOT created with SSR
        // let's pick out the inner content for slot projection
        // create a node to represent where the original
        // content was first placed, which is useful later on
        // DOM WRITE!!
        elm['s-sc'] = scopeId;
        elm.classList.add(scopeId + '-h');
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.scoped && flags & 2 /* scopedCssEncapsulation */) {
            elm.classList.add(scopeId + '-s');
        }
    }
    endAttachStyles();
};
const getScopeId = (cmp, mode) => 'sc-' + (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.mode && mode && cmp.$flags$ & 32 /* hasMode */ ? cmp.$tagName$ + '-' + mode : cmp.$tagName$);
const convertScopedToShadow = (css) => css.replace(/\/\*!@([^\/]+)\*\/[^\{]+\{/g, '$1{');
// Private
const computeMode = (elm) => modeResolutionChain.map(h => h(elm)).find(m => !!m);
// Public
const setMode = (handler) => modeResolutionChain.push(handler);
const getMode = (ref) => getHostRef(ref).$modeName$;
/**
 * Default style mode id
 */
/**
 * Reusable empty obj/array
 * Don't add values to these!!
 */
const EMPTY_OBJ = {};
/**
 * Namespaces
 */
const SVG_NS = 'http://www.w3.org/2000/svg';
const HTML_NS = 'http://www.w3.org/1999/xhtml';
const isDef = (v) => v != null;
const isComplexType = (o) => {
    // https://jsperf.com/typeof-fn-object/5
    o = typeof o;
    return o === 'object' || o === 'function';
};
/**
 * Production h() function based on Preact by
 * Jason Miller (@developit)
 * Licensed under the MIT License
 * https://github.com/developit/preact/blob/master/LICENSE
 *
 * Modified for Stencil's compiler and vdom
 */
// const stack: any[] = [];
// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, child?: d.ChildType): d.VNode;
// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, ...children: d.ChildType[]): d.VNode;
const h = (nodeName, vnodeData, ...children) => {
    let child = null;
    let key = null;
    let slotName = null;
    let simple = false;
    let lastSimple = false;
    let vNodeChildren = [];
    const walk = (c) => {
        for (let i = 0; i < c.length; i++) {
            child = c[i];
            if (Array.isArray(child)) {
                walk(child);
            }
            else if (child != null && typeof child !== 'boolean') {
                if ((simple = typeof nodeName !== 'function' && !isComplexType(child))) {
                    child = String(child);
                }
                else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev && typeof nodeName !== 'function' && child.$flags$ === undefined) {
                    consoleDevError(`vNode passed as children has unexpected type.
Make sure it's using the correct h() function.
Empty objects can also be the cause, look for JSX comments that became objects.`);
                }
                if (simple && lastSimple) {
                    // If the previous child was simple (string), we merge both
                    vNodeChildren[vNodeChildren.length - 1].$text$ += child;
                }
                else {
                    // Append a new vNode, if it's text, we create a text vNode
                    vNodeChildren.push(simple ? newVNode(null, child) : child);
                }
                lastSimple = simple;
            }
        }
    };
    walk(children);
    if (vnodeData) {
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev && nodeName === 'input') {
            validateInputProperties(vnodeData);
        }
        // normalize class / classname attributes
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomKey && vnodeData.key) {
            key = vnodeData.key;
        }
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation && vnodeData.name) {
            slotName = vnodeData.name;
        }
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomClass) {
            const classData = vnodeData.className || vnodeData.class;
            if (classData) {
                vnodeData.class =
                    typeof classData !== 'object'
                        ? classData
                        : Object.keys(classData)
                            .filter(k => classData[k])
                            .join(' ');
            }
        }
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev && vNodeChildren.some(isHost)) {
        consoleDevError(`The <Host> must be the single root component. Make sure:
- You are NOT using hostData() and <Host> in the same component.
- <Host> is used once, and it's the single root component of the render() function.`);
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomFunctional && typeof nodeName === 'function') {
        // nodeName is a functional component
        return nodeName(vnodeData === null ? {} : vnodeData, vNodeChildren, vdomFnUtils);
    }
    const vnode = newVNode(nodeName, null);
    vnode.$attrs$ = vnodeData;
    if (vNodeChildren.length > 0) {
        vnode.$children$ = vNodeChildren;
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomKey) {
        vnode.$key$ = key;
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation) {
        vnode.$name$ = slotName;
    }
    return vnode;
};
const newVNode = (tag, text) => {
    const vnode = {
        $flags$: 0,
        $tag$: tag,
        $text$: text,
        $elm$: null,
        $children$: null,
    };
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomAttribute) {
        vnode.$attrs$ = null;
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomKey) {
        vnode.$key$ = null;
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation) {
        vnode.$name$ = null;
    }
    return vnode;
};
const Host = {};
const isHost = (node) => node && node.$tag$ === Host;
const vdomFnUtils = {
    forEach: (children, cb) => children.map(convertToPublic).forEach(cb),
    map: (children, cb) => children.map(convertToPublic).map(cb).map(convertToPrivate),
};
const convertToPublic = (node) => ({
    vattrs: node.$attrs$,
    vchildren: node.$children$,
    vkey: node.$key$,
    vname: node.$name$,
    vtag: node.$tag$,
    vtext: node.$text$,
});
const convertToPrivate = (node) => {
    if (typeof node.vtag === 'function') {
        const vnodeData = Object.assign({}, node.vattrs);
        if (node.vkey) {
            vnodeData.key = node.vkey;
        }
        if (node.vname) {
            vnodeData.name = node.vname;
        }
        return h(node.vtag, vnodeData, ...(node.vchildren || []));
    }
    const vnode = newVNode(node.vtag, node.vtext);
    vnode.$attrs$ = node.vattrs;
    vnode.$children$ = node.vchildren;
    vnode.$key$ = node.vkey;
    vnode.$name$ = node.vname;
    return vnode;
};
const validateInputProperties = (vnodeData) => {
    const props = Object.keys(vnodeData);
    const typeIndex = props.indexOf('type');
    const minIndex = props.indexOf('min');
    const maxIndex = props.indexOf('max');
    const stepIndex = props.indexOf('min');
    const value = props.indexOf('value');
    if (value === -1) {
        return;
    }
    if (value < typeIndex || value < minIndex || value < maxIndex || value < stepIndex) {
        consoleDevWarn(`The "value" prop of <input> should be set after "min", "max", "type" and "step"`);
    }
};
/**
 * Production setAccessor() function based on Preact by
 * Jason Miller (@developit)
 * Licensed under the MIT License
 * https://github.com/developit/preact/blob/master/LICENSE
 *
 * Modified for Stencil's compiler and vdom
 */
const setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags) => {
    if (oldValue !== newValue) {
        let isProp = isMemberInElement(elm, memberName);
        let ln = memberName.toLowerCase();
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomClass && memberName === 'class') {
            const classList = elm.classList;
            const oldClasses = parseClassList(oldValue);
            const newClasses = parseClassList(newValue);
            classList.remove(...oldClasses.filter(c => c && !newClasses.includes(c)));
            classList.add(...newClasses.filter(c => c && !oldClasses.includes(c)));
        }
        else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomStyle && memberName === 'style') {
            // update style attribute, css properties and values
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable) {
                for (const prop in oldValue) {
                    if (!newValue || newValue[prop] == null) {
                        if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide && prop.includes('-')) {
                            elm.style.removeProperty(prop);
                        }
                        else {
                            elm.style[prop] = '';
                        }
                    }
                }
            }
            for (const prop in newValue) {
                if (!oldValue || newValue[prop] !== oldValue[prop]) {
                    if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide && prop.includes('-')) {
                        elm.style.setProperty(prop, newValue[prop]);
                    }
                    else {
                        elm.style[prop] = newValue[prop];
                    }
                }
            }
        }
        else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomKey && memberName === 'key')
            ;
        else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomRef && memberName === 'ref') {
            // minifier will clean this up
            if (newValue) {
                newValue(elm);
            }
        }
        else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomListener && (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad ? !isProp : !elm.__lookupSetter__(memberName)) && memberName[0] === 'o' && memberName[1] === 'n') {
            // Event Handlers
            // so if the member name starts with "on" and the 3rd characters is
            // a capital letter, and it's not already a member on the element,
            // then we're assuming it's an event listener
            if (memberName[2] === '-') {
                // on- prefixed events
                // allows to be explicit about the dom event to listen without any magic
                // under the hood:
                // <my-cmp on-click> // listens for "click"
                // <my-cmp on-Click> // listens for "Click"
                // <my-cmp on-ionChange> // listens for "ionChange"
                // <my-cmp on-EVENTS> // listens for "EVENTS"
                memberName = memberName.slice(3);
            }
            else if (isMemberInElement(win, ln)) {
                // standard event
                // the JSX attribute could have been "onMouseOver" and the
                // member name "onmouseover" is on the window's prototype
                // so let's add the listener "mouseover", which is all lowercased
                memberName = ln.slice(2);
            }
            else {
                // custom event
                // the JSX attribute could have been "onMyCustomEvent"
                // so let's trim off the "on" prefix and lowercase the first character
                // and add the listener "myCustomEvent"
                // except for the first character, we keep the event name case
                memberName = ln[2] + memberName.slice(3);
            }
            if (oldValue) {
                plt.rel(elm, memberName, oldValue, false);
            }
            if (newValue) {
                plt.ael(elm, memberName, newValue, false);
            }
        }
        else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomPropOrAttr) {
            // Set property if it exists and it's not a SVG
            const isComplex = isComplexType(newValue);
            if ((isProp || (isComplex && newValue !== null)) && !isSvg) {
                try {
                    if (!elm.tagName.includes('-')) {
                        let n = newValue == null ? '' : newValue;
                        // Workaround for Safari, moving the <input> caret when re-assigning the same valued
                        if (memberName === 'list') {
                            isProp = false;
                            // tslint:disable-next-line: triple-equals
                        }
                        else if (oldValue == null || elm[memberName] != n) {
                            elm[memberName] = n;
                        }
                    }
                    else {
                        elm[memberName] = newValue;
                    }
                }
                catch (e) { }
            }
            /**
             * Need to manually update attribute if:
             * - memberName is not an attribute
             * - if we are rendering the host element in order to reflect attribute
             * - if it's a SVG, since properties might not work in <svg>
             * - if the newValue is null/undefined or 'false'.
             */
            let xlink = false;
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomXlink) {
                if (ln !== (ln = ln.replace(/^xlink\:?/, ''))) {
                    memberName = ln;
                    xlink = true;
                }
            }
            if (newValue == null || newValue === false) {
                if (newValue !== false || elm.getAttribute(memberName) === '') {
                    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomXlink && xlink) {
                        elm.removeAttributeNS(XLINK_NS, memberName);
                    }
                    else {
                        elm.removeAttribute(memberName);
                    }
                }
            }
            else if ((!isProp || flags & 4 /* isHost */ || isSvg) && !isComplex) {
                newValue = newValue === true ? '' : newValue;
                if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomXlink && xlink) {
                    elm.setAttributeNS(XLINK_NS, memberName, newValue);
                }
                else {
                    elm.setAttribute(memberName, newValue);
                }
            }
        }
    }
};
const parseClassListRegex = /\s/;
const parseClassList = (value) => (!value ? [] : value.split(parseClassListRegex));
const updateElement = (oldVnode, newVnode, isSvgMode, memberName) => {
    // if the element passed in is a shadow root, which is a document fragment
    // then we want to be adding attrs/props to the shadow root's "host" element
    // if it's not a shadow root, then we add attrs/props to the same element
    const elm = newVnode.$elm$.nodeType === 11 /* DocumentFragment */ && newVnode.$elm$.host ? newVnode.$elm$.host : newVnode.$elm$;
    const oldVnodeAttrs = (oldVnode && oldVnode.$attrs$) || EMPTY_OBJ;
    const newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable) {
        // remove attributes no longer present on the vnode by setting them to undefined
        for (memberName in oldVnodeAttrs) {
            if (!(memberName in newVnodeAttrs)) {
                setAccessor(elm, memberName, oldVnodeAttrs[memberName], undefined, isSvgMode, newVnode.$flags$);
            }
        }
    }
    // add new & update changed attributes
    for (memberName in newVnodeAttrs) {
        setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode, newVnode.$flags$);
    }
};
const createElm = (oldParentVNode, newParentVNode, childIndex, parentElm) => {
    // tslint:disable-next-line: prefer-const
    let newVNode = newParentVNode.$children$[childIndex];
    let i = 0;
    let elm;
    let childNode;
    let oldVNode;
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation && !useNativeShadowDom) {
        // remember for later we need to check to relocate nodes
        checkSlotRelocate = true;
        if (newVNode.$tag$ === 'slot') {
            if (scopeId) {
                // scoped css needs to add its scoped id to the parent element
                parentElm.classList.add(scopeId + '-s');
            }
            newVNode.$flags$ |= newVNode.$children$
                ? // slot element has fallback content
                    2 /* isSlotFallback */
                : // slot element does not have fallback content
                    1 /* isSlotReference */;
        }
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev && newVNode.$elm$) {
        consoleDevError(`The JSX ${newVNode.$text$ !== null ? `"${newVNode.$text$}" text` : `"${newVNode.$tag$}" element`} node should not be shared within the same renderer. The renderer caches element lookups in order to improve performance. However, a side effect from this is that the exact same JSX node should not be reused. For more information please see https://stenciljs.com/docs/templating-jsx#avoid-shared-jsx-nodes`);
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomText && newVNode.$text$ !== null) {
        // create text node
        elm = newVNode.$elm$ = doc.createTextNode(newVNode.$text$);
    }
    else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation && newVNode.$flags$ & 1 /* isSlotReference */) {
        // create a slot reference node
        elm = newVNode.$elm$ = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDebug || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide ? slotReferenceDebugNode(newVNode) : doc.createTextNode('');
    }
    else {
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.svg && !isSvgMode) {
            isSvgMode = newVNode.$tag$ === 'svg';
        }
        // create element
        elm = newVNode.$elm$ = (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.svg
            ? doc.createElementNS(isSvgMode ? SVG_NS : HTML_NS, _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation && newVNode.$flags$ & 2 /* isSlotFallback */ ? 'slot-fb' : newVNode.$tag$)
            : doc.createElement(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation && newVNode.$flags$ & 2 /* isSlotFallback */ ? 'slot-fb' : newVNode.$tag$));
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.svg && isSvgMode && newVNode.$tag$ === 'foreignObject') {
            isSvgMode = false;
        }
        // add css classes, attrs, props, listeners, etc.
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomAttribute) {
            updateElement(null, newVNode, isSvgMode);
        }
        if ((_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.scoped) && isDef(scopeId) && elm['s-si'] !== scopeId) {
            // if there is a scopeId and this is the initial render
            // then let's add the scopeId as a css class
            elm.classList.add((elm['s-si'] = scopeId));
        }
        if (newVNode.$children$) {
            for (i = 0; i < newVNode.$children$.length; ++i) {
                // create the node
                childNode = createElm(oldParentVNode, newVNode, i, elm);
                // return node could have been null
                if (childNode) {
                    // append our new node
                    elm.appendChild(childNode);
                }
            }
        }
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.svg) {
            if (newVNode.$tag$ === 'svg') {
                // Only reset the SVG context when we're exiting <svg> element
                isSvgMode = false;
            }
            else if (elm.tagName === 'foreignObject') {
                // Reenter SVG context when we're exiting <foreignObject> element
                isSvgMode = true;
            }
        }
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation) {
        elm['s-hn'] = hostTagName;
        if (newVNode.$flags$ & (2 /* isSlotFallback */ | 1 /* isSlotReference */)) {
            // remember the content reference comment
            elm['s-sr'] = true;
            // remember the content reference comment
            elm['s-cr'] = contentRef;
            // remember the slot name, or empty string for default slot
            elm['s-sn'] = newVNode.$name$ || '';
            // check if we've got an old vnode for this slot
            oldVNode = oldParentVNode && oldParentVNode.$children$ && oldParentVNode.$children$[childIndex];
            if (oldVNode && oldVNode.$tag$ === newVNode.$tag$ && oldParentVNode.$elm$) {
                // we've got an old slot vnode and the wrapper is being replaced
                // so let's move the old slot content back to it's original location
                putBackInOriginalLocation(oldParentVNode.$elm$, false);
            }
        }
    }
    return elm;
};
const putBackInOriginalLocation = (parentElm, recursive) => {
    plt.$flags$ |= 1 /* isTmpDisconnected */;
    const oldSlotChildNodes = parentElm.childNodes;
    for (let i = oldSlotChildNodes.length - 1; i >= 0; i--) {
        const childNode = oldSlotChildNodes[i];
        if (childNode['s-hn'] !== hostTagName && childNode['s-ol']) {
            // // this child node in the old element is from another component
            // // remove this node from the old slot's parent
            // childNode.remove();
            // and relocate it back to it's original location
            parentReferenceNode(childNode).insertBefore(childNode, referenceNode(childNode));
            // remove the old original location comment entirely
            // later on the patch function will know what to do
            // and move this to the correct spot in need be
            childNode['s-ol'].remove();
            childNode['s-ol'] = undefined;
            checkSlotRelocate = true;
        }
        if (recursive) {
            putBackInOriginalLocation(childNode, recursive);
        }
    }
    plt.$flags$ &= ~1 /* isTmpDisconnected */;
};
const addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {
    let containerElm = ((_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation && parentElm['s-cr'] && parentElm['s-cr'].parentNode) || parentElm);
    let childNode;
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom && containerElm.shadowRoot && containerElm.tagName === hostTagName) {
        containerElm = containerElm.shadowRoot;
    }
    for (; startIdx <= endIdx; ++startIdx) {
        if (vnodes[startIdx]) {
            childNode = createElm(null, parentVNode, startIdx, parentElm);
            if (childNode) {
                vnodes[startIdx].$elm$ = childNode;
                containerElm.insertBefore(childNode, _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation ? referenceNode(before) : before);
            }
        }
    }
};
const removeVnodes = (vnodes, startIdx, endIdx, vnode, elm) => {
    for (; startIdx <= endIdx; ++startIdx) {
        if ((vnode = vnodes[startIdx])) {
            elm = vnode.$elm$;
            callNodeRefs(vnode);
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation) {
                // we're removing this element
                // so it's possible we need to show slot fallback content now
                checkSlotFallbackVisibility = true;
                if (elm['s-ol']) {
                    // remove the original location comment
                    elm['s-ol'].remove();
                }
                else {
                    // it's possible that child nodes of the node
                    // that's being removed are slot nodes
                    putBackInOriginalLocation(elm, true);
                }
            }
            // remove the vnode's element from the dom
            elm.remove();
        }
    }
};
const updateChildren = (parentElm, oldCh, newVNode, newCh) => {
    let oldStartIdx = 0;
    let newStartIdx = 0;
    let idxInOld = 0;
    let i = 0;
    let oldEndIdx = oldCh.length - 1;
    let oldStartVnode = oldCh[0];
    let oldEndVnode = oldCh[oldEndIdx];
    let newEndIdx = newCh.length - 1;
    let newStartVnode = newCh[0];
    let newEndVnode = newCh[newEndIdx];
    let node;
    let elmToMove;
    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
        if (oldStartVnode == null) {
            // Vnode might have been moved left
            oldStartVnode = oldCh[++oldStartIdx];
        }
        else if (oldEndVnode == null) {
            oldEndVnode = oldCh[--oldEndIdx];
        }
        else if (newStartVnode == null) {
            newStartVnode = newCh[++newStartIdx];
        }
        else if (newEndVnode == null) {
            newEndVnode = newCh[--newEndIdx];
        }
        else if (isSameVnode(oldStartVnode, newStartVnode)) {
            patch(oldStartVnode, newStartVnode);
            oldStartVnode = oldCh[++oldStartIdx];
            newStartVnode = newCh[++newStartIdx];
        }
        else if (isSameVnode(oldEndVnode, newEndVnode)) {
            patch(oldEndVnode, newEndVnode);
            oldEndVnode = oldCh[--oldEndIdx];
            newEndVnode = newCh[--newEndIdx];
        }
        else if (isSameVnode(oldStartVnode, newEndVnode)) {
            // Vnode moved right
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation && (oldStartVnode.$tag$ === 'slot' || newEndVnode.$tag$ === 'slot')) {
                putBackInOriginalLocation(oldStartVnode.$elm$.parentNode, false);
            }
            patch(oldStartVnode, newEndVnode);
            parentElm.insertBefore(oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);
            oldStartVnode = oldCh[++oldStartIdx];
            newEndVnode = newCh[--newEndIdx];
        }
        else if (isSameVnode(oldEndVnode, newStartVnode)) {
            // Vnode moved left
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation && (oldStartVnode.$tag$ === 'slot' || newEndVnode.$tag$ === 'slot')) {
                putBackInOriginalLocation(oldEndVnode.$elm$.parentNode, false);
            }
            patch(oldEndVnode, newStartVnode);
            parentElm.insertBefore(oldEndVnode.$elm$, oldStartVnode.$elm$);
            oldEndVnode = oldCh[--oldEndIdx];
            newStartVnode = newCh[++newStartIdx];
        }
        else {
            // createKeyToOldIdx
            idxInOld = -1;
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomKey) {
                for (i = oldStartIdx; i <= oldEndIdx; ++i) {
                    if (oldCh[i] && oldCh[i].$key$ !== null && oldCh[i].$key$ === newStartVnode.$key$) {
                        idxInOld = i;
                        break;
                    }
                }
            }
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomKey && idxInOld >= 0) {
                elmToMove = oldCh[idxInOld];
                if (elmToMove.$tag$ !== newStartVnode.$tag$) {
                    node = createElm(oldCh && oldCh[newStartIdx], newVNode, idxInOld, parentElm);
                }
                else {
                    patch(elmToMove, newStartVnode);
                    oldCh[idxInOld] = undefined;
                    node = elmToMove.$elm$;
                }
                newStartVnode = newCh[++newStartIdx];
            }
            else {
                // new element
                node = createElm(oldCh && oldCh[newStartIdx], newVNode, newStartIdx, parentElm);
                newStartVnode = newCh[++newStartIdx];
            }
            if (node) {
                if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation) {
                    parentReferenceNode(oldStartVnode.$elm$).insertBefore(node, referenceNode(oldStartVnode.$elm$));
                }
                else {
                    oldStartVnode.$elm$.parentNode.insertBefore(node, oldStartVnode.$elm$);
                }
            }
        }
    }
    if (oldStartIdx > oldEndIdx) {
        addVnodes(parentElm, newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$, newVNode, newCh, newStartIdx, newEndIdx);
    }
    else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable && newStartIdx > newEndIdx) {
        removeVnodes(oldCh, oldStartIdx, oldEndIdx);
    }
};
const isSameVnode = (vnode1, vnode2) => {
    // compare if two vnode to see if they're "technically" the same
    // need to have the same element tag, and same key to be the same
    if (vnode1.$tag$ === vnode2.$tag$) {
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation && vnode1.$tag$ === 'slot') {
            return vnode1.$name$ === vnode2.$name$;
        }
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomKey) {
            return vnode1.$key$ === vnode2.$key$;
        }
        return true;
    }
    return false;
};
const referenceNode = (node) => {
    // this node was relocated to a new location in the dom
    // because of some other component's slot
    // but we still have an html comment in place of where
    // it's original location was according to it's original vdom
    return (node && node['s-ol']) || node;
};
const parentReferenceNode = (node) => (node['s-ol'] ? node['s-ol'] : node).parentNode;
const patch = (oldVNode, newVNode) => {
    const elm = (newVNode.$elm$ = oldVNode.$elm$);
    const oldChildren = oldVNode.$children$;
    const newChildren = newVNode.$children$;
    const tag = newVNode.$tag$;
    const text = newVNode.$text$;
    let defaultHolder;
    if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomText || text === null) {
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.svg) {
            // test if we're rendering an svg element, or still rendering nodes inside of one
            // only add this to the when the compiler sees we're using an svg somewhere
            isSvgMode = tag === 'svg' ? true : tag === 'foreignObject' ? false : isSvgMode;
        }
        // element node
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomAttribute || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.reflect) {
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slot && tag === 'slot')
                ;
            else {
                // either this is the first render of an element OR it's an update
                // AND we already know it's possible it could have changed
                // this updates the element's css classes, attrs, props, listeners, etc.
                updateElement(oldVNode, newVNode, isSvgMode);
            }
        }
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable && oldChildren !== null && newChildren !== null) {
            // looks like there's child vnodes for both the old and new vnodes
            updateChildren(elm, oldChildren, newVNode, newChildren);
        }
        else if (newChildren !== null) {
            // no old child vnodes, but there are new child vnodes to add
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomText && oldVNode.$text$ !== null) {
                // the old vnode was text, so be sure to clear it out
                elm.textContent = '';
            }
            // add the new vnode children
            addVnodes(elm, null, newVNode, newChildren, 0, newChildren.length - 1);
        }
        else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable && oldChildren !== null) {
            // no new child vnodes, but there are old child vnodes to remove
            removeVnodes(oldChildren, 0, oldChildren.length - 1);
        }
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.svg && isSvgMode && tag === 'svg') {
            isSvgMode = false;
        }
    }
    else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomText && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation && (defaultHolder = elm['s-cr'])) {
        // this element has slotted content
        defaultHolder.parentNode.textContent = text;
    }
    else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomText && oldVNode.$text$ !== text) {
        // update the text content for the text only vnode
        // and also only if the text is different than before
        elm.data = text;
    }
};
const updateFallbackSlotVisibility = (elm) => {
    // tslint:disable-next-line: prefer-const
    let childNodes = elm.childNodes;
    let childNode;
    let i;
    let ilen;
    let j;
    let slotNameAttr;
    let nodeType;
    for (i = 0, ilen = childNodes.length; i < ilen; i++) {
        childNode = childNodes[i];
        if (childNode.nodeType === 1 /* ElementNode */) {
            if (childNode['s-sr']) {
                // this is a slot fallback node
                // get the slot name for this slot reference node
                slotNameAttr = childNode['s-sn'];
                // by default always show a fallback slot node
                // then hide it if there are other slots in the light dom
                childNode.hidden = false;
                for (j = 0; j < ilen; j++) {
                    nodeType = childNodes[j].nodeType;
                    if (childNodes[j]['s-hn'] !== childNode['s-hn'] || slotNameAttr !== '') {
                        // this sibling node is from a different component OR is a named fallback slot node
                        if (nodeType === 1 /* ElementNode */ && slotNameAttr === childNodes[j].getAttribute('slot')) {
                            childNode.hidden = true;
                            break;
                        }
                    }
                    else {
                        // this is a default fallback slot node
                        // any element or text node (with content)
                        // should hide the default fallback slot node
                        if (nodeType === 1 /* ElementNode */ ||
                            (nodeType === 3 /* TextNode */ && childNodes[j].textContent.trim() !== '')) {
                            childNode.hidden = true;
                            break;
                        }
                    }
                }
            }
            // keep drilling down
            updateFallbackSlotVisibility(childNode);
        }
    }
};
const relocateNodes = [];
const relocateSlotContent = (elm) => {
    // tslint:disable-next-line: prefer-const
    let childNode;
    let node;
    let hostContentNodes;
    let slotNameAttr;
    let relocateNodeData;
    let j;
    let i = 0;
    let childNodes = elm.childNodes;
    let ilen = childNodes.length;
    for (; i < ilen; i++) {
        childNode = childNodes[i];
        if (childNode['s-sr'] && (node = childNode['s-cr']) && node.parentNode) {
            // first got the content reference comment node
            // then we got it's parent, which is where all the host content is in now
            hostContentNodes = node.parentNode.childNodes;
            slotNameAttr = childNode['s-sn'];
            for (j = hostContentNodes.length - 1; j >= 0; j--) {
                node = hostContentNodes[j];
                if (!node['s-cn'] && !node['s-nr'] && node['s-hn'] !== childNode['s-hn']) {
                    // let's do some relocating to its new home
                    // but never relocate a content reference node
                    // that is suppose to always represent the original content location
                    if (isNodeLocatedInSlot(node, slotNameAttr)) {
                        // it's possible we've already decided to relocate this node
                        relocateNodeData = relocateNodes.find(r => r.$nodeToRelocate$ === node);
                        // made some changes to slots
                        // let's make sure we also double check
                        // fallbacks are correctly hidden or shown
                        checkSlotFallbackVisibility = true;
                        node['s-sn'] = node['s-sn'] || slotNameAttr;
                        if (relocateNodeData) {
                            // previously we never found a slot home for this node
                            // but turns out we did, so let's remember it now
                            relocateNodeData.$slotRefNode$ = childNode;
                        }
                        else {
                            // add to our list of nodes to relocate
                            relocateNodes.push({
                                $slotRefNode$: childNode,
                                $nodeToRelocate$: node,
                            });
                        }
                        if (node['s-sr']) {
                            relocateNodes.map(relocateNode => {
                                if (isNodeLocatedInSlot(relocateNode.$nodeToRelocate$, node['s-sn'])) {
                                    relocateNodeData = relocateNodes.find(r => r.$nodeToRelocate$ === node);
                                    if (relocateNodeData && !relocateNode.$slotRefNode$) {
                                        relocateNode.$slotRefNode$ = relocateNodeData.$slotRefNode$;
                                    }
                                }
                            });
                        }
                    }
                    else if (!relocateNodes.some(r => r.$nodeToRelocate$ === node)) {
                        // so far this element does not have a slot home, not setting slotRefNode on purpose
                        // if we never find a home for this element then we'll need to hide it
                        relocateNodes.push({
                            $nodeToRelocate$: node,
                        });
                    }
                }
            }
        }
        if (childNode.nodeType === 1 /* ElementNode */) {
            relocateSlotContent(childNode);
        }
    }
};
const isNodeLocatedInSlot = (nodeToRelocate, slotNameAttr) => {
    if (nodeToRelocate.nodeType === 1 /* ElementNode */) {
        if (nodeToRelocate.getAttribute('slot') === null && slotNameAttr === '') {
            return true;
        }
        if (nodeToRelocate.getAttribute('slot') === slotNameAttr) {
            return true;
        }
        return false;
    }
    if (nodeToRelocate['s-sn'] === slotNameAttr) {
        return true;
    }
    return slotNameAttr === '';
};
const callNodeRefs = (vNode) => {
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomRef) {
        vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);
        vNode.$children$ && vNode.$children$.map(callNodeRefs);
    }
};
const renderVdom = (hostRef, renderFnResults) => {
    const hostElm = hostRef.$hostElement$;
    const cmpMeta = hostRef.$cmpMeta$;
    const oldVNode = hostRef.$vnode$ || newVNode(null, null);
    const rootVnode = isHost(renderFnResults) ? renderFnResults : h(null, null, renderFnResults);
    hostTagName = hostElm.tagName;
    // <Host> runtime check
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev && Array.isArray(renderFnResults) && renderFnResults.some(isHost)) {
        throw new Error(`The <Host> must be the single root component.
Looks like the render() function of "${hostTagName.toLowerCase()}" is returning an array that contains the <Host>.

The render() function should look like this instead:

render() {
  // Do not return an array
  return (
    <Host>{content}</Host>
  );
}
  `);
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.reflect && cmpMeta.$attrsToReflect$) {
        rootVnode.$attrs$ = rootVnode.$attrs$ || {};
        cmpMeta.$attrsToReflect$.map(([propName, attribute]) => (rootVnode.$attrs$[attribute] = hostElm[propName]));
    }
    rootVnode.$tag$ = null;
    rootVnode.$flags$ |= 4 /* isHost */;
    hostRef.$vnode$ = rootVnode;
    rootVnode.$elm$ = oldVNode.$elm$ = (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom ? hostElm.shadowRoot || hostElm : hostElm);
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.scoped || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom) {
        scopeId = hostElm['s-sc'];
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation) {
        contentRef = hostElm['s-cr'];
        useNativeShadowDom = supportsShadow && (cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) !== 0;
        // always reset
        checkSlotFallbackVisibility = false;
    }
    // synchronous patch
    patch(oldVNode, rootVnode);
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation) {
        // while we're moving nodes around existing nodes, temporarily disable
        // the disconnectCallback from working
        plt.$flags$ |= 1 /* isTmpDisconnected */;
        if (checkSlotRelocate) {
            relocateSlotContent(rootVnode.$elm$);
            let relocateData;
            let nodeToRelocate;
            let orgLocationNode;
            let parentNodeRef;
            let insertBeforeNode;
            let refNode;
            let i = 0;
            for (; i < relocateNodes.length; i++) {
                relocateData = relocateNodes[i];
                nodeToRelocate = relocateData.$nodeToRelocate$;
                if (!nodeToRelocate['s-ol']) {
                    // add a reference node marking this node's original location
                    // keep a reference to this node for later lookups
                    orgLocationNode = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDebug || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide ? originalLocationDebugNode(nodeToRelocate) : doc.createTextNode('');
                    orgLocationNode['s-nr'] = nodeToRelocate;
                    nodeToRelocate.parentNode.insertBefore((nodeToRelocate['s-ol'] = orgLocationNode), nodeToRelocate);
                }
            }
            for (i = 0; i < relocateNodes.length; i++) {
                relocateData = relocateNodes[i];
                nodeToRelocate = relocateData.$nodeToRelocate$;
                if (relocateData.$slotRefNode$) {
                    // by default we're just going to insert it directly
                    // after the slot reference node
                    parentNodeRef = relocateData.$slotRefNode$.parentNode;
                    insertBeforeNode = relocateData.$slotRefNode$.nextSibling;
                    orgLocationNode = nodeToRelocate['s-ol'];
                    while ((orgLocationNode = orgLocationNode.previousSibling)) {
                        refNode = orgLocationNode['s-nr'];
                        if (refNode && refNode['s-sn'] === nodeToRelocate['s-sn'] && parentNodeRef === refNode.parentNode) {
                            refNode = refNode.nextSibling;
                            if (!refNode || !refNode['s-nr']) {
                                insertBeforeNode = refNode;
                                break;
                            }
                        }
                    }
                    if ((!insertBeforeNode && parentNodeRef !== nodeToRelocate.parentNode) || nodeToRelocate.nextSibling !== insertBeforeNode) {
                        // we've checked that it's worth while to relocate
                        // since that the node to relocate
                        // has a different next sibling or parent relocated
                        if (nodeToRelocate !== insertBeforeNode) {
                            if (!nodeToRelocate['s-hn'] && nodeToRelocate['s-ol']) {
                                // probably a component in the index.html that doesn't have it's hostname set
                                nodeToRelocate['s-hn'] = nodeToRelocate['s-ol'].parentNode.nodeName;
                            }
                            // add it back to the dom but in its new home
                            parentNodeRef.insertBefore(nodeToRelocate, insertBeforeNode);
                        }
                    }
                }
                else {
                    // this node doesn't have a slot home to go to, so let's hide it
                    if (nodeToRelocate.nodeType === 1 /* ElementNode */) {
                        nodeToRelocate.hidden = true;
                    }
                }
            }
        }
        if (checkSlotFallbackVisibility) {
            updateFallbackSlotVisibility(rootVnode.$elm$);
        }
        // done moving nodes around
        // allow the disconnect callback to work again
        plt.$flags$ &= ~1 /* isTmpDisconnected */;
        // always reset
        relocateNodes.length = 0;
    }
};
// slot comment debug nodes only created with the `--debug` flag
// otherwise these nodes are text nodes w/out content
const slotReferenceDebugNode = (slotVNode) => doc.createComment(`<slot${slotVNode.$name$ ? ' name="' + slotVNode.$name$ + '"' : ''}> (host=${hostTagName.toLowerCase()})`);
const originalLocationDebugNode = (nodeToRelocate) => doc.createComment(`org-location for ` + (nodeToRelocate.localName ? `<${nodeToRelocate.localName}> (host=${nodeToRelocate['s-hn']})` : `[${nodeToRelocate.textContent}]`));
const getElement = (ref) => (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad ? getHostRef(ref).$hostElement$ : ref);
const createEvent = (ref, name, flags) => {
    const elm = getElement(ref);
    return {
        emit: (detail) => {
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev && !elm.isConnected) {
                consoleDevWarn(`The "${name}" event was emitted, but the dispatcher node is no longer connected to the dom.`);
            }
            return emitEvent(elm, name, {
                bubbles: !!(flags & 4 /* Bubbles */),
                composed: !!(flags & 2 /* Composed */),
                cancelable: !!(flags & 1 /* Cancellable */),
                detail,
            });
        },
    };
};
const emitEvent = (elm, name, opts) => {
    const ev = plt.ce(name, opts);
    elm.dispatchEvent(ev);
    return ev;
};
const attachToAncestor = (hostRef, ancestorComponent) => {
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading && ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent['s-p']) {
        ancestorComponent['s-p'].push(new Promise(r => (hostRef.$onRenderResolve$ = r)));
    }
};
const scheduleUpdate = (hostRef, isInitialLoad) => {
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.taskQueue && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable) {
        hostRef.$flags$ |= 16 /* isQueuedForUpdate */;
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading && hostRef.$flags$ & 4 /* isWaitingForChildren */) {
        hostRef.$flags$ |= 512 /* needsRerender */;
        return;
    }
    attachToAncestor(hostRef, hostRef.$ancestorComponent$);
    // there is no ancestor component or the ancestor component
    // has already fired off its lifecycle update then
    // fire off the initial update
    const dispatch = () => dispatchHooks(hostRef, isInitialLoad);
    return _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.taskQueue ? writeTask(dispatch) : dispatch();
};
const dispatchHooks = (hostRef, isInitialLoad) => {
    const elm = hostRef.$hostElement$;
    const endSchedule = createTime('scheduleUpdate', hostRef.$cmpMeta$.$tagName$);
    const instance = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;
    let promise;
    if (isInitialLoad) {
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListener) {
            hostRef.$flags$ |= 256 /* isListenReady */;
            if (hostRef.$queuedListeners$) {
                hostRef.$queuedListeners$.map(([methodName, event]) => safeCall(instance, methodName, event));
                hostRef.$queuedListeners$ = null;
            }
        }
        emitLifecycleEvent(elm, 'componentWillLoad');
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cmpWillLoad) {
            promise = safeCall(instance, 'componentWillLoad');
        }
    }
    else {
        emitLifecycleEvent(elm, 'componentWillUpdate');
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cmpWillUpdate) {
            promise = safeCall(instance, 'componentWillUpdate');
        }
    }
    emitLifecycleEvent(elm, 'componentWillRender');
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cmpWillRender) {
        promise = then(promise, () => safeCall(instance, 'componentWillRender'));
    }
    endSchedule();
    return then(promise, () => updateComponent(hostRef, instance, isInitialLoad));
};
const updateComponent = async (hostRef, instance, isInitialLoad) => {
    // updateComponent
    const elm = hostRef.$hostElement$;
    const endUpdate = createTime('update', hostRef.$cmpMeta$.$tagName$);
    const rc = elm['s-rc'];
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.style && isInitialLoad) {
        // DOM WRITE!
        attachStyles(hostRef);
    }
    const endRender = createTime('render', hostRef.$cmpMeta$.$tagName$);
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev) {
        hostRef.$flags$ |= 1024 /* devOnRender */;
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide) {
        await callRender(hostRef, instance, elm);
    }
    else {
        callRender(hostRef, instance, elm);
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cssVarShim && plt.$cssShim$) {
        plt.$cssShim$.updateHost(elm);
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev) {
        hostRef.$renderCount$++;
        hostRef.$flags$ &= ~1024 /* devOnRender */;
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide) {
        try {
            // manually connected child components during server-side hydrate
            serverSideConnected(elm);
            if (isInitialLoad) {
                // using only during server-side hydrate
                if (hostRef.$cmpMeta$.$flags$ & 1 /* shadowDomEncapsulation */) {
                    elm['s-en'] = '';
                }
                else if (hostRef.$cmpMeta$.$flags$ & 2 /* scopedCssEncapsulation */) {
                    elm['s-en'] = 'c';
                }
            }
        }
        catch (e) {
            consoleError(e, elm);
        }
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading && rc) {
        // ok, so turns out there are some child host elements
        // waiting on this parent element to load
        // let's fire off all update callbacks waiting
        rc.map(cb => cb());
        elm['s-rc'] = undefined;
    }
    endRender();
    endUpdate();
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading) {
        const childrenPromises = elm['s-p'];
        const postUpdate = () => postUpdateComponent(hostRef);
        if (childrenPromises.length === 0) {
            postUpdate();
        }
        else {
            Promise.all(childrenPromises).then(postUpdate);
            hostRef.$flags$ |= 4 /* isWaitingForChildren */;
            childrenPromises.length = 0;
        }
    }
    else {
        postUpdateComponent(hostRef);
    }
};
const callRender = (hostRef, instance, elm) => {
    // in order for bundlers to correctly treeshake the BUILD object
    // we need to ensure BUILD is not deoptimized within a try/catch
    // https://rollupjs.org/guide/en/#treeshake tryCatchDeoptimization
    const allRenderFn = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.allRenderFn ? true : false;
    const lazyLoad = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad ? true : false;
    const taskQueue = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.taskQueue ? true : false;
    const updatable = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable ? true : false;
    try {
        renderingRef = instance;
        instance = allRenderFn ? instance.render() : instance.render && instance.render();
        if (updatable && taskQueue) {
            hostRef.$flags$ &= ~16 /* isQueuedForUpdate */;
        }
        if (updatable || lazyLoad) {
            hostRef.$flags$ |= 2 /* hasRendered */;
        }
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hasRenderFn || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.reflect) {
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.vdomRender || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.reflect) {
                // looks like we've got child nodes to render into this host element
                // or we need to update the css class/attrs on the host element
                // DOM WRITE!
                if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide) {
                    return Promise.resolve(instance).then(value => renderVdom(hostRef, value));
                }
                else {
                    renderVdom(hostRef, instance);
                }
            }
            else {
                elm.textContent = instance;
            }
        }
    }
    catch (e) {
        consoleError(e, hostRef.$hostElement$);
    }
    renderingRef = null;
    return null;
};
const getRenderingRef = () => renderingRef;
const postUpdateComponent = (hostRef) => {
    const tagName = hostRef.$cmpMeta$.$tagName$;
    const elm = hostRef.$hostElement$;
    const endPostUpdate = createTime('postUpdate', tagName);
    const instance = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;
    const ancestorComponent = hostRef.$ancestorComponent$;
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cmpDidRender) {
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev) {
            hostRef.$flags$ |= 1024 /* devOnRender */;
        }
        safeCall(instance, 'componentDidRender');
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev) {
            hostRef.$flags$ &= ~1024 /* devOnRender */;
        }
    }
    emitLifecycleEvent(elm, 'componentDidRender');
    if (!(hostRef.$flags$ & 64 /* hasLoadedComponent */)) {
        hostRef.$flags$ |= 64 /* hasLoadedComponent */;
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cssAnnotations) {
            // DOM WRITE!
            addHydratedFlag(elm);
        }
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cmpDidLoad) {
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev) {
                hostRef.$flags$ |= 2048 /* devOnDidLoad */;
            }
            safeCall(instance, 'componentDidLoad');
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev) {
                hostRef.$flags$ &= ~2048 /* devOnDidLoad */;
            }
        }
        emitLifecycleEvent(elm, 'componentDidLoad');
        endPostUpdate();
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading) {
            hostRef.$onReadyResolve$(elm);
            if (!ancestorComponent) {
                appDidLoad(tagName);
            }
        }
    }
    else {
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cmpDidUpdate) {
            // we've already loaded this component
            // fire off the user's componentDidUpdate method (if one was provided)
            // componentDidUpdate runs AFTER render() has been called
            // and all child components have finished updating
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev) {
                hostRef.$flags$ |= 1024 /* devOnRender */;
            }
            safeCall(instance, 'componentDidUpdate');
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev) {
                hostRef.$flags$ &= ~1024 /* devOnRender */;
            }
        }
        emitLifecycleEvent(elm, 'componentDidUpdate');
        endPostUpdate();
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hotModuleReplacement) {
        elm['s-hmr-load'] && elm['s-hmr-load']();
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.method && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad) {
        hostRef.$onInstanceResolve$(elm);
    }
    // load events fire from bottom to top
    // the deepest elements load first then bubbles up
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading) {
        if (hostRef.$onRenderResolve$) {
            hostRef.$onRenderResolve$();
            hostRef.$onRenderResolve$ = undefined;
        }
        if (hostRef.$flags$ & 512 /* needsRerender */) {
            nextTick(() => scheduleUpdate(hostRef, false));
        }
        hostRef.$flags$ &= ~(4 /* isWaitingForChildren */ | 512 /* needsRerender */);
    }
    // ( _)
    // ( _)>-
    // (_)
};
const forceUpdate = (ref) => {
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable) {
        const hostRef = getHostRef(ref);
        const isConnected = hostRef.$hostElement$.isConnected;
        if (isConnected && (hostRef.$flags$ & (2 /* hasRendered */ | 16 /* isQueuedForUpdate */)) === 2 /* hasRendered */) {
            scheduleUpdate(hostRef, false);
        }
        // Returns "true" when the forced update was successfully scheduled
        return isConnected;
    }
    return false;
};
const appDidLoad = (who) => {
    // on appload
    // we have finish the first big initial render
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cssAnnotations) {
        addHydratedFlag(doc.documentElement);
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncQueue) {
        plt.$flags$ |= 2 /* appLoaded */;
    }
    nextTick(() => emitEvent(win, 'appload', { detail: { namespace: _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.NAMESPACE } }));
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.profile && performance.measure) {
        performance.measure(`[Stencil] ${_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.NAMESPACE} initial load (by ${who})`, 'st:app:start');
    }
};
const safeCall = (instance, method, arg) => {
    if (instance && instance[method]) {
        try {
            return instance[method](arg);
        }
        catch (e) {
            consoleError(e);
        }
    }
    return undefined;
};
const then = (promise, thenFn) => {
    return promise && promise.then ? promise.then(thenFn) : thenFn();
};
const emitLifecycleEvent = (elm, lifecycleName) => {
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lifecycleDOMEvents) {
        emitEvent(elm, 'stencil_' + lifecycleName, {
            bubbles: true,
            composed: true,
            detail: {
                namespace: _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.NAMESPACE,
            },
        });
    }
};
const addHydratedFlag = (elm) => (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydratedClass ? elm.classList.add('hydrated') : _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydratedAttribute ? elm.setAttribute('hydrated', '') : undefined);
const serverSideConnected = (elm) => {
    const children = elm.children;
    if (children != null) {
        for (let i = 0, ii = children.length; i < ii; i++) {
            const childElm = children[i];
            if (typeof childElm.connectedCallback === 'function') {
                childElm.connectedCallback();
            }
            serverSideConnected(childElm);
        }
    }
};
const initializeClientHydrate = (hostElm, tagName, hostId, hostRef) => {
    const endHydrate = createTime('hydrateClient', tagName);
    const shadowRoot = hostElm.shadowRoot;
    const childRenderNodes = [];
    const slotNodes = [];
    const shadowRootNodes = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom && shadowRoot ? [] : null;
    const vnode = (hostRef.$vnode$ = newVNode(tagName, null));
    if (!plt.$orgLocNodes$) {
        initializeDocumentHydrate(doc.body, (plt.$orgLocNodes$ = new Map()));
    }
    hostElm[HYDRATE_ID] = hostId;
    hostElm.removeAttribute(HYDRATE_ID);
    clientHydrate(vnode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, hostElm, hostId);
    childRenderNodes.map(c => {
        const orgLocationId = c.$hostId$ + '.' + c.$nodeId$;
        const orgLocationNode = plt.$orgLocNodes$.get(orgLocationId);
        const node = c.$elm$;
        if (orgLocationNode && supportsShadow && orgLocationNode['s-en'] === '') {
            orgLocationNode.parentNode.insertBefore(node, orgLocationNode.nextSibling);
        }
        if (!shadowRoot) {
            node['s-hn'] = tagName;
            if (orgLocationNode) {
                node['s-ol'] = orgLocationNode;
                node['s-ol']['s-nr'] = node;
            }
        }
        plt.$orgLocNodes$.delete(orgLocationId);
    });
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom && shadowRoot) {
        shadowRootNodes.map(shadowRootNode => {
            if (shadowRootNode) {
                shadowRoot.appendChild(shadowRootNode);
            }
        });
    }
    endHydrate();
};
const clientHydrate = (parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node, hostId) => {
    let childNodeType;
    let childIdSplt;
    let childVNode;
    let i;
    if (node.nodeType === 1 /* ElementNode */) {
        childNodeType = node.getAttribute(HYDRATE_CHILD_ID);
        if (childNodeType) {
            // got the node data from the element's attribute
            // `${hostId}.${nodeId}.${depth}.${index}`
            childIdSplt = childNodeType.split('.');
            if (childIdSplt[0] === hostId || childIdSplt[0] === '0') {
                childVNode = {
                    $flags$: 0,
                    $hostId$: childIdSplt[0],
                    $nodeId$: childIdSplt[1],
                    $depth$: childIdSplt[2],
                    $index$: childIdSplt[3],
                    $tag$: node.tagName.toLowerCase(),
                    $elm$: node,
                    $attrs$: null,
                    $children$: null,
                    $key$: null,
                    $name$: null,
                    $text$: null,
                };
                childRenderNodes.push(childVNode);
                node.removeAttribute(HYDRATE_CHILD_ID);
                // this is a new child vnode
                // so ensure its parent vnode has the vchildren array
                if (!parentVNode.$children$) {
                    parentVNode.$children$ = [];
                }
                // add our child vnode to a specific index of the vnode's children
                parentVNode.$children$[childVNode.$index$] = childVNode;
                // this is now the new parent vnode for all the next child checks
                parentVNode = childVNode;
                if (shadowRootNodes && childVNode.$depth$ === '0') {
                    shadowRootNodes[childVNode.$index$] = childVNode.$elm$;
                }
            }
        }
        // recursively drill down, end to start so we can remove nodes
        for (i = node.childNodes.length - 1; i >= 0; i--) {
            clientHydrate(parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node.childNodes[i], hostId);
        }
        if (node.shadowRoot) {
            // keep drilling down through the shadow root nodes
            for (i = node.shadowRoot.childNodes.length - 1; i >= 0; i--) {
                clientHydrate(parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node.shadowRoot.childNodes[i], hostId);
            }
        }
    }
    else if (node.nodeType === 8 /* CommentNode */) {
        // `${COMMENT_TYPE}.${hostId}.${nodeId}.${depth}.${index}`
        childIdSplt = node.nodeValue.split('.');
        if (childIdSplt[1] === hostId || childIdSplt[1] === '0') {
            // comment node for either the host id or a 0 host id
            childNodeType = childIdSplt[0];
            childVNode = {
                $flags$: 0,
                $hostId$: childIdSplt[1],
                $nodeId$: childIdSplt[2],
                $depth$: childIdSplt[3],
                $index$: childIdSplt[4],
                $elm$: node,
                $attrs$: null,
                $children$: null,
                $key$: null,
                $name$: null,
                $tag$: null,
                $text$: null,
            };
            if (childNodeType === TEXT_NODE_ID) {
                childVNode.$elm$ = node.nextSibling;
                if (childVNode.$elm$ && childVNode.$elm$.nodeType === 3 /* TextNode */) {
                    childVNode.$text$ = childVNode.$elm$.textContent;
                    childRenderNodes.push(childVNode);
                    // remove the text comment since it's no longer needed
                    node.remove();
                    if (!parentVNode.$children$) {
                        parentVNode.$children$ = [];
                    }
                    parentVNode.$children$[childVNode.$index$] = childVNode;
                    if (shadowRootNodes && childVNode.$depth$ === '0') {
                        shadowRootNodes[childVNode.$index$] = childVNode.$elm$;
                    }
                }
            }
            else if (childVNode.$hostId$ === hostId) {
                // this comment node is specifcally for this host id
                if (childNodeType === SLOT_NODE_ID) {
                    // `${SLOT_NODE_ID}.${hostId}.${nodeId}.${depth}.${index}.${slotName}`;
                    childVNode.$tag$ = 'slot';
                    if (childIdSplt[5]) {
                        node['s-sn'] = childVNode.$name$ = childIdSplt[5];
                    }
                    else {
                        node['s-sn'] = '';
                    }
                    node['s-sr'] = true;
                    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom && shadowRootNodes) {
                        // browser support shadowRoot and this is a shadow dom component
                        // create an actual slot element
                        childVNode.$elm$ = doc.createElement(childVNode.$tag$);
                        if (childVNode.$name$) {
                            // add the slot name attribute
                            childVNode.$elm$.setAttribute('name', childVNode.$name$);
                        }
                        // insert the new slot element before the slot comment
                        node.parentNode.insertBefore(childVNode.$elm$, node);
                        // remove the slot comment since it's not needed for shadow
                        node.remove();
                        if (childVNode.$depth$ === '0') {
                            shadowRootNodes[childVNode.$index$] = childVNode.$elm$;
                        }
                    }
                    slotNodes.push(childVNode);
                    if (!parentVNode.$children$) {
                        parentVNode.$children$ = [];
                    }
                    parentVNode.$children$[childVNode.$index$] = childVNode;
                }
                else if (childNodeType === CONTENT_REF_ID) {
                    // `${CONTENT_REF_ID}.${hostId}`;
                    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom && shadowRootNodes) {
                        // remove the content ref comment since it's not needed for shadow
                        node.remove();
                    }
                    else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation) {
                        hostElm['s-cr'] = node;
                        node['s-cn'] = true;
                    }
                }
            }
        }
    }
    else if (parentVNode && parentVNode.$tag$ === 'style') {
        const vnode = newVNode(null, node.textContent);
        vnode.$elm$ = node;
        vnode.$index$ = '0';
        parentVNode.$children$ = [vnode];
    }
};
const initializeDocumentHydrate = (node, orgLocNodes) => {
    if (node.nodeType === 1 /* ElementNode */) {
        let i = 0;
        for (; i < node.childNodes.length; i++) {
            initializeDocumentHydrate(node.childNodes[i], orgLocNodes);
        }
        if (node.shadowRoot) {
            for (i = 0; i < node.shadowRoot.childNodes.length; i++) {
                initializeDocumentHydrate(node.shadowRoot.childNodes[i], orgLocNodes);
            }
        }
    }
    else if (node.nodeType === 8 /* CommentNode */) {
        const childIdSplt = node.nodeValue.split('.');
        if (childIdSplt[0] === ORG_LOCATION_ID) {
            orgLocNodes.set(childIdSplt[1] + '.' + childIdSplt[2], node);
            node.nodeValue = '';
            // useful to know if the original location is
            // the root light-dom of a shadow dom component
            node['s-en'] = childIdSplt[3];
        }
    }
};
const parsePropertyValue = (propValue, propType) => {
    // ensure this value is of the correct prop type
    if (propValue != null && !isComplexType(propValue)) {
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.propBoolean && propType & 4 /* Boolean */) {
            // per the HTML spec, any string value means it is a boolean true value
            // but we'll cheat here and say that the string "false" is the boolean false
            return propValue === 'false' ? false : propValue === '' || !!propValue;
        }
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.propNumber && propType & 2 /* Number */) {
            // force it to be a number
            return parseFloat(propValue);
        }
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.propString && propType & 1 /* String */) {
            // could have been passed as a number or boolean
            // but we still want it as a string
            return String(propValue);
        }
        // redundant return here for better minification
        return propValue;
    }
    // not sure exactly what type we want
    // so no need to change to a different type
    return propValue;
};
const getValue = (ref, propName) => getHostRef(ref).$instanceValues$.get(propName);
const setValue = (ref, propName, newVal, cmpMeta) => {
    // check our new property value against our internal value
    const hostRef = getHostRef(ref);
    const elm = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad ? hostRef.$hostElement$ : ref;
    const oldVal = hostRef.$instanceValues$.get(propName);
    const flags = hostRef.$flags$;
    const instance = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;
    newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);
    if ((!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad || !(flags & 8 /* isConstructingInstance */) || oldVal === undefined) && newVal !== oldVal) {
        // gadzooks! the property's value has changed!!
        // set our new value!
        hostRef.$instanceValues$.set(propName, newVal);
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev) {
            if (hostRef.$flags$ & 1024 /* devOnRender */) {
                consoleDevWarn(`The state/prop "${propName}" changed during rendering. This can potentially lead to infinite-loops and other bugs.`, '\nElement', elm, '\nNew value', newVal, '\nOld value', oldVal);
            }
            else if (hostRef.$flags$ & 2048 /* devOnDidLoad */) {
                consoleDevWarn(`The state/prop "${propName}" changed during "componentDidLoad()", this triggers extra re-renders, try to setup on "componentWillLoad()"`, '\nElement', elm, '\nNew value', newVal, '\nOld value', oldVal);
            }
        }
        if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad || instance) {
            // get an array of method names of watch functions to call
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.watchCallback && cmpMeta.$watchers$ && flags & 128 /* isWatchReady */) {
                const watchMethods = cmpMeta.$watchers$[propName];
                if (watchMethods) {
                    // this instance is watching for when this property changed
                    watchMethods.map(watchMethodName => {
                        try {
                            // fire off each of the watch methods that are watching this property
                            instance[watchMethodName](newVal, oldVal, propName);
                        }
                        catch (e) {
                            consoleError(e, elm);
                        }
                    });
                }
            }
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.updatable && (flags & (2 /* hasRendered */ | 16 /* isQueuedForUpdate */)) === 2 /* hasRendered */) {
                if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cmpShouldUpdate && instance.componentShouldUpdate) {
                    if (instance.componentShouldUpdate(newVal, oldVal, propName) === false) {
                        return;
                    }
                }
                // looks like this value actually changed, so we've got work to do!
                // but only if we've already rendered, otherwise just chill out
                // queue that we need to do an update, but don't worry about queuing
                // up millions cuz this function ensures it only runs once
                scheduleUpdate(hostRef, false);
            }
        }
    }
};
const proxyComponent = (Cstr, cmpMeta, flags) => {
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.member && cmpMeta.$members$) {
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.watchCallback && Cstr.watchers) {
            cmpMeta.$watchers$ = Cstr.watchers;
        }
        // It's better to have a const than two Object.entries()
        const members = Object.entries(cmpMeta.$members$);
        const prototype = Cstr.prototype;
        members.map(([memberName, [memberFlags]]) => {
            if ((_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.prop || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.state) && (memberFlags & 31 /* Prop */ || ((!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad || flags & 2 /* proxyState */) && memberFlags & 32 /* State */))) {
                // proxyComponent - prop
                Object.defineProperty(prototype, memberName, {
                    get() {
                        // proxyComponent, get value
                        return getValue(this, memberName);
                    },
                    set(newValue) {
                        // only during dev time
                        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev) {
                            const ref = getHostRef(this);
                            if (
                            // we are proxying the instance (not element)
                            (flags & 1 /* isElementConstructor */) === 0 &&
                                // the element is not constructing
                                (ref.$flags$ & 8 /* isConstructingInstance */) === 0 &&
                                // the member is a prop
                                (memberFlags & 31 /* Prop */) !== 0 &&
                                // the member is not mutable
                                (memberFlags & 1024 /* Mutable */) === 0) {
                                consoleDevWarn(`@Prop() "${memberName}" on <${cmpMeta.$tagName$}> is immutable but was modified from within the component.\nMore information: https://stenciljs.com/docs/properties#prop-mutability`);
                            }
                        }
                        // proxyComponent, set value
                        setValue(this, memberName, newValue, cmpMeta);
                    },
                    configurable: true,
                    enumerable: true,
                });
            }
            else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.method && flags & 1 /* isElementConstructor */ && memberFlags & 64 /* Method */) {
                // proxyComponent - method
                Object.defineProperty(prototype, memberName, {
                    value(...args) {
                        const ref = getHostRef(this);
                        return ref.$onInstancePromise$.then(() => ref.$lazyInstance$[memberName](...args));
                    },
                });
            }
        });
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.observeAttribute && (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad || flags & 1 /* isElementConstructor */)) {
            const attrNameToPropName = new Map();
            prototype.attributeChangedCallback = function (attrName, _oldValue, newValue) {
                plt.jmp(() => {
                    const propName = attrNameToPropName.get(attrName);
                    this[propName] = newValue === null && typeof this[propName] === 'boolean' ? false : newValue;
                });
            };
            // create an array of attributes to observe
            // and also create a map of html attribute name to js property name
            Cstr.observedAttributes = members
                .filter(([_, m]) => m[0] & 15 /* HasAttribute */) // filter to only keep props that should match attributes
                .map(([propName, m]) => {
                const attrName = m[1] || propName;
                attrNameToPropName.set(attrName, propName);
                if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.reflect && m[0] & 512 /* ReflectAttr */) {
                    cmpMeta.$attrsToReflect$.push([propName, attrName]);
                }
                return attrName;
            });
        }
    }
    return Cstr;
};
const initializeComponent = async (elm, hostRef, cmpMeta, hmrVersionId, Cstr) => {
    // initializeComponent
    if ((_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.style) && (hostRef.$flags$ & 32 /* hasInitializedComponent */) === 0) {
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateClientSide) {
            // we haven't initialized this element yet
            hostRef.$flags$ |= 32 /* hasInitializedComponent */;
            // lazy loaded components
            // request the component's implementation to be
            // wired up with the host element
            Cstr = loadModule(cmpMeta, hostRef, hmrVersionId);
            if (Cstr.then) {
                // Await creates a micro-task avoid if possible
                const endLoad = uniqueTime(`st:load:${cmpMeta.$tagName$}:${hostRef.$modeName$}`, `[Stencil] Load module for <${cmpMeta.$tagName$}>`);
                Cstr = await Cstr;
                endLoad();
            }
            if ((_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDebug) && !Cstr) {
                throw new Error(`Constructor for "${cmpMeta.$tagName$}#${hostRef.$modeName$}" was not found`);
            }
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.member && !Cstr.isProxied) {
                // we'eve never proxied this Constructor before
                // let's add the getters/setters to its prototype before
                // the first time we create an instance of the implementation
                if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.watchCallback) {
                    cmpMeta.$watchers$ = Cstr.watchers;
                }
                proxyComponent(Cstr, cmpMeta, 2 /* proxyState */);
                Cstr.isProxied = true;
            }
            const endNewInstance = createTime('createInstance', cmpMeta.$tagName$);
            // ok, time to construct the instance
            // but let's keep track of when we start and stop
            // so that the getters/setters don't incorrectly step on data
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.member) {
                hostRef.$flags$ |= 8 /* isConstructingInstance */;
            }
            // construct the lazy-loaded component implementation
            // passing the hostRef is very important during
            // construction in order to directly wire together the
            // host element and the lazy-loaded instance
            try {
                new Cstr(hostRef);
            }
            catch (e) {
                consoleError(e);
            }
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.member) {
                hostRef.$flags$ &= ~8 /* isConstructingInstance */;
            }
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.watchCallback) {
                hostRef.$flags$ |= 128 /* isWatchReady */;
            }
            endNewInstance();
            fireConnectedCallback(hostRef.$lazyInstance$);
        }
        else {
            // sync constructor component
            Cstr = elm.constructor;
            hostRef.$flags$ |= 128 /* isWatchReady */ | 32 /* hasInitializedComponent */;
        }
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.style && Cstr.style) {
            // this component has styles but we haven't registered them yet
            let style = Cstr.style;
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.mode && typeof style !== 'string') {
                style = style[(hostRef.$modeName$ = computeMode(elm))];
                if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide && hostRef.$modeName$) {
                    elm.setAttribute('s-mode', hostRef.$modeName$);
                }
            }
            const scopeId = getScopeId(cmpMeta, hostRef.$modeName$);
            if (!styles.has(scopeId)) {
                const endRegisterStyles = createTime('registerStyles', cmpMeta.$tagName$);
                if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDomShim && cmpMeta.$flags$ & 8 /* needsShadowDomShim */) {
                    style = await __webpack_require__.e(/*! import() */ "vendors-node_modules_stencil_core_internal_client_shadow-css_js").then(__webpack_require__.bind(__webpack_require__, /*! ./shadow-css.js */ "./node_modules/@stencil/core/internal/client/shadow-css.js")).then(m => m.scopeCss(style, scopeId, false));
                }
                registerStyle(scopeId, style, !!(cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */));
                endRegisterStyles();
            }
        }
    }
    // we've successfully created a lazy instance
    const ancestorComponent = hostRef.$ancestorComponent$;
    const schedule = () => scheduleUpdate(hostRef, true);
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading && ancestorComponent && ancestorComponent['s-rc']) {
        // this is the intial load and this component it has an ancestor component
        // but the ancestor component has NOT fired its will update lifecycle yet
        // so let's just cool our jets and wait for the ancestor to continue first
        // this will get fired off when the ancestor component
        // finally gets around to rendering its lazy self
        // fire off the initial update
        ancestorComponent['s-rc'].push(schedule);
    }
    else {
        schedule();
    }
};
const fireConnectedCallback = (instance) => {
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.connectedCallback) {
        safeCall(instance, 'connectedCallback');
    }
};
const connectedCallback = (elm) => {
    if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0) {
        const hostRef = getHostRef(elm);
        const cmpMeta = hostRef.$cmpMeta$;
        const endConnected = createTime('connectedCallback', cmpMeta.$tagName$);
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListenerTargetParent) {
            // only run if we have listeners being attached to a parent
            addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, true);
        }
        if (!(hostRef.$flags$ & 1 /* hasConnected */)) {
            // first time this component has connected
            hostRef.$flags$ |= 1 /* hasConnected */;
            let hostId;
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateClientSide) {
                hostId = elm.getAttribute(HYDRATE_ID);
                if (hostId) {
                    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom && supportsShadow && cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {
                        const scopeId = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.mode ? addStyle(elm.shadowRoot, cmpMeta, elm.getAttribute('s-mode')) : addStyle(elm.shadowRoot, cmpMeta);
                        elm.classList.remove(scopeId + '-h', scopeId + '-s');
                    }
                    initializeClientHydrate(elm, cmpMeta.$tagName$, hostId, hostRef);
                }
            }
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotRelocation && !hostId) {
                // initUpdate
                // if the slot polyfill is required we'll need to put some nodes
                // in here to act as original content anchors as we move nodes around
                // host element has been connected to the DOM
                if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide || ((_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slot || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom) && cmpMeta.$flags$ & (4 /* hasSlotRelocation */ | 8 /* needsShadowDomShim */))) {
                    setContentReference(elm);
                }
            }
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading) {
                // find the first ancestor component (if there is one) and register
                // this component as one of the actively loading child components for its ancestor
                let ancestorComponent = elm;
                while ((ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host)) {
                    // climb up the ancestors looking for the first
                    // component that hasn't finished its lifecycle update yet
                    if ((_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateClientSide && ancestorComponent.nodeType === 1 /* ElementNode */ && ancestorComponent.hasAttribute('s-id') && ancestorComponent['s-p']) ||
                        ancestorComponent['s-p']) {
                        // we found this components first ancestor component
                        // keep a reference to this component's ancestor component
                        attachToAncestor(hostRef, (hostRef.$ancestorComponent$ = ancestorComponent));
                        break;
                    }
                }
            }
            // Lazy properties
            // https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.prop && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad && !_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide && cmpMeta.$members$) {
                Object.entries(cmpMeta.$members$).map(([memberName, [memberFlags]]) => {
                    if (memberFlags & 31 /* Prop */ && elm.hasOwnProperty(memberName)) {
                        const value = elm[memberName];
                        delete elm[memberName];
                        elm[memberName] = value;
                    }
                });
            }
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.initializeNextTick) {
                // connectedCallback, taskQueue, initialLoad
                // angular sets attribute AFTER connectCallback
                // https://github.com/angular/angular/issues/18909
                // https://github.com/angular/angular/issues/19940
                nextTick(() => initializeComponent(elm, hostRef, cmpMeta));
            }
            else {
                initializeComponent(elm, hostRef, cmpMeta);
            }
        }
        else {
            // not the first time this has connected
            // reattach any event listeners to the host
            // since they would have been removed when disconnected
            addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, false);
            // fire off connectedCallback() on component instance
            fireConnectedCallback(hostRef.$lazyInstance$);
        }
        endConnected();
    }
};
const setContentReference = (elm) => {
    // only required when we're NOT using native shadow dom (slot)
    // or this browser doesn't support native shadow dom
    // and this host element was NOT created with SSR
    // let's pick out the inner content for slot projection
    // create a node to represent where the original
    // content was first placed, which is useful later on
    const contentRefElm = (elm['s-cr'] = doc.createComment(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDebug ? `content-ref (host=${elm.localName})` : ''));
    contentRefElm['s-cn'] = true;
    elm.insertBefore(contentRefElm, elm.firstChild);
};
const disconnectedCallback = (elm) => {
    if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0) {
        const hostRef = getHostRef(elm);
        const instance = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListener) {
            if (hostRef.$rmListeners$) {
                hostRef.$rmListeners$.map(rmListener => rmListener());
                hostRef.$rmListeners$ = undefined;
            }
        }
        // clear CSS var-shim tracking
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cssVarShim && plt.$cssShim$) {
            plt.$cssShim$.removeHost(elm);
        }
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.disconnectedCallback) {
            safeCall(instance, 'disconnectedCallback');
        }
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cmpDidUnload) {
            safeCall(instance, 'componentDidUnload');
        }
    }
};
const defineCustomElement = (Cstr, compactMeta) => {
    customElements.define(compactMeta[1], proxyCustomElement(Cstr, compactMeta));
};
const proxyCustomElement = (Cstr, compactMeta) => {
    const cmpMeta = {
        $flags$: compactMeta[0],
        $tagName$: compactMeta[1],
    };
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.member) {
        cmpMeta.$members$ = compactMeta[2];
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListener) {
        cmpMeta.$listeners$ = compactMeta[3];
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.watchCallback) {
        cmpMeta.$watchers$ = Cstr.$watchers$;
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.reflect) {
        cmpMeta.$attrsToReflect$ = [];
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom && !supportsShadow && cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {
        cmpMeta.$flags$ |= 8 /* needsShadowDomShim */;
    }
    const originalConnectedCallback = Cstr.prototype.connectedCallback;
    const originalDisconnectedCallback = Cstr.prototype.disconnectedCallback;
    Object.assign(Cstr.prototype, {
        __registerHost() {
            registerHost(this, cmpMeta);
        },
        connectedCallback() {
            connectedCallback(this);
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.connectedCallback && originalConnectedCallback) {
                originalConnectedCallback.call(this);
            }
        },
        disconnectedCallback() {
            disconnectedCallback(this);
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.disconnectedCallback && originalDisconnectedCallback) {
                originalDisconnectedCallback.call(this);
            }
        },
    });
    Cstr.is = cmpMeta.$tagName$;
    return proxyComponent(Cstr, cmpMeta, 1 /* isElementConstructor */ | 2 /* proxyState */);
};
const forceModeUpdate = (elm) => {
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.style && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.mode && !_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad) {
        const mode = computeMode(elm);
        const hostRef = getHostRef(elm);
        if (hostRef.$modeName$ !== mode) {
            const cmpMeta = hostRef.$cmpMeta$;
            const oldScopeId = elm['s-sc'];
            const scopeId = getScopeId(cmpMeta, mode);
            const style = elm.constructor.style[mode];
            const flags = cmpMeta.$flags$;
            if (style) {
                if (!styles.has(scopeId)) {
                    registerStyle(scopeId, style, !!(flags & 1 /* shadowDomEncapsulation */));
                }
                hostRef.$modeName$ = mode;
                elm.classList.remove(oldScopeId + '-h', oldScopeId + '-s');
                attachStyles(hostRef);
                forceUpdate(elm);
            }
        }
    }
};
const attachShadow = (el) => {
    if (supportsShadow) {
        el.attachShadow({ mode: 'open' });
    }
    else {
        el.shadowRoot = el;
    }
};
const hmrStart = (elm, cmpMeta, hmrVersionId) => {
    // \_()_/
    const hostRef = getHostRef(elm);
    // reset state flags to only have been connected
    hostRef.$flags$ = 1 /* hasConnected */;
    // TODO
    // detatch any event listeners that may have been added
    // because we're not passing an exact event name it'll
    // remove all of this element's event, which is good
    // create a callback for when this component finishes hmr
    elm['s-hmr-load'] = () => {
        // finished hmr for this element
        delete elm['s-hmr-load'];
    };
    // re-initialize the component
    initializeComponent(elm, hostRef, cmpMeta, hmrVersionId);
};
const patchCloneNode = (HostElementPrototype) => {
    const orgCloneNode = HostElementPrototype.cloneNode;
    HostElementPrototype.cloneNode = function (deep) {
        const srcNode = this;
        const isShadowDom = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom ? srcNode.shadowRoot && supportsShadow : false;
        const clonedNode = orgCloneNode.call(srcNode, isShadowDom ? deep : false);
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slot && !isShadowDom && deep) {
            let i = 0;
            let slotted, nonStencilNode;
            let stencilPrivates = ['s-id', 's-cr', 's-lr', 's-rc', 's-sc', 's-p', 's-cn', 's-sr', 's-sn', 's-hn', 's-ol', 's-nr', 's-si'];
            for (; i < srcNode.childNodes.length; i++) {
                slotted = srcNode.childNodes[i]['s-nr'];
                nonStencilNode = stencilPrivates.every((privateField) => !srcNode.childNodes[i][privateField]);
                if (slotted) {
                    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.appendChildSlotFix && clonedNode.__appendChild) {
                        clonedNode.__appendChild(slotted.cloneNode(true));
                    }
                    else {
                        clonedNode.appendChild(slotted.cloneNode(true));
                    }
                }
                if (nonStencilNode) {
                    clonedNode.appendChild(srcNode.childNodes[i].cloneNode(true));
                }
            }
        }
        return clonedNode;
    };
};
const patchSlotAppendChild = (HostElementPrototype) => {
    HostElementPrototype.__appendChild = HostElementPrototype.appendChild;
    HostElementPrototype.appendChild = function (newChild) {
        const slotName = (newChild['s-sn'] = getSlotName(newChild));
        const slotNode = getHostSlotNode(this.childNodes, slotName);
        if (slotNode) {
            const slotChildNodes = getHostSlotChildNodes(slotNode, slotName);
            const appendAfter = slotChildNodes[slotChildNodes.length - 1];
            return appendAfter.parentNode.insertBefore(newChild, appendAfter.nextSibling);
        }
        return this.__appendChild(newChild);
    };
};
const patchChildSlotNodes = (elm, cmpMeta) => {
    class FakeNodeList extends Array {
        item(n) {
            return this[n];
        }
    }
    if (cmpMeta.$flags$ & 8 /* needsShadowDomShim */) {
        const childNodesFn = elm.__lookupGetter__('childNodes');
        Object.defineProperty(elm, 'children', {
            get() {
                return this.childNodes.map((n) => n.nodeType === 1);
            },
        });
        Object.defineProperty(elm, 'childElementCount', {
            get() {
                return elm.children.length;
            },
        });
        Object.defineProperty(elm, 'childNodes', {
            get() {
                const childNodes = childNodesFn.call(this);
                if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0 && getHostRef(this).$flags$ & 2 /* hasRendered */) {
                    const result = new FakeNodeList();
                    for (let i = 0; i < childNodes.length; i++) {
                        const slot = childNodes[i]['s-nr'];
                        if (slot) {
                            result.push(slot);
                        }
                    }
                    return result;
                }
                return FakeNodeList.from(childNodes);
            },
        });
    }
};
const getSlotName = (node) => node['s-sn'] || (node.nodeType === 1 && node.getAttribute('slot')) || '';
const getHostSlotNode = (childNodes, slotName) => {
    let i = 0;
    let childNode;
    for (; i < childNodes.length; i++) {
        childNode = childNodes[i];
        if (childNode['s-sr'] && childNode['s-sn'] === slotName) {
            return childNode;
        }
        childNode = getHostSlotNode(childNode.childNodes, slotName);
        if (childNode) {
            return childNode;
        }
    }
    return null;
};
const getHostSlotChildNodes = (n, slotName) => {
    const childNodes = [n];
    while ((n = n.nextSibling) && n['s-sn'] === slotName) {
        childNodes.push(n);
    }
    return childNodes;
};
const bootstrapLazy = (lazyBundles, options = {}) => {
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.profile && performance.mark) {
        performance.mark('st:app:start');
    }
    installDevTools();
    const endBootstrap = createTime('bootstrapLazy');
    const cmpTags = [];
    const exclude = options.exclude || [];
    const customElements = win.customElements;
    const head = doc.head;
    const metaCharset = /*@__PURE__*/ head.querySelector('meta[charset]');
    const visibilityStyle = /*@__PURE__*/ doc.createElement('style');
    const deferredConnectedCallbacks = [];
    const styles = /*@__PURE__*/ doc.querySelectorAll(`[${HYDRATED_STYLE_ID}]`);
    let appLoadFallback;
    let isBootstrapping = true;
    let i = 0;
    Object.assign(plt, options);
    plt.$resourcesUrl$ = new URL(options.resourcesUrl || './', doc.baseURI).href;
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncQueue) {
        if (options.syncQueue) {
            plt.$flags$ |= 4 /* queueSync */;
        }
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateClientSide) {
        // If the app is already hydrated there is not point to disable the
        // async queue. This will improve the first input delay
        plt.$flags$ |= 2 /* appLoaded */;
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateClientSide && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom) {
        for (; i < styles.length; i++) {
            registerStyle(styles[i].getAttribute(HYDRATED_STYLE_ID), convertScopedToShadow(styles[i].innerHTML), true);
        }
    }
    lazyBundles.map(lazyBundle => lazyBundle[1].map(compactMeta => {
        const cmpMeta = {
            $flags$: compactMeta[0],
            $tagName$: compactMeta[1],
            $members$: compactMeta[2],
            $listeners$: compactMeta[3],
        };
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.member) {
            cmpMeta.$members$ = compactMeta[2];
        }
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hostListener) {
            cmpMeta.$listeners$ = compactMeta[3];
        }
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.reflect) {
            cmpMeta.$attrsToReflect$ = [];
        }
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.watchCallback) {
            cmpMeta.$watchers$ = {};
        }
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom && !supportsShadow && cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {
            cmpMeta.$flags$ |= 8 /* needsShadowDomShim */;
        }
        const tagName = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.transformTagName && options.transformTagName ? options.transformTagName(cmpMeta.$tagName$) : cmpMeta.$tagName$;
        const HostElement = class extends HTMLElement {
            // StencilLazyHost
            constructor(self) {
                // @ts-ignore
                super(self);
                self = this;
                registerHost(self, cmpMeta);
                if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDom && cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {
                    // this component is using shadow dom
                    // and this browser supports shadow dom
                    // add the read-only property "shadowRoot" to the host element
                    // adding the shadow root build conditionals to minimize runtime
                    if (supportsShadow) {
                        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.shadowDelegatesFocus) {
                            self.attachShadow({
                                mode: 'open',
                                delegatesFocus: !!(cmpMeta.$flags$ & 16 /* shadowDelegatesFocus */),
                            });
                        }
                        else {
                            self.attachShadow({ mode: 'open' });
                        }
                    }
                    else if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide && !('shadowRoot' in self)) {
                        self.shadowRoot = self;
                    }
                }
                if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.slotChildNodesFix) {
                    patchChildSlotNodes(self, cmpMeta);
                }
            }
            connectedCallback() {
                if (appLoadFallback) {
                    clearTimeout(appLoadFallback);
                    appLoadFallback = null;
                }
                if (isBootstrapping) {
                    // connectedCallback will be processed once all components have been registered
                    deferredConnectedCallbacks.push(this);
                }
                else {
                    plt.jmp(() => connectedCallback(this));
                }
            }
            disconnectedCallback() {
                plt.jmp(() => disconnectedCallback(this));
            }
            componentOnReady() {
                return getHostRef(this).$onReadyPromise$;
            }
        };
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.cloneNodeFix) {
            patchCloneNode(HostElement.prototype);
        }
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.appendChildSlotFix) {
            patchSlotAppendChild(HostElement.prototype);
        }
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hotModuleReplacement) {
            HostElement.prototype['s-hmr'] = function (hmrVersionId) {
                hmrStart(this, cmpMeta, hmrVersionId);
            };
        }
        cmpMeta.$lazyBundleId$ = lazyBundle[0];
        if (!exclude.includes(tagName) && !customElements.get(tagName)) {
            cmpTags.push(tagName);
            customElements.define(tagName, proxyComponent(HostElement, cmpMeta, 1 /* isElementConstructor */));
        }
    }));
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydratedClass || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydratedAttribute) {
        visibilityStyle.innerHTML = cmpTags + HYDRATED_CSS;
        visibilityStyle.setAttribute('data-styles', '');
        head.insertBefore(visibilityStyle, metaCharset ? metaCharset.nextSibling : head.firstChild);
    }
    // Process deferred connectedCallbacks now all components have been registered
    isBootstrapping = false;
    if (deferredConnectedCallbacks.length) {
        deferredConnectedCallbacks.map(host => host.connectedCallback());
    }
    else {
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.profile) {
            plt.jmp(() => (appLoadFallback = setTimeout(appDidLoad, 30, 'timeout')));
        }
        else {
            plt.jmp(() => (appLoadFallback = setTimeout(appDidLoad, 30)));
        }
    }
    // Fallback appLoad event
    endBootstrap();
};
const getAssetPath = (path) => {
    const assetUrl = new URL(path, plt.$resourcesUrl$);
    return assetUrl.origin !== win.location.origin ? assetUrl.href : assetUrl.pathname;
};
const setAssetPath = (path) => (plt.$resourcesUrl$ = path);
const getConnect = (_ref, tagName) => {
    const componentOnReady = () => {
        let elm = doc.querySelector(tagName);
        if (!elm) {
            elm = doc.createElement(tagName);
            doc.body.appendChild(elm);
        }
        return typeof elm.componentOnReady === 'function' ? elm.componentOnReady() : Promise.resolve(elm);
    };
    const create = (...args) => {
        return componentOnReady().then(el => el.create(...args));
    };
    return {
        create,
        componentOnReady,
    };
};
const getContext = (_elm, context) => {
    if (context in Context) {
        return Context[context];
    }
    else if (context === 'window') {
        return win;
    }
    else if (context === 'document') {
        return doc;
    }
    else if (context === 'isServer' || context === 'isPrerender') {
        return _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide ? true : false;
    }
    else if (context === 'isClient') {
        return _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hydrateServerSide ? false : true;
    }
    else if (context === 'resourcesUrl' || context === 'publicPath') {
        return getAssetPath('.');
    }
    else if (context === 'queue') {
        return {
            write: writeTask,
            read: readTask,
            tick: {
                then(cb) {
                    return nextTick(cb);
                },
            },
        };
    }
    return undefined;
};
const insertVdomAnnotations = (doc, staticComponents) => {
    if (doc != null) {
        const docData = {
            hostIds: 0,
            rootLevelIds: 0,
            staticComponents: new Set(staticComponents),
        };
        const orgLocationNodes = [];
        parseVNodeAnnotations(doc, doc.body, docData, orgLocationNodes);
        orgLocationNodes.forEach(orgLocationNode => {
            if (orgLocationNode != null) {
                const nodeRef = orgLocationNode['s-nr'];
                let hostId = nodeRef['s-host-id'];
                let nodeId = nodeRef['s-node-id'];
                let childId = `${hostId}.${nodeId}`;
                if (hostId == null) {
                    hostId = 0;
                    docData.rootLevelIds++;
                    nodeId = docData.rootLevelIds;
                    childId = `${hostId}.${nodeId}`;
                    if (nodeRef.nodeType === 1 /* ElementNode */) {
                        nodeRef.setAttribute(HYDRATE_CHILD_ID, childId);
                    }
                    else if (nodeRef.nodeType === 3 /* TextNode */) {
                        if (hostId === 0) {
                            const textContent = nodeRef.nodeValue.trim();
                            if (textContent === '') {
                                // useless whitespace node at the document root
                                orgLocationNode.remove();
                                return;
                            }
                        }
                        const commentBeforeTextNode = doc.createComment(childId);
                        commentBeforeTextNode.nodeValue = `${TEXT_NODE_ID}.${childId}`;
                        nodeRef.parentNode.insertBefore(commentBeforeTextNode, nodeRef);
                    }
                }
                let orgLocationNodeId = `${ORG_LOCATION_ID}.${childId}`;
                const orgLocationParentNode = orgLocationNode.parentElement;
                if (orgLocationParentNode) {
                    if (orgLocationParentNode['s-en'] === '') {
                        // ending with a "." means that the parent element
                        // of this node's original location is a SHADOW dom element
                        // and this node is apart of the root level light dom
                        orgLocationNodeId += `.`;
                    }
                    else if (orgLocationParentNode['s-en'] === 'c') {
                        // ending with a ".c" means that the parent element
                        // of this node's original location is a SCOPED element
                        // and this node is apart of the root level light dom
                        orgLocationNodeId += `.c`;
                    }
                }
                orgLocationNode.nodeValue = orgLocationNodeId;
            }
        });
    }
};
const parseVNodeAnnotations = (doc, node, docData, orgLocationNodes) => {
    if (node == null) {
        return;
    }
    if (node['s-nr'] != null) {
        orgLocationNodes.push(node);
    }
    if (node.nodeType === 1 /* ElementNode */) {
        node.childNodes.forEach(childNode => {
            const hostRef = getHostRef(childNode);
            if (hostRef != null && !docData.staticComponents.has(childNode.nodeName.toLowerCase())) {
                const cmpData = {
                    nodeIds: 0,
                };
                insertVNodeAnnotations(doc, childNode, hostRef.$vnode$, docData, cmpData);
            }
            parseVNodeAnnotations(doc, childNode, docData, orgLocationNodes);
        });
    }
};
const insertVNodeAnnotations = (doc, hostElm, vnode, docData, cmpData) => {
    if (vnode != null) {
        const hostId = ++docData.hostIds;
        hostElm.setAttribute(HYDRATE_ID, hostId);
        if (hostElm['s-cr'] != null) {
            hostElm['s-cr'].nodeValue = `${CONTENT_REF_ID}.${hostId}`;
        }
        if (vnode.$children$ != null) {
            const depth = 0;
            vnode.$children$.forEach((vnodeChild, index) => {
                insertChildVNodeAnnotations(doc, vnodeChild, cmpData, hostId, depth, index);
            });
        }
        if (hostElm && vnode && vnode.$elm$ && !hostElm.hasAttribute('c-id')) {
            const parent = hostElm.parentElement;
            if (parent && parent.childNodes) {
                const parentChildNodes = Array.from(parent.childNodes);
                const comment = parentChildNodes.find(node => node.nodeType === 8 /* CommentNode */ && node['s-sr']);
                if (comment) {
                    const index = parentChildNodes.indexOf(hostElm) - 1;
                    vnode.$elm$.setAttribute(HYDRATE_CHILD_ID, `${comment['s-host-id']}.${comment['s-node-id']}.0.${index}`);
                }
            }
        }
    }
};
const insertChildVNodeAnnotations = (doc, vnodeChild, cmpData, hostId, depth, index) => {
    const childElm = vnodeChild.$elm$;
    if (childElm == null) {
        return;
    }
    const nodeId = cmpData.nodeIds++;
    const childId = `${hostId}.${nodeId}.${depth}.${index}`;
    childElm['s-host-id'] = hostId;
    childElm['s-node-id'] = nodeId;
    if (childElm.nodeType === 1 /* ElementNode */) {
        childElm.setAttribute(HYDRATE_CHILD_ID, childId);
    }
    else if (childElm.nodeType === 3 /* TextNode */) {
        const parentNode = childElm.parentNode;
        const nodeName = parentNode.nodeName;
        if (nodeName !== 'STYLE' && nodeName !== 'SCRIPT') {
            const textNodeId = `${TEXT_NODE_ID}.${childId}`;
            const commentBeforeTextNode = doc.createComment(textNodeId);
            parentNode.insertBefore(commentBeforeTextNode, childElm);
        }
    }
    else if (childElm.nodeType === 8 /* CommentNode */) {
        if (childElm['s-sr']) {
            const slotName = childElm['s-sn'] || '';
            const slotNodeId = `${SLOT_NODE_ID}.${childId}.${slotName}`;
            childElm.nodeValue = slotNodeId;
        }
    }
    if (vnodeChild.$children$ != null) {
        const childDepth = depth + 1;
        vnodeChild.$children$.forEach((vnode, index) => {
            insertChildVNodeAnnotations(doc, vnode, cmpData, hostId, childDepth, index);
        });
    }
};
const setPlatformOptions = (opts) => Object.assign(plt, opts);
const Fragment = (_, children) => children;
const hostRefs = new WeakMap();
const getHostRef = (ref) => hostRefs.get(ref);
const registerInstance = (lazyInstance, hostRef) => hostRefs.set((hostRef.$lazyInstance$ = lazyInstance), hostRef);
const registerHost = (elm, cmpMeta) => {
    const hostRef = {
        $flags$: 0,
        $hostElement$: elm,
        $cmpMeta$: cmpMeta,
        $instanceValues$: new Map(),
    };
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev) {
        hostRef.$renderCount$ = 0;
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.method && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.lazyLoad) {
        hostRef.$onInstancePromise$ = new Promise(r => (hostRef.$onInstanceResolve$ = r));
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncLoading) {
        hostRef.$onReadyPromise$ = new Promise(r => (hostRef.$onReadyResolve$ = r));
        elm['s-p'] = [];
        elm['s-rc'] = [];
    }
    addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, false);
    return hostRefs.set(elm, hostRef);
};
const isMemberInElement = (elm, memberName) => memberName in elm;
const consoleError = (e, el) => (customError || console.error)(e, el);
const STENCIL_DEV_MODE = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isTesting
    ? ['STENCIL:'] // E2E testing
    : ['%cstencil', 'color: white;background:#4c47ff;font-weight: bold; font-size:10px; padding:2px 6px; border-radius: 5px'];
const consoleDevError = (...m) => console.error(...STENCIL_DEV_MODE, ...m);
const consoleDevWarn = (...m) => console.warn(...STENCIL_DEV_MODE, ...m);
const consoleDevInfo = (...m) => console.info(...STENCIL_DEV_MODE, ...m);
const setErrorHandler = (handler) => customError = handler;
const cmpModules = /*@__PURE__*/ new Map();
const loadModule = (cmpMeta, hostRef, hmrVersionId) => {
    // loadModuleImport
    const exportName = cmpMeta.$tagName$.replace(/-/g, '_');
    const bundleId = cmpMeta.$lazyBundleId$;
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev && typeof bundleId !== 'string') {
        consoleDevError(`Trying to lazily load component <${cmpMeta.$tagName$}> with style mode "${hostRef.$modeName$}", but it does not exist.`);
        return undefined;
    }
    const module = !_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hotModuleReplacement ? cmpModules.get(bundleId) : false;
    if (module) {
        return module[exportName];
    }
    return __webpack_require__("./node_modules/@stencil/core/internal/client lazy recursive ^\\.\\/.*\\.entry\\.js.*$ include: \\.entry\\.js$ exclude: \\.system\\.entry\\.js$")(`./${bundleId}.entry.js${_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hotModuleReplacement && hmrVersionId ? '?s-hmr=' + hmrVersionId : ''}`).then(importedModule => {
        if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.hotModuleReplacement) {
            cmpModules.set(bundleId, importedModule);
        }
        return importedModule[exportName];
    }, consoleError);
};
const styles = new Map();
const modeResolutionChain = [];
const queueDomReads = [];
const queueDomWrites = [];
const queueDomWritesLow = [];
const queueTask = (queue, write) => (cb) => {
    queue.push(cb);
    if (!queuePending) {
        queuePending = true;
        if (write && plt.$flags$ & 4 /* queueSync */) {
            nextTick(flush);
        }
        else {
            plt.raf(flush);
        }
    }
};
const consume = (queue) => {
    for (let i = 0; i < queue.length; i++) {
        try {
            queue[i](performance.now());
        }
        catch (e) {
            consoleError(e);
        }
    }
    queue.length = 0;
};
const consumeTimeout = (queue, timeout) => {
    let i = 0;
    let ts = 0;
    while (i < queue.length && (ts = performance.now()) < timeout) {
        try {
            queue[i++](ts);
        }
        catch (e) {
            consoleError(e);
        }
    }
    if (i === queue.length) {
        queue.length = 0;
    }
    else if (i !== 0) {
        queue.splice(0, i);
    }
};
const flush = () => {
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncQueue) {
        queueCongestion++;
    }
    // always force a bunch of medium callbacks to run, but still have
    // a throttle on how many can run in a certain time
    // DOM READS!!!
    consume(queueDomReads);
    // DOM WRITES!!!
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.asyncQueue) {
        const timeout = (plt.$flags$ & 6 /* queueMask */) === 2 /* appLoaded */ ? performance.now() + 14 * Math.ceil(queueCongestion * (1.0 / 10.0)) : Infinity;
        consumeTimeout(queueDomWrites, timeout);
        consumeTimeout(queueDomWritesLow, timeout);
        if (queueDomWrites.length > 0) {
            queueDomWritesLow.push(...queueDomWrites);
            queueDomWrites.length = 0;
        }
        if ((queuePending = queueDomReads.length + queueDomWrites.length + queueDomWritesLow.length > 0)) {
            // still more to do yet, but we've run out of time
            // let's let this thing cool off and try again in the next tick
            plt.raf(flush);
        }
        else {
            queueCongestion = 0;
        }
    }
    else {
        consume(queueDomWrites);
        if ((queuePending = queueDomReads.length > 0)) {
            // still more to do yet, but we've run out of time
            // let's let this thing cool off and try again in the next tick
            plt.raf(flush);
        }
    }
};
const nextTick = /*@__PURE__*/ (cb) => promiseResolve().then(cb);
const readTask = /*@__PURE__*/ queueTask(queueDomReads, false);
const writeTask = /*@__PURE__*/ queueTask(queueDomWrites, true);
const Build = {
    isDev: _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isDev ? true : false,
    isBrowser: true,
    isServer: false,
    isTesting: _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_0__.BUILD.isTesting ? true : false,
};




/***/ }),

/***/ "./node_modules/core-js/internals/same-value.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/same-value.js ***!
  \******************************************************/
/***/ ((module) => {

// `SameValue` abstract operation
// https://tc39.es/ecma262/#sec-samevalue
// eslint-disable-next-line es/no-object-is -- safe
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare -- NaN check
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.from.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.from.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var from = __webpack_require__(/*! ../internals/array-from */ "./node_modules/core-js/internals/array-from.js");
var checkCorrectnessOfIteration = __webpack_require__(/*! ../internals/check-correctness-of-iteration */ "./node_modules/core-js/internals/check-correctness-of-iteration.js");

var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {
  // eslint-disable-next-line es/no-array-from -- required for testing
  Array.from(iterable);
});

// `Array.from` method
// https://tc39.es/ecma262/#sec-array.from
$({ target: 'Array', stat: true, forced: INCORRECT_ITERATION }, {
  from: from
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.search.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.search.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fixRegExpWellKnownSymbolLogic = __webpack_require__(/*! ../internals/fix-regexp-well-known-symbol-logic */ "./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
var sameValue = __webpack_require__(/*! ../internals/same-value */ "./node_modules/core-js/internals/same-value.js");
var regExpExec = __webpack_require__(/*! ../internals/regexp-exec-abstract */ "./node_modules/core-js/internals/regexp-exec-abstract.js");

// @@search logic
fixRegExpWellKnownSymbolLogic('search', 1, function (SEARCH, nativeSearch, maybeCallNative) {
  return [
    // `String.prototype.search` method
    // https://tc39.es/ecma262/#sec-string.prototype.search
    function search(regexp) {
      var O = requireObjectCoercible(this);
      var searcher = regexp == undefined ? undefined : regexp[SEARCH];
      return searcher !== undefined ? searcher.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
    },
    // `RegExp.prototype[@@search]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@search
    function (regexp) {
      var res = maybeCallNative(nativeSearch, regexp, this);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);

      var previousLastIndex = rx.lastIndex;
      if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
      var result = regExpExec(rx, S);
      if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
      return result === null ? -1 : result.index;
    }
  ];
});


/***/ }),

/***/ "./node_modules/@stencil/core/internal/app-data/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@stencil/core/internal/app-data/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BUILD": () => (/* binding */ BUILD),
/* harmony export */   "Env": () => (/* binding */ Env),
/* harmony export */   "NAMESPACE": () => (/* binding */ NAMESPACE)
/* harmony export */ });
const BUILD = {
    allRenderFn: false,
    cmpDidLoad: true,
    cmpDidUnload: false,
    cmpDidUpdate: true,
    cmpDidRender: true,
    cmpWillLoad: true,
    cmpWillUpdate: true,
    cmpWillRender: true,
    connectedCallback: true,
    disconnectedCallback: true,
    element: true,
    event: true,
    hasRenderFn: true,
    lifecycle: true,
    hostListener: true,
    hostListenerTargetWindow: true,
    hostListenerTargetDocument: true,
    hostListenerTargetBody: true,
    hostListenerTargetParent: false,
    hostListenerTarget: true,
    member: true,
    method: true,
    mode: true,
    observeAttribute: true,
    prop: true,
    propMutable: true,
    reflect: true,
    scoped: true,
    shadowDom: true,
    slot: true,
    cssAnnotations: true,
    state: true,
    style: true,
    svg: true,
    updatable: true,
    vdomAttribute: true,
    vdomXlink: true,
    vdomClass: true,
    vdomFunctional: true,
    vdomKey: true,
    vdomListener: true,
    vdomRef: true,
    vdomPropOrAttr: true,
    vdomRender: true,
    vdomStyle: true,
    vdomText: true,
    watchCallback: true,
    taskQueue: true,
    hotModuleReplacement: false,
    isDebug: false,
    isDev: false,
    isTesting: false,
    hydrateServerSide: false,
    hydrateClientSide: false,
    lifecycleDOMEvents: false,
    lazyLoad: false,
    profile: false,
    slotRelocation: true,
    appendChildSlotFix: false,
    cloneNodeFix: false,
    hydratedAttribute: false,
    hydratedClass: true,
    safari10: false,
    scriptDataOpts: false,
    shadowDomShim: false,
    slotChildNodesFix: false,
    propBoolean: true,
    propNumber: true,
    propString: true,
    cssVarShim: false,
    constructableCSS: true,
    cmpShouldUpdate: true,
    devTools: false,
    dynamicImportShim: false,
    shadowDelegatesFocus: true,
    initializeNextTick: false,
    asyncLoading: false,
    asyncQueue: false,
    transformTagName: false,
    attachStyles: true,
};
const Env = {};
const NAMESPACE = /* default */ 'app';




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfZHVldGRzX2RhdGUtcGlja2VyX2N1c3RvbS1lbGVtZW50X2luZGV4X2pzLW5vZGVfbW9kdWxlc19jb3JlLWpzX21vZHVsZXNfLWZmODdkYS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUF5RjtBQUNSOztBQUVqRiw4QkFBOEIsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0NBQWdDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEVBQUU7QUFDZDtBQUNBO0FBQ0E7QUFDQSxZQUFZLEVBQUU7QUFDZDtBQUNBLFlBQVksRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTyxHQUFHLE9BQU8sRUFBRSxPQUFPLEdBQUcsT0FBTyxHQUFHLE9BQU8sR0FBRyxPQUFPLEdBQUcsT0FBTyxFQUFFLE9BQU8sRUFBRSxPQUFPO0FBQ2hHOztBQUVBLDJCQUEyQixzS0FBc0s7QUFDak0sVUFBVSxnRUFBQyxVQUFVLG1DQUFtQztBQUN4RCxJQUFJLGdFQUFDLFlBQVkscVNBQXFTO0FBQ3RULElBQUksZ0VBQUMsWUFBWSwwQ0FBMEM7QUFDM0QsSUFBSSxnRUFBQyxhQUFhLGtHQUFrRztBQUNwSCxNQUFNLGdFQUFDLFdBQVcsaUNBQWlDO0FBQ25ELFFBQVEsZ0VBQUMsVUFBVSw2R0FBNkc7QUFDaEksVUFBVSxnRUFBQyxRQUFRLG1FQUFtRTtBQUN0RixZQUFZLGdFQUFDLFdBQVcsdU5BQXVOO0FBQy9PLFlBQVksZ0VBQUMsV0FBVyxnR0FBZ0c7QUFDeEgsWUFBWSxnRUFBQyxRQUFRLHNCQUFzQjtBQUMzQyxjQUFjLGdFQUFDLGFBQWEsOEJBQThCO0FBQzFELGNBQWMsZ0VBQUMsYUFBYSw4QkFBOEI7QUFDMUQsY0FBYyxnRUFBQyxhQUFhLCtCQUErQjtBQUMzRCxjQUFjLGdFQUFDLGFBQWEsK0JBQStCO0FBQzNELGNBQWMsZ0VBQUMsYUFBYSwrQkFBK0I7QUFDM0QsY0FBYyxnRUFBQyxhQUFhLGdDQUFnQztBQUM1RCxNQUFNLGdFQUFDLFdBQVcsNkJBQTZCO0FBQy9DO0FBQ0Esd0JBQXdCLGdFQUFDO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLHlIQUF5SDtBQUNsSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0VBQUMsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxJQUFJLGdFQUFDLFdBQVcsdUJBQXVCO0FBQ3ZDLElBQUksZ0VBQUMsV0FBVyw2QkFBNkI7QUFDN0M7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDJCQUEyQixvS0FBb0s7QUFDL0w7QUFDQTtBQUNBLFVBQVUsZ0VBQUMsWUFBWSw0REFBNEQ7QUFDbkYsSUFBSSxnRUFBQztBQUNMLE1BQU0sZ0VBQUMsOEVBQThFLGdFQUFDLFNBQVMsZ0RBQWdEO0FBQy9JLFFBQVEsZ0VBQUMsV0FBVyx1QkFBdUI7QUFDM0MsUUFBUSxnRUFBQyxXQUFXLDZCQUE2QjtBQUNqRCxJQUFJLGdFQUFDLDRDQUE0QyxnRUFBQyxTQUFTLHlCQUF5QixtQkFBbUIsZ0VBQUMsU0FBUywwQkFBMEI7QUFDM0ksTUFBTSxnRUFBQyxrQkFBa0IsNFJBQTRSO0FBQ3JUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjs7QUFFckIsaUZBQWlGLHNCQUFzQixTQUFTLFdBQVcsV0FBVyxzQkFBc0IsNkJBQTZCLGNBQWMsNkJBQTZCLFNBQVMsa0JBQWtCLGdCQUFnQixXQUFXLGtCQUFrQix3QkFBd0IsZ0JBQWdCLHFDQUFxQyxrRUFBa0UsaUNBQWlDLDZCQUE2QixXQUFXLDZCQUE2QixlQUFlLG1CQUFtQiw0QkFBNEIsV0FBVyx3QkFBd0IsdUNBQXVDLCtDQUErQyxVQUFVLDZDQUE2QyxvQ0FBb0MsVUFBVSxtQ0FBbUMsb0NBQW9DLFVBQVUsd0NBQXdDLG9DQUFvQywwQkFBMEIsa0JBQWtCLFdBQVcsbUJBQW1CLHFCQUFxQix3QkFBd0IseUJBQXlCLG1CQUFtQixnQkFBZ0Isb0NBQW9DLFNBQVMsZ0JBQWdCLDhDQUE4QywyQ0FBMkMsNENBQTRDLDZCQUE2QixlQUFlLGFBQWEsd0JBQXdCLHVCQUF1QixVQUFVLGtCQUFrQixVQUFVLFFBQVEsaUJBQWlCLFdBQVcsVUFBVSx5QkFBeUIsK0NBQStDLFVBQVUsd0JBQXdCLGFBQWEsZ0JBQWdCLHVCQUF1QixtQkFBbUIsbUJBQW1CLGFBQWEsT0FBTyxnQkFBZ0IsVUFBVSxrQkFBa0IsU0FBUyxzREFBc0QsMkJBQTJCLDJFQUEyRSxrQkFBa0IsV0FBVywyQ0FBMkMsNEJBQTRCLDhCQUE4QixtQkFBbUIscUNBQXFDLFNBQVMsZUFBZSxRQUFRLE1BQU0sd0JBQXdCLGdDQUFnQywyQkFBMkIsVUFBVSxRQUFRLFdBQVcsNkJBQTZCLFVBQVUsb0RBQW9ELG1CQUFtQiwyQkFBMkIscUNBQXFDLG9DQUFvQyxpQ0FBaUMsMkNBQTJDLGlCQUFpQixlQUFlLGdCQUFnQixnQkFBZ0IsdUJBQXVCLGtCQUFrQixlQUFlLFdBQVcsNEJBQTRCLDhCQUE4QiwyQkFBMkIsU0FBUyxnQkFBZ0IsMENBQTBDLDJDQUEyQyxTQUFTLE9BQU8sU0FBUyxlQUFlLGdCQUFnQixVQUFVLGtCQUFrQixrQkFBa0IseUNBQXlDLDJFQUEyRSxrQkFBa0IsMkNBQTJDLHNDQUFzQyxVQUFVLHNDQUFzQyxvQkFBb0Isa0JBQWtCLHlCQUF5QixpQkFBaUIsNkJBQTZCLGVBQWUsb0NBQW9DLGlCQUFpQixrQkFBa0IsV0FBVyx5QkFBeUIsa0JBQWtCLGtDQUFrQyxtQkFBbUIsaUJBQWlCLG1CQUFtQixxQkFBcUIseUJBQXlCLGlCQUFpQixrQkFBa0IsZ0JBQWdCLHFCQUFxQix3QkFBd0IsZ0JBQWdCLHVCQUF1QixTQUFTLGtCQUFrQiw2QkFBNkIsZUFBZSxxQkFBcUIsNkJBQTZCLG1CQUFtQixrQ0FBa0Msb0NBQW9DLFlBQVksaUJBQWlCLGdCQUFnQixrQkFBa0Isa0JBQWtCLHNCQUFzQixXQUFXLFVBQVUseUJBQXlCLCtDQUErQyxrQkFBa0IsWUFBWSwrREFBK0QscUNBQXFDLGtCQUFrQixTQUFTLGFBQWEsT0FBTyxhQUFhLGtCQUFrQixRQUFRLE1BQU0seURBQXlELHFDQUFxQyxnQkFBZ0Isb0NBQW9DLFVBQVUsdUJBQXVCLHFDQUFxQyw2Q0FBNkMsb0NBQW9DLFlBQVksc0JBQXNCLDZDQUE2QyxZQUFZLCtCQUErQixnQkFBZ0IsbUVBQW1FLHVCQUF1Qiw2QkFBNkIsZUFBZSxZQUFZLDZDQUE2QywrQ0FBK0MsbURBQW1ELDZDQUE2QyxxQ0FBcUMsb0NBQW9DLDJEQUEyRCxhQUFhLDJCQUEyQixvQ0FBb0MsZ0JBQWdCLDZCQUE2QixlQUFlLFlBQVksb0JBQW9CLG1DQUFtQyxhQUFhLG1CQUFtQixtQkFBbUIsYUFBYSw4QkFBOEIsbUJBQW1CLFdBQVcsZ0JBQWdCLG1CQUFtQixrQ0FBa0MscUJBQXFCLHdCQUF3QixtQkFBbUIsZ0JBQWdCLG9DQUFvQyxTQUFTLGtCQUFrQiw2QkFBNkIsZUFBZSxvQkFBb0IsWUFBWSx1QkFBdUIsZ0JBQWdCLFVBQVUsdUNBQXVDLFdBQVcsOEJBQThCLGtDQUFrQyxZQUFZLFlBQVksOENBQThDLCtDQUErQyxVQUFVLDREQUE0RCxnQkFBZ0Isb0RBQW9ELGVBQWUsWUFBWSwwQ0FBMEMsY0FBYyxtQkFBbUIsb0JBQW9CLGVBQWUsa0JBQWtCLHdCQUF3QixpQkFBaUIsMEJBQTBCLGVBQWUsZUFBZSxZQUFZLE9BQU8sVUFBVSxrQkFBa0IsTUFBTSxXQUFXLFVBQVUseURBQXlELCtDQUErQyx5QkFBeUIsbUJBQW1CLGlDQUFpQyw2QkFBNkIsYUFBYSxrQkFBa0Isa0NBQWtDLGlCQUFpQixvQkFBb0Isb0JBQW9CLGtCQUFrQixXQUFXLFVBQVUsNkJBQTZCLFdBQVcsWUFBWSxtQkFBbUIsbUJBQW1CLDRDQUE0QyxhQUFhLDhCQUE4QixtQkFBbUIsaUJBQWlCLGdCQUFnQixrQkFBa0Isa0JBQWtCLHVCQUF1QixtQkFBbUIsV0FBVyx5QkFBeUIsbUJBQW1CLFNBQVMsU0FBUyxpQkFBaUIsVUFBVSxrQkFBa0IsV0FBVyxTQUFTLFlBQVksMkJBQTJCLHFCQUFxQixrQ0FBa0MsY0FBYyxnQkFBZ0IsdUJBQXVCLG1CQUFtQix5QkFBeUIsMkJBQTJCLGNBQWMsa0JBQWtCLHdCQUF3QixtQkFBbUIsZ0JBQWdCLG9DQUFvQyxTQUFTLGtCQUFrQiw2QkFBNkIsZUFBZSxhQUFhLFlBQVksdUJBQXVCLFVBQVUsV0FBVyx5QkFBeUIsa0JBQWtCLFdBQVcsd0JBQXdCLCtDQUErQyxhQUFhLHlCQUF5Qix3QkFBd0IsV0FBVyxzQkFBc0IsY0FBYyxvQkFBb0IsU0FBUyw4QkFBOEIsV0FBVyxnQkFBZ0IsVUFBVSxrQkFBa0IsTUFBTSxVQUFVOztBQUVycVE7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwRUFBVztBQUNqQyxvQkFBb0IsMEVBQVc7QUFDL0IscUJBQXFCLDBFQUFXO0FBQ2hDLG9CQUFvQiwwRUFBVztBQUMvQixxQkFBcUIsMEVBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Ozs7Ozs7Ozs7Ozs7QUNiWTtBQUNiLG9DQUFvQyxtQkFBTyxDQUFDLCtIQUFpRDtBQUM3RixlQUFlLG1CQUFPLENBQUMsNkVBQXdCO0FBQy9DLDZCQUE2QixtQkFBTyxDQUFDLDJHQUF1QztBQUM1RSxnQkFBZ0IsbUJBQU8sQ0FBQywrRUFBeUI7QUFDakQsaUJBQWlCLG1CQUFPLENBQUMsbUdBQW1DOztBQUU1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGR1ZXRkcy9kYXRlLXBpY2tlci9jdXN0b20tZWxlbWVudC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9jbGllbnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NhbWUtdmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mcm9tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNlYXJjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9hcHAtZGF0YS9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBoLCBjcmVhdGVFdmVudCwgSG9zdCwgcHJveHlDdXN0b21FbGVtZW50IH0gZnJvbSAnQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9jbGllbnQnO1xuZXhwb3J0IHsgc2V0QXNzZXRQYXRoLCBzZXRQbGF0Zm9ybU9wdGlvbnMgfSBmcm9tICdAc3RlbmNpbC9jb3JlL2ludGVybmFsL2NsaWVudCc7XG5cbmNvbnN0IElTT19EQVRFX0ZPUk1BVCA9IC9eKFxcZHs0fSktKFxcZHsyfSktKFxcZHsyfSkkLztcbnZhciBEYXlzT2ZXZWVrO1xuKGZ1bmN0aW9uIChEYXlzT2ZXZWVrKSB7XG4gIERheXNPZldlZWtbRGF5c09mV2Vla1tcIlN1bmRheVwiXSA9IDBdID0gXCJTdW5kYXlcIjtcbiAgRGF5c09mV2Vla1tEYXlzT2ZXZWVrW1wiTW9uZGF5XCJdID0gMV0gPSBcIk1vbmRheVwiO1xuICBEYXlzT2ZXZWVrW0RheXNPZldlZWtbXCJUdWVzZGF5XCJdID0gMl0gPSBcIlR1ZXNkYXlcIjtcbiAgRGF5c09mV2Vla1tEYXlzT2ZXZWVrW1wiV2VkbmVzZGF5XCJdID0gM10gPSBcIldlZG5lc2RheVwiO1xuICBEYXlzT2ZXZWVrW0RheXNPZldlZWtbXCJUaHVyc2RheVwiXSA9IDRdID0gXCJUaHVyc2RheVwiO1xuICBEYXlzT2ZXZWVrW0RheXNPZldlZWtbXCJGcmlkYXlcIl0gPSA1XSA9IFwiRnJpZGF5XCI7XG4gIERheXNPZldlZWtbRGF5c09mV2Vla1tcIlNhdHVyZGF5XCJdID0gNl0gPSBcIlNhdHVyZGF5XCI7XG59KShEYXlzT2ZXZWVrIHx8IChEYXlzT2ZXZWVrID0ge30pKTtcbmZ1bmN0aW9uIGNyZWF0ZURhdGUoeWVhciwgbW9udGgsIGRheSkge1xuICB2YXIgZGF5SW50ID0gcGFyc2VJbnQoZGF5LCAxMCk7XG4gIHZhciBtb250aEludCA9IHBhcnNlSW50KG1vbnRoLCAxMCk7XG4gIHZhciB5ZWFySW50ID0gcGFyc2VJbnQoeWVhciwgMTApO1xuICBjb25zdCBpc1ZhbGlkID0gTnVtYmVyLmlzSW50ZWdlcih5ZWFySW50KSAmJiAvLyBhbGwgcGFydHMgc2hvdWxkIGJlIGludGVnZXJzXG4gICAgTnVtYmVyLmlzSW50ZWdlcihtb250aEludCkgJiZcbiAgICBOdW1iZXIuaXNJbnRlZ2VyKGRheUludCkgJiZcbiAgICBtb250aEludCA+IDAgJiYgLy8gbW9udGggbXVzdCBiZSAxLTEyXG4gICAgbW9udGhJbnQgPD0gMTIgJiZcbiAgICBkYXlJbnQgPiAwICYmIC8vIGRheSBtdXN0IGJlIDEtMzFcbiAgICBkYXlJbnQgPD0gMzEgJiZcbiAgICB5ZWFySW50ID4gMDtcbiAgaWYgKGlzVmFsaWQpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoeWVhckludCwgbW9udGhJbnQgLSAxLCBkYXlJbnQpO1xuICB9XG59XG4vKipcbiAqIEBwYXJhbSB2YWx1ZSBkYXRlIHN0cmluZyBpbiBJU08gZm9ybWF0IFlZWVktTU0tRERcbiAqL1xuZnVuY3Rpb24gcGFyc2VJU09EYXRlKHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgbWF0Y2hlcyA9IHZhbHVlLm1hdGNoKElTT19EQVRFX0ZPUk1BVCk7XG4gIGlmIChtYXRjaGVzKSB7XG4gICAgcmV0dXJuIGNyZWF0ZURhdGUobWF0Y2hlc1sxXSwgbWF0Y2hlc1syXSwgbWF0Y2hlc1szXSk7XG4gIH1cbn1cbi8qKlxuICogcHJpbnQgZGF0ZSBpbiBmb3JtYXQgWVlZWS1NTS1ERFxuICogQHBhcmFtIGRhdGVcbiAqL1xuZnVuY3Rpb24gcHJpbnRJU09EYXRlKGRhdGUpIHtcbiAgaWYgKCFkYXRlKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgdmFyIGQgPSBkYXRlLmdldERhdGUoKS50b1N0cmluZygxMCk7XG4gIHZhciBtID0gKGRhdGUuZ2V0TW9udGgoKSArIDEpLnRvU3RyaW5nKDEwKTtcbiAgdmFyIHkgPSBkYXRlLmdldEZ1bGxZZWFyKCkudG9TdHJpbmcoMTApO1xuICAvLyBkYXlzIGFyZSBub3QgemVyby1pbmRleGVkLCBzbyBwYWQgaWYgbGVzcyB0aGFuIDEwXG4gIGlmIChkYXRlLmdldERhdGUoKSA8IDEwKSB7XG4gICAgZCA9IGAwJHtkfWA7XG4gIH1cbiAgLy8gbW9udGhzICphcmUqIHplcm8taW5kZXhlZCwgcGFkIGlmIGxlc3MgdGhhbiA5IVxuICBpZiAoZGF0ZS5nZXRNb250aCgpIDwgOSkge1xuICAgIG0gPSBgMCR7bX1gO1xuICB9XG4gIHJldHVybiBgJHt5fS0ke219LSR7ZH1gO1xufVxuLyoqXG4gKiBDb21wYXJlIGlmIHR3byBkYXRlcyBhcmUgZXF1YWwgaW4gdGVybXMgb2YgZGF5LCBtb250aCwgYW5kIHllYXJcbiAqL1xuZnVuY3Rpb24gaXNFcXVhbChhLCBiKSB7XG4gIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc0VxdWFsTW9udGgoYSwgYikgJiYgYS5nZXREYXRlKCkgPT09IGIuZ2V0RGF0ZSgpO1xufVxuLyoqXG4gKiBDb21wYXJlIGlmIHR3byBkYXRlcyBhcmUgaW4gdGhlIHNhbWUgbW9udGggb2YgdGhlIHNhbWUgeWVhci5cbiAqL1xuZnVuY3Rpb24gaXNFcXVhbE1vbnRoKGEsIGIpIHtcbiAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGEuZ2V0RnVsbFllYXIoKSA9PT0gYi5nZXRGdWxsWWVhcigpICYmIGEuZ2V0TW9udGgoKSA9PT0gYi5nZXRNb250aCgpO1xufVxuZnVuY3Rpb24gYWRkRGF5cyhkYXRlLCBkYXlzKSB7XG4gIHZhciBkID0gbmV3IERhdGUoZGF0ZSk7XG4gIGQuc2V0RGF0ZShkLmdldERhdGUoKSArIGRheXMpO1xuICByZXR1cm4gZDtcbn1cbmZ1bmN0aW9uIHN0YXJ0T2ZXZWVrKGRhdGUsIGZpcnN0RGF5T2ZXZWVrID0gRGF5c09mV2Vlay5Nb25kYXkpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZShkYXRlKTtcbiAgdmFyIGRheSA9IGQuZ2V0RGF5KCk7XG4gIHZhciBkaWZmID0gKGRheSA8IGZpcnN0RGF5T2ZXZWVrID8gNyA6IDApICsgZGF5IC0gZmlyc3REYXlPZldlZWs7XG4gIGQuc2V0RGF0ZShkLmdldERhdGUoKSAtIGRpZmYpO1xuICByZXR1cm4gZDtcbn1cbmZ1bmN0aW9uIGVuZE9mV2VlayhkYXRlLCBmaXJzdERheU9mV2VlayA9IERheXNPZldlZWsuTW9uZGF5KSB7XG4gIHZhciBkID0gbmV3IERhdGUoZGF0ZSk7XG4gIHZhciBkYXkgPSBkLmdldERheSgpO1xuICB2YXIgZGlmZiA9IChkYXkgPCBmaXJzdERheU9mV2VlayA/IC03IDogMCkgKyA2IC0gKGRheSAtIGZpcnN0RGF5T2ZXZWVrKTtcbiAgZC5zZXREYXRlKGQuZ2V0RGF0ZSgpICsgZGlmZik7XG4gIHJldHVybiBkO1xufVxuZnVuY3Rpb24gc3RhcnRPZk1vbnRoKGRhdGUpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCAxKTtcbn1cbmZ1bmN0aW9uIGVuZE9mTW9udGgoZGF0ZSkge1xuICByZXR1cm4gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCkgKyAxLCAwKTtcbn1cbmZ1bmN0aW9uIHNldE1vbnRoKGRhdGUsIG1vbnRoKSB7XG4gIGNvbnN0IGQgPSBuZXcgRGF0ZShkYXRlKTtcbiAgZC5zZXRNb250aChtb250aCk7XG4gIHJldHVybiBkO1xufVxuZnVuY3Rpb24gc2V0WWVhcihkYXRlLCB5ZWFyKSB7XG4gIGNvbnN0IGQgPSBuZXcgRGF0ZShkYXRlKTtcbiAgZC5zZXRGdWxsWWVhcih5ZWFyKTtcbiAgcmV0dXJuIGQ7XG59XG4vKipcbiAqIENoZWNrIGlmIGRhdGUgaXMgd2l0aGluIGEgbWluIGFuZCBtYXhcbiAqL1xuZnVuY3Rpb24gaW5SYW5nZShkYXRlLCBtaW4sIG1heCkge1xuICByZXR1cm4gY2xhbXAoZGF0ZSwgbWluLCBtYXgpID09PSBkYXRlO1xufVxuLyoqXG4gKiBFbnN1cmVzIGRhdGUgaXMgd2l0aGluIHJhbmdlLCByZXR1cm5zIG1pbiBvciBtYXggaWYgb3V0IG9mIGJvdW5kc1xuICovXG5mdW5jdGlvbiBjbGFtcChkYXRlLCBtaW4sIG1heCkge1xuICBjb25zdCB0aW1lID0gZGF0ZS5nZXRUaW1lKCk7XG4gIGlmIChtaW4gJiYgbWluIGluc3RhbmNlb2YgRGF0ZSAmJiB0aW1lIDwgbWluLmdldFRpbWUoKSkge1xuICAgIHJldHVybiBtaW47XG4gIH1cbiAgaWYgKG1heCAmJiBtYXggaW5zdGFuY2VvZiBEYXRlICYmIHRpbWUgPiBtYXguZ2V0VGltZSgpKSB7XG4gICAgcmV0dXJuIG1heDtcbiAgfVxuICByZXR1cm4gZGF0ZTtcbn1cbi8qKlxuICogZ2l2ZW4gc3RhcnQgYW5kIGVuZCBkYXRlLCByZXR1cm4gYW4gKGluY2x1c2l2ZSkgYXJyYXkgb2YgYWxsIGRhdGVzIGluIGJldHdlZW5cbiAqIEBwYXJhbSBzdGFydFxuICogQHBhcmFtIGVuZFxuICovXG5mdW5jdGlvbiBnZXREYXlzSW5SYW5nZShzdGFydCwgZW5kKSB7XG4gIGNvbnN0IGRheXMgPSBbXTtcbiAgbGV0IGN1cnJlbnQgPSBzdGFydDtcbiAgd2hpbGUgKCFpc0VxdWFsKGN1cnJlbnQsIGVuZCkpIHtcbiAgICBkYXlzLnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGFkZERheXMoY3VycmVudCwgMSk7XG4gIH1cbiAgZGF5cy5wdXNoKGN1cnJlbnQpO1xuICByZXR1cm4gZGF5cztcbn1cbi8qKlxuICogZ2l2ZW4gYSBkYXRlLCByZXR1cm4gYW4gYXJyYXkgb2YgZGF0ZXMgZnJvbSBhIGNhbGVuZGFyIHBlcnNwZWN0aXZlXG4gKiBAcGFyYW0gZGF0ZVxuICogQHBhcmFtIGZpcnN0RGF5T2ZXZWVrXG4gKi9cbmZ1bmN0aW9uIGdldFZpZXdPZk1vbnRoKGRhdGUsIGZpcnN0RGF5T2ZXZWVrID0gRGF5c09mV2Vlay5Nb25kYXkpIHtcbiAgY29uc3Qgc3RhcnQgPSBzdGFydE9mV2VlayhzdGFydE9mTW9udGgoZGF0ZSksIGZpcnN0RGF5T2ZXZWVrKTtcbiAgY29uc3QgZW5kID0gZW5kT2ZXZWVrKGVuZE9mTW9udGgoZGF0ZSksIGZpcnN0RGF5T2ZXZWVrKTtcbiAgcmV0dXJuIGdldERheXNJblJhbmdlKHN0YXJ0LCBlbmQpO1xufVxuLyoqXG4gKiBGb3JtIHJhbmRvbSBoYXNoXG4gKi9cbmZ1bmN0aW9uIGNocjQoKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpXG4gICAgLnRvU3RyaW5nKDE2KVxuICAgIC5zbGljZSgtNCk7XG59XG4vKipcbiAqIENyZWF0ZSByYW5kb20gaWRlbnRpZmllciB3aXRoIGEgcHJlZml4XG4gKiBAcGFyYW0gcHJlZml4XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlkZW50aWZpZXIocHJlZml4KSB7XG4gIHJldHVybiBgJHtwcmVmaXh9LSR7Y2hyNCgpfSR7Y2hyNCgpfS0ke2NocjQoKX0tJHtjaHI0KCl9LSR7Y2hyNCgpfS0ke2NocjQoKX0ke2NocjQoKX0ke2NocjQoKX1gO1xufVxuXG5jb25zdCBEYXRlUGlja2VySW5wdXQgPSAoeyBvbkNsaWNrLCBkYXRlRm9ybWF0dGVyLCBsb2NhbGl6YXRpb24sIG5hbWUsIGZvcm1hdHRlZFZhbHVlLCB2YWx1ZUFzRGF0ZSwgdmFsdWUsIGlkZW50aWZpZXIsIGRpc2FibGVkLCByZXF1aXJlZCwgcm9sZSwgYnV0dG9uUmVmLCBpbnB1dFJlZiwgb25JbnB1dCwgb25CbHVyLCBvbkZvY3VzLCB9KSA9PiB7XG4gIHJldHVybiAoaChcImRpdlwiLCB7IGNsYXNzOiBcImR1ZXQtZGF0ZV9faW5wdXQtd3JhcHBlclwiIH0sXG4gICAgaChcImlucHV0XCIsIHsgY2xhc3M6IFwiZHVldC1kYXRlX19pbnB1dFwiLCB2YWx1ZTogZm9ybWF0dGVkVmFsdWUsIHBsYWNlaG9sZGVyOiBsb2NhbGl6YXRpb24ucGxhY2Vob2xkZXIsIGlkOiBpZGVudGlmaWVyLCBkaXNhYmxlZDogZGlzYWJsZWQsIHJvbGU6IHJvbGUsIHJlcXVpcmVkOiByZXF1aXJlZCA/IHRydWUgOiB1bmRlZmluZWQsIFwiYXJpYS1hdXRvY29tcGxldGVcIjogXCJub25lXCIsIG9uSW5wdXQ6IG9uSW5wdXQsIG9uRm9jdXM6IG9uRm9jdXMsIG9uQmx1cjogb25CbHVyLCBhdXRvQ29tcGxldGU6IFwib2ZmXCIsIHJlZjogaW5wdXRSZWYgfSksXG4gICAgaChcImlucHV0XCIsIHsgdHlwZTogXCJoaWRkZW5cIiwgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH0pLFxuICAgIGgoXCJidXR0b25cIiwgeyBjbGFzczogXCJkdWV0LWRhdGVfX3RvZ2dsZVwiLCBvbkNsaWNrOiBvbkNsaWNrLCBkaXNhYmxlZDogZGlzYWJsZWQsIHJlZjogYnV0dG9uUmVmLCB0eXBlOiBcImJ1dHRvblwiIH0sXG4gICAgICBoKFwic3BhblwiLCB7IGNsYXNzOiBcImR1ZXQtZGF0ZV9fdG9nZ2xlLWljb25cIiB9LFxuICAgICAgICBoKFwic3ZnXCIsIHsgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIiwgaGVpZ2h0OiBcIjI0XCIsIHZpZXdCb3g6IFwiMCAwIDIxIDIxXCIsIHdpZHRoOiBcIjI0XCIsIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgfSxcbiAgICAgICAgICBoKFwiZ1wiLCB7IGZpbGw6IFwibm9uZVwiLCBcImZpbGwtcnVsZVwiOiBcImV2ZW5vZGRcIiwgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZSgyIDIpXCIgfSxcbiAgICAgICAgICAgIGgoXCJwYXRoXCIsIHsgZDogXCJtMi41LjVoMTJjMS4xMDQ1Njk1IDAgMiAuODk1NDMwNSAyIDJ2MTJjMCAxLjEwNDU2OTUtLjg5NTQzMDUgMi0yIDJoLTEyYy0xLjEwNDU2OTUgMC0yLS44OTU0MzA1LTItMnYtMTJjMC0xLjEwNDU2OTUuODk1NDMwNS0yIDItMnpcIiwgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLCBcInN0cm9rZS1saW5lY2FwXCI6IFwicm91bmRcIiwgXCJzdHJva2UtbGluZWpvaW5cIjogXCJyb3VuZFwiIH0pLFxuICAgICAgICAgICAgaChcInBhdGhcIiwgeyBkOiBcIm0uNSA0LjVoMTZcIiwgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLCBcInN0cm9rZS1saW5lY2FwXCI6IFwicm91bmRcIiwgXCJzdHJva2UtbGluZWpvaW5cIjogXCJyb3VuZFwiIH0pLFxuICAgICAgICAgICAgaChcImdcIiwgeyBmaWxsOiBcImN1cnJlbnRDb2xvclwiIH0sXG4gICAgICAgICAgICAgIGgoXCJjaXJjbGVcIiwgeyBjeDogXCI4LjVcIiwgY3k6IFwiOC41XCIsIHI6IFwiMVwiIH0pLFxuICAgICAgICAgICAgICBoKFwiY2lyY2xlXCIsIHsgY3g6IFwiNC41XCIsIGN5OiBcIjguNVwiLCByOiBcIjFcIiB9KSxcbiAgICAgICAgICAgICAgaChcImNpcmNsZVwiLCB7IGN4OiBcIjEyLjVcIiwgY3k6IFwiOC41XCIsIHI6IFwiMVwiIH0pLFxuICAgICAgICAgICAgICBoKFwiY2lyY2xlXCIsIHsgY3g6IFwiOC41XCIsIGN5OiBcIjEyLjVcIiwgcjogXCIxXCIgfSksXG4gICAgICAgICAgICAgIGgoXCJjaXJjbGVcIiwgeyBjeDogXCI0LjVcIiwgY3k6IFwiMTIuNVwiLCByOiBcIjFcIiB9KSxcbiAgICAgICAgICAgICAgaChcImNpcmNsZVwiLCB7IGN4OiBcIjEyLjVcIiwgY3k6IFwiMTIuNVwiLCByOiBcIjFcIiB9KSkpKSksXG4gICAgICBoKFwic3BhblwiLCB7IGNsYXNzOiBcImR1ZXQtZGF0ZV9fdmhpZGRlblwiIH0sXG4gICAgICAgIGxvY2FsaXphdGlvbi5idXR0b25MYWJlbCxcbiAgICAgICAgdmFsdWVBc0RhdGUgJiYgKGgoXCJzcGFuXCIsIG51bGwsXG4gICAgICAgICAgXCIsIFwiLFxuICAgICAgICAgIGxvY2FsaXphdGlvbi5zZWxlY3RlZERhdGVNZXNzYWdlLFxuICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgIGRhdGVGb3JtYXR0ZXIuZm9ybWF0KHZhbHVlQXNEYXRlKSkpKSkpKTtcbn07XG5cbmNvbnN0IERhdGVQaWNrZXJEYXkgPSAoeyBmb2N1c2VkRGF5LCB0b2RheSwgZGF5LCBvbkRheVNlbGVjdCwgb25LZXlib2FyZE5hdmlnYXRpb24sIGZvY3VzZWREYXlSZWYsIGRpc2FibGVkLCBpblJhbmdlLCBpc1NlbGVjdGVkLCBkYXRlRm9ybWF0dGVyLCB9KSA9PiB7XG4gIGNvbnN0IGlzVG9kYXkgPSBpc0VxdWFsKGRheSwgdG9kYXkpO1xuICBjb25zdCBpc01vbnRoID0gaXNFcXVhbE1vbnRoKGRheSwgZm9jdXNlZERheSk7XG4gIGNvbnN0IGlzRm9jdXNlZCA9IGlzRXF1YWwoZGF5LCBmb2N1c2VkRGF5KTtcbiAgY29uc3QgaXNPdXRzaWRlUmFuZ2UgPSAhaW5SYW5nZTtcbiAgZnVuY3Rpb24gaGFuZGxlQ2xpY2soZSkge1xuICAgIG9uRGF5U2VsZWN0KGUsIGRheSk7XG4gIH1cbiAgcmV0dXJuIChoKFwiYnV0dG9uXCIsIHsgY2xhc3M6IHtcbiAgICAgIFwiZHVldC1kYXRlX19kYXlcIjogdHJ1ZSxcbiAgICAgIFwiaXMtb3V0c2lkZVwiOiBpc091dHNpZGVSYW5nZSxcbiAgICAgIFwiaXMtdG9kYXlcIjogaXNUb2RheSxcbiAgICAgIFwiaXMtbW9udGhcIjogaXNNb250aCxcbiAgICAgIFwiaXMtZGlzYWJsZWRcIjogZGlzYWJsZWQsXG4gICAgfSwgdGFiSW5kZXg6IGlzRm9jdXNlZCA/IDAgOiAtMSwgb25DbGljazogaGFuZGxlQ2xpY2ssIG9uS2V5RG93bjogb25LZXlib2FyZE5hdmlnYXRpb24sIFwiYXJpYS1kaXNhYmxlZFwiOiBkaXNhYmxlZCA/IFwidHJ1ZVwiIDogdW5kZWZpbmVkLCBkaXNhYmxlZDogaXNPdXRzaWRlUmFuZ2UsIHR5cGU6IFwiYnV0dG9uXCIsIFwiYXJpYS1wcmVzc2VkXCI6IGlzU2VsZWN0ZWQgPyBcInRydWVcIiA6IFwiZmFsc2VcIiwgcmVmOiBlbCA9PiB7XG4gICAgICBpZiAoaXNGb2N1c2VkICYmIGVsICYmIGZvY3VzZWREYXlSZWYpIHtcbiAgICAgICAgZm9jdXNlZERheVJlZihlbCk7XG4gICAgICB9XG4gICAgfSB9LFxuICAgIGgoXCJzcGFuXCIsIHsgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIiB9LCBkYXkuZ2V0RGF0ZSgpKSxcbiAgICBoKFwic3BhblwiLCB7IGNsYXNzOiBcImR1ZXQtZGF0ZV9fdmhpZGRlblwiIH0sIGRhdGVGb3JtYXR0ZXIuZm9ybWF0KGRheSkpKSk7XG59O1xuXG5mdW5jdGlvbiBjaHVuayhhcnJheSwgY2h1bmtTaXplKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSBjaHVua1NpemUpIHtcbiAgICByZXN1bHQucHVzaChhcnJheS5zbGljZShpLCBpICsgY2h1bmtTaXplKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1hcFdpdGhPZmZzZXQoYXJyYXksIHN0YXJ0aW5nT2Zmc2V0LCBtYXBGbikge1xuICByZXR1cm4gYXJyYXkubWFwKChfLCBpKSA9PiB7XG4gICAgY29uc3QgYWRqdXN0ZWRJbmRleCA9IChpICsgc3RhcnRpbmdPZmZzZXQpICUgYXJyYXkubGVuZ3RoO1xuICAgIHJldHVybiBtYXBGbihhcnJheVthZGp1c3RlZEluZGV4XSk7XG4gIH0pO1xufVxuY29uc3QgRGF0ZVBpY2tlck1vbnRoID0gKHsgc2VsZWN0ZWREYXRlLCBmb2N1c2VkRGF0ZSwgbGFiZWxsZWRCeUlkLCBsb2NhbGl6YXRpb24sIGZpcnN0RGF5T2ZXZWVrLCBtaW4sIG1heCwgZGF0ZUZvcm1hdHRlciwgaXNEYXRlRGlzYWJsZWQsIG9uRGF0ZVNlbGVjdCwgb25LZXlib2FyZE5hdmlnYXRpb24sIGZvY3VzZWREYXlSZWYsIH0pID0+IHtcbiAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuICBjb25zdCBkYXlzID0gZ2V0Vmlld09mTW9udGgoZm9jdXNlZERhdGUsIGZpcnN0RGF5T2ZXZWVrKTtcbiAgcmV0dXJuIChoKFwidGFibGVcIiwgeyBjbGFzczogXCJkdWV0LWRhdGVfX3RhYmxlXCIsIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IGxhYmVsbGVkQnlJZCB9LFxuICAgIGgoXCJ0aGVhZFwiLCBudWxsLFxuICAgICAgaChcInRyXCIsIG51bGwsIG1hcFdpdGhPZmZzZXQobG9jYWxpemF0aW9uLmRheU5hbWVzLCBmaXJzdERheU9mV2VlaywgZGF5TmFtZSA9PiAoaChcInRoXCIsIHsgY2xhc3M6IFwiZHVldC1kYXRlX190YWJsZS1oZWFkZXJcIiwgc2NvcGU6IFwiY29sXCIgfSxcbiAgICAgICAgaChcInNwYW5cIiwgeyBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiIH0sIGRheU5hbWUuc3Vic3RyKDAsIDIpKSxcbiAgICAgICAgaChcInNwYW5cIiwgeyBjbGFzczogXCJkdWV0LWRhdGVfX3ZoaWRkZW5cIiB9LCBkYXlOYW1lKSkpKSkpLFxuICAgIGgoXCJ0Ym9keVwiLCBudWxsLCBjaHVuayhkYXlzLCA3KS5tYXAod2VlayA9PiAoaChcInRyXCIsIHsgY2xhc3M6IFwiZHVldC1kYXRlX19yb3dcIiB9LCB3ZWVrLm1hcChkYXkgPT4gKGgoXCJ0ZFwiLCB7IGNsYXNzOiBcImR1ZXQtZGF0ZV9fY2VsbFwiIH0sXG4gICAgICBoKERhdGVQaWNrZXJEYXksIHsgZGF5OiBkYXksIHRvZGF5OiB0b2RheSwgZm9jdXNlZERheTogZm9jdXNlZERhdGUsIGlzU2VsZWN0ZWQ6IGlzRXF1YWwoZGF5LCBzZWxlY3RlZERhdGUpLCBkaXNhYmxlZDogaXNEYXRlRGlzYWJsZWQoZGF5KSwgaW5SYW5nZTogaW5SYW5nZShkYXksIG1pbiwgbWF4KSwgb25EYXlTZWxlY3Q6IG9uRGF0ZVNlbGVjdCwgZGF0ZUZvcm1hdHRlcjogZGF0ZUZvcm1hdHRlciwgb25LZXlib2FyZE5hdmlnYXRpb246IG9uS2V5Ym9hcmROYXZpZ2F0aW9uLCBmb2N1c2VkRGF5UmVmOiBmb2N1c2VkRGF5UmVmIH0pKSkpKSkpKSkpO1xufTtcblxuY29uc3QgbG9jYWxpemF0aW9uID0ge1xuICBidXR0b25MYWJlbDogXCJDaG9vc2UgZGF0ZVwiLFxuICBwbGFjZWhvbGRlcjogXCJZWVlZLU1NLUREXCIsXG4gIHNlbGVjdGVkRGF0ZU1lc3NhZ2U6IFwiU2VsZWN0ZWQgZGF0ZSBpc1wiLFxuICBwcmV2TW9udGhMYWJlbDogXCJQcmV2aW91cyBtb250aFwiLFxuICBuZXh0TW9udGhMYWJlbDogXCJOZXh0IG1vbnRoXCIsXG4gIG1vbnRoU2VsZWN0TGFiZWw6IFwiTW9udGhcIixcbiAgeWVhclNlbGVjdExhYmVsOiBcIlllYXJcIixcbiAgY2xvc2VMYWJlbDogXCJDbG9zZSB3aW5kb3dcIixcbiAgY2FsZW5kYXJIZWFkaW5nOiBcIkNob29zZSBhIGRhdGVcIixcbiAgZGF5TmFtZXM6IFtcIlN1bmRheVwiLCBcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIiwgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiLCBcIlNhdHVyZGF5XCJdLFxuICBtb250aE5hbWVzOiBbXG4gICAgXCJKYW51YXJ5XCIsXG4gICAgXCJGZWJydWFyeVwiLFxuICAgIFwiTWFyY2hcIixcbiAgICBcIkFwcmlsXCIsXG4gICAgXCJNYXlcIixcbiAgICBcIkp1bmVcIixcbiAgICBcIkp1bHlcIixcbiAgICBcIkF1Z3VzdFwiLFxuICAgIFwiU2VwdGVtYmVyXCIsXG4gICAgXCJPY3RvYmVyXCIsXG4gICAgXCJOb3ZlbWJlclwiLFxuICAgIFwiRGVjZW1iZXJcIixcbiAgXSxcbiAgbW9udGhOYW1lc1Nob3J0OiBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPY3RcIiwgXCJOb3ZcIiwgXCJEZWNcIl0sXG4gIGxvY2FsZTogXCJlbi1HQlwiLFxufTtcblxuY29uc3QgaXNvQWRhcHRlciA9IHsgcGFyc2U6IHBhcnNlSVNPRGF0ZSwgZm9ybWF0OiBwcmludElTT0RhdGUgfTtcblxuY29uc3QgZHVldERhdGVQaWNrZXJDc3MgPSBcIi5kdWV0LWRhdGUgKiwuZHVldC1kYXRlICo6OmJlZm9yZSwuZHVldC1kYXRlICo6OmFmdGVye2JveC1zaXppbmc6Ym9yZGVyLWJveDttYXJnaW46MDt3aWR0aDphdXRvfS5kdWV0LWRhdGV7Ym94LXNpemluZzpib3JkZXItYm94O2NvbG9yOnZhcigtLWR1ZXQtY29sb3ItdGV4dCk7ZGlzcGxheTpibG9jaztmb250LWZhbWlseTp2YXIoLS1kdWV0LWZvbnQpO21hcmdpbjowO3Bvc2l0aW9uOnJlbGF0aXZlO3RleHQtYWxpZ246bGVmdDt3aWR0aDoxMDAlfS5kdWV0LWRhdGVfX2lucHV0ey13ZWJraXQtYXBwZWFyYW5jZTpub25lO2FwcGVhcmFuY2U6bm9uZTtiYWNrZ3JvdW5kOnZhcigtLWR1ZXQtY29sb3Itc3VyZmFjZSk7Ym9yZGVyOjFweCBzb2xpZCB2YXIoLS1kdWV0LWNvbG9yLWJvcmRlciwgdmFyKC0tZHVldC1jb2xvci10ZXh0KSk7Ym9yZGVyLXJhZGl1czp2YXIoLS1kdWV0LXJhZGl1cyk7Y29sb3I6dmFyKC0tZHVldC1jb2xvci10ZXh0KTtmbG9hdDpub25lO2ZvbnQtZmFtaWx5OnZhcigtLWR1ZXQtZm9udCk7Zm9udC1zaXplOjEwMCU7bGluZS1oZWlnaHQ6bm9ybWFsO3BhZGRpbmc6MTRweCA2MHB4IDE0cHggMTRweDt3aWR0aDoxMDAlfS5kdWV0LWRhdGVfX2lucHV0OmZvY3Vze2JvcmRlci1jb2xvcjp2YXIoLS1kdWV0LWNvbG9yLXByaW1hcnkpO2JveC1zaGFkb3c6MCAwIDAgMXB4IHZhcigtLWR1ZXQtY29sb3ItcHJpbWFyeSk7b3V0bGluZTowfS5kdWV0LWRhdGVfX2lucHV0Ojotd2Via2l0LWlucHV0LXBsYWNlaG9sZGVye2NvbG9yOnZhcigtLWR1ZXQtY29sb3ItcGxhY2Vob2xkZXIpO29wYWNpdHk6MX0uZHVldC1kYXRlX19pbnB1dDotbW96LXBsYWNlaG9sZGVye2NvbG9yOnZhcigtLWR1ZXQtY29sb3ItcGxhY2Vob2xkZXIpO29wYWNpdHk6MX0uZHVldC1kYXRlX19pbnB1dDotbXMtaW5wdXQtcGxhY2Vob2xkZXJ7Y29sb3I6dmFyKC0tZHVldC1jb2xvci1wbGFjZWhvbGRlcil9LmR1ZXQtZGF0ZV9faW5wdXQtd3JhcHBlcntwb3NpdGlvbjpyZWxhdGl2ZTt3aWR0aDoxMDAlfS5kdWV0LWRhdGVfX3RvZ2dsZXstbW96LWFwcGVhcmFuY2U6bm9uZTstd2Via2l0LWFwcGVhcmFuY2U6bm9uZTstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7YWxpZ24taXRlbXM6Y2VudGVyO2FwcGVhcmFuY2U6bm9uZTtiYWNrZ3JvdW5kOnZhcigtLWR1ZXQtY29sb3ItYnV0dG9uKTtib3JkZXI6MDtib3JkZXItcmFkaXVzOjA7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6dmFyKC0tZHVldC1yYWRpdXMpO2JvcmRlci10b3AtcmlnaHQtcmFkaXVzOnZhcigtLWR1ZXQtcmFkaXVzKTtib3gtc2hhZG93Omluc2V0IDFweCAwIDAgcmdiYSgwLCAwLCAwLCAwLjEpO2NvbG9yOnZhcigtLWR1ZXQtY29sb3ItdGV4dCk7Y3Vyc29yOnBvaW50ZXI7ZGlzcGxheTpmbGV4O2hlaWdodDpjYWxjKDEwMCUgLSAycHgpO2p1c3RpZnktY29udGVudDpjZW50ZXI7cGFkZGluZzowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjFweDt0b3A6MXB4O3VzZXItc2VsZWN0Om5vbmU7d2lkdGg6NDhweDt6LWluZGV4OjJ9LmR1ZXQtZGF0ZV9fdG9nZ2xlOmZvY3Vze2JveC1zaGFkb3c6MCAwIDAgMnB4IHZhcigtLWR1ZXQtY29sb3ItcHJpbWFyeSk7b3V0bGluZTowfS5kdWV0LWRhdGVfX3RvZ2dsZS1pY29ue2Rpc3BsYXk6ZmxleDtmbGV4LWJhc2lzOjEwMCU7anVzdGlmeS1jb250ZW50OmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXJ9LmR1ZXQtZGF0ZV9fZGlhbG9ne2Rpc3BsYXk6ZmxleDtsZWZ0OjA7bWluLXdpZHRoOjMyMHB4O29wYWNpdHk6MDtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MTAwJTt0cmFuc2Zvcm06c2NhbGUoMC45NikgdHJhbnNsYXRlWigwKSB0cmFuc2xhdGVZKC0yMHB4KTt0cmFuc2Zvcm0tb3JpZ2luOnRvcCByaWdodDt0cmFuc2l0aW9uOnRyYW5zZm9ybSAzMDBtcyBlYXNlLCBvcGFjaXR5IDMwMG1zIGVhc2UsIHZpc2liaWxpdHkgMzAwbXMgZWFzZTt2aXNpYmlsaXR5OmhpZGRlbjt3aWR0aDoxMDAlO3dpbGwtY2hhbmdlOnRyYW5zZm9ybSwgb3BhY2l0eSwgdmlzaWJpbGl0eTt6LWluZGV4OnZhcigtLWR1ZXQtei1pbmRleCl9QG1lZGlhIChtYXgtd2lkdGg6IDM1LjkzNzVlbSl7LmR1ZXQtZGF0ZV9fZGlhbG9ne2JhY2tncm91bmQ6dmFyKC0tZHVldC1jb2xvci1vdmVybGF5KTtib3R0b206MDtwb3NpdGlvbjpmaXhlZDtyaWdodDowO3RvcDowO3RyYW5zZm9ybTp0cmFuc2xhdGVaKDApO3RyYW5zZm9ybS1vcmlnaW46Ym90dG9tIGNlbnRlcn19LmR1ZXQtZGF0ZV9fZGlhbG9nLmlzLWxlZnR7bGVmdDphdXRvO3JpZ2h0OjA7d2lkdGg6YXV0b30uZHVldC1kYXRlX19kaWFsb2cuaXMtYWN0aXZle29wYWNpdHk6MTt0cmFuc2Zvcm06c2NhbGUoMS4wMDAxKSB0cmFuc2xhdGVaKDApIHRyYW5zbGF0ZVkoMCk7dmlzaWJpbGl0eTp2aXNpYmxlfS5kdWV0LWRhdGVfX2RpYWxvZy1jb250ZW50e2JhY2tncm91bmQ6dmFyKC0tZHVldC1jb2xvci1zdXJmYWNlKTtib3JkZXI6MXB4IHNvbGlkIHJnYmEoMCwgMCwgMCwgMC4xKTtib3JkZXItcmFkaXVzOnZhcigtLWR1ZXQtcmFkaXVzKTtib3gtc2hhZG93OjAgNHB4IDEwcHggMCByZ2JhKDAsIDAsIDAsIDAuMSk7bWFyZ2luLWxlZnQ6YXV0bzttYXJnaW4tdG9wOjhweDttYXgtd2lkdGg6MzEwcHg7bWluLXdpZHRoOjI5MHB4O3BhZGRpbmc6MTZweCAxNnB4IDIwcHg7cG9zaXRpb246cmVsYXRpdmU7dHJhbnNmb3JtOm5vbmU7d2lkdGg6MTAwJTt6LWluZGV4OnZhcigtLWR1ZXQtei1pbmRleCl9QG1lZGlhIChtYXgtd2lkdGg6IDM1LjkzNzVlbSl7LmR1ZXQtZGF0ZV9fZGlhbG9nLWNvbnRlbnR7Ym9yZGVyOjA7Ym9yZGVyLXJhZGl1czowO2JvcmRlci10b3AtbGVmdC1yYWRpdXM6dmFyKC0tZHVldC1yYWRpdXMpO2JvcmRlci10b3AtcmlnaHQtcmFkaXVzOnZhcigtLWR1ZXQtcmFkaXVzKTtib3R0b206MDtsZWZ0OjA7bWFyZ2luOjA7bWF4LXdpZHRoOm5vbmU7bWluLWhlaWdodDoyNmVtO29wYWNpdHk6MDtwYWRkaW5nOjAgOCUgMjBweDtwb3NpdGlvbjphYnNvbHV0ZTt0cmFuc2Zvcm06dHJhbnNsYXRlWigwKSB0cmFuc2xhdGVZKDEwMCUpO3RyYW5zaXRpb246dHJhbnNmb3JtIDQwMG1zIGVhc2UsIG9wYWNpdHkgNDAwbXMgZWFzZSwgdmlzaWJpbGl0eSA0MDBtcyBlYXNlO3Zpc2liaWxpdHk6aGlkZGVuO3dpbGwtY2hhbmdlOnRyYW5zZm9ybSwgb3BhY2l0eSwgdmlzaWJpbGl0eX0uaXMtYWN0aXZlIC5kdWV0LWRhdGVfX2RpYWxvZy1jb250ZW50e29wYWNpdHk6MTt0cmFuc2Zvcm06dHJhbnNsYXRlWigwKSB0cmFuc2xhdGVZKDApO3Zpc2liaWxpdHk6dmlzaWJsZX19LmR1ZXQtZGF0ZV9fdGFibGV7Ym9yZGVyLWNvbGxhcHNlOmNvbGxhcHNlO2JvcmRlci1zcGFjaW5nOjA7Y29sb3I6dmFyKC0tZHVldC1jb2xvci10ZXh0KTtmb250LXNpemU6MXJlbTtmb250LXdlaWdodDp2YXIoLS1kdWV0LWZvbnQtbm9ybWFsKTtsaW5lLWhlaWdodDoxLjI1O3RleHQtYWxpZ246Y2VudGVyO3dpZHRoOjEwMCV9LmR1ZXQtZGF0ZV9fdGFibGUtaGVhZGVye2ZvbnQtc2l6ZTowLjc1cmVtO2ZvbnQtd2VpZ2h0OnZhcigtLWR1ZXQtZm9udC1ib2xkKTtsZXR0ZXItc3BhY2luZzoxcHg7bGluZS1oZWlnaHQ6MS4yNTtwYWRkaW5nLWJvdHRvbTo4cHg7dGV4dC1kZWNvcmF0aW9uOm5vbmU7dGV4dC10cmFuc2Zvcm06dXBwZXJjYXNlfS5kdWV0LWRhdGVfX2NlbGx7dGV4dC1hbGlnbjpjZW50ZXJ9LmR1ZXQtZGF0ZV9fZGF5ey1tb3otYXBwZWFyYW5jZTpub25lOy13ZWJraXQtYXBwZWFyYW5jZTpub25lO2FwcGVhcmFuY2U6bm9uZTtiYWNrZ3JvdW5kOnRyYW5zcGFyZW50O2JvcmRlcjowO2JvcmRlci1yYWRpdXM6NTAlO2NvbG9yOnZhcigtLWR1ZXQtY29sb3ItdGV4dCk7Y3Vyc29yOnBvaW50ZXI7ZGlzcGxheTppbmxpbmUtYmxvY2s7Zm9udC1mYW1pbHk6dmFyKC0tZHVldC1mb250KTtmb250LXNpemU6MC44NzVyZW07Zm9udC12YXJpYW50LW51bWVyaWM6dGFidWxhci1udW1zO2ZvbnQtd2VpZ2h0OnZhcigtLWR1ZXQtZm9udC1ub3JtYWwpO2hlaWdodDozNnB4O2xpbmUtaGVpZ2h0OjEuMjU7cGFkZGluZzowIDAgMXB4O3Bvc2l0aW9uOnJlbGF0aXZlO3RleHQtYWxpZ246Y2VudGVyO3ZlcnRpY2FsLWFsaWduOm1pZGRsZTt3aWR0aDozNnB4O3otaW5kZXg6MX0uZHVldC1kYXRlX19kYXkuaXMtdG9kYXl7Ym94LXNoYWRvdzowIDAgMCAxcHggdmFyKC0tZHVldC1jb2xvci1wcmltYXJ5KTtwb3NpdGlvbjpyZWxhdGl2ZTt6LWluZGV4OjIwMH0uZHVldC1kYXRlX19kYXk6aG92ZXI6OmJlZm9yZSwuZHVldC1kYXRlX19kYXkuaXMtdG9kYXk6OmJlZm9yZXtiYWNrZ3JvdW5kOnZhcigtLWR1ZXQtY29sb3ItcHJpbWFyeSk7Ym9yZGVyLXJhZGl1czo1MCU7Ym90dG9tOjA7Y29udGVudDpcXFwiXFxcIjtsZWZ0OjA7b3BhY2l0eTowLjA2O3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7dG9wOjB9LmR1ZXQtZGF0ZV9fZGF5W2FyaWEtcHJlc3NlZD10cnVlXSwuZHVldC1kYXRlX19kYXk6Zm9jdXN7YmFja2dyb3VuZDp2YXIoLS1kdWV0LWNvbG9yLXByaW1hcnkpO2JveC1zaGFkb3c6bm9uZTtjb2xvcjp2YXIoLS1kdWV0LWNvbG9yLXRleHQtYWN0aXZlKTtvdXRsaW5lOjB9LmR1ZXQtZGF0ZV9fZGF5OmFjdGl2ZXtiYWNrZ3JvdW5kOnZhcigtLWR1ZXQtY29sb3ItcHJpbWFyeSk7Ym94LXNoYWRvdzowIDAgNXB4IHZhcigtLWR1ZXQtY29sb3ItcHJpbWFyeSk7Y29sb3I6dmFyKC0tZHVldC1jb2xvci10ZXh0LWFjdGl2ZSk7ei1pbmRleDoyMDB9LmR1ZXQtZGF0ZV9fZGF5OmZvY3Vze2JveC1zaGFkb3c6MCAwIDVweCB2YXIoLS1kdWV0LWNvbG9yLXByaW1hcnkpO3otaW5kZXg6MjAwfS5kdWV0LWRhdGVfX2RheTpub3QoLmlzLW1vbnRoKXtib3gtc2hhZG93Om5vbmV9LmR1ZXQtZGF0ZV9fZGF5Om5vdCguaXMtbW9udGgpLC5kdWV0LWRhdGVfX2RheVthcmlhLWRpc2FibGVkPXRydWVde2JhY2tncm91bmQ6dHJhbnNwYXJlbnQ7Y29sb3I6dmFyKC0tZHVldC1jb2xvci10ZXh0KTtjdXJzb3I6ZGVmYXVsdDtvcGFjaXR5OjAuNX0uZHVldC1kYXRlX19kYXlbYXJpYS1kaXNhYmxlZD10cnVlXS5pcy10b2RheXtib3gtc2hhZG93OjAgMCAwIDFweCB2YXIoLS1kdWV0LWNvbG9yLXByaW1hcnkpfS5kdWV0LWRhdGVfX2RheVthcmlhLWRpc2FibGVkPXRydWVdLmlzLXRvZGF5OmZvY3Vze2JveC1zaGFkb3c6MCAwIDVweCB2YXIoLS1kdWV0LWNvbG9yLXByaW1hcnkpO2JhY2tncm91bmQ6dmFyKC0tZHVldC1jb2xvci1wcmltYXJ5KTtjb2xvcjp2YXIoLS1kdWV0LWNvbG9yLXRleHQtYWN0aXZlKX0uZHVldC1kYXRlX19kYXlbYXJpYS1kaXNhYmxlZD10cnVlXTpub3QoLmlzLXRvZGF5KTo6YmVmb3Jle2Rpc3BsYXk6bm9uZX0uZHVldC1kYXRlX19kYXkuaXMtb3V0c2lkZXtiYWNrZ3JvdW5kOnZhcigtLWR1ZXQtY29sb3ItYnV0dG9uKTtib3gtc2hhZG93Om5vbmU7Y29sb3I6dmFyKC0tZHVldC1jb2xvci10ZXh0KTtjdXJzb3I6ZGVmYXVsdDtvcGFjaXR5OjAuNjtwb2ludGVyLWV2ZW50czpub25lfS5kdWV0LWRhdGVfX2RheS5pcy1vdXRzaWRlOjpiZWZvcmV7ZGlzcGxheTpub25lfS5kdWV0LWRhdGVfX2hlYWRlcnthbGlnbi1pdGVtczpjZW50ZXI7ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVuO21hcmdpbi1ib3R0b206MTZweDt3aWR0aDoxMDAlfS5kdWV0LWRhdGVfX25hdnt3aGl0ZS1zcGFjZTpub3dyYXB9LmR1ZXQtZGF0ZV9fcHJldiwuZHVldC1kYXRlX19uZXh0ey1tb3otYXBwZWFyYW5jZTpub25lOy13ZWJraXQtYXBwZWFyYW5jZTpub25lO2FsaWduLWl0ZW1zOmNlbnRlcjthcHBlYXJhbmNlOm5vbmU7YmFja2dyb3VuZDp2YXIoLS1kdWV0LWNvbG9yLWJ1dHRvbik7Ym9yZGVyOjA7Ym9yZGVyLXJhZGl1czo1MCU7Y29sb3I6dmFyKC0tZHVldC1jb2xvci10ZXh0KTtjdXJzb3I6cG9pbnRlcjtkaXNwbGF5OmlubGluZS1mbGV4O2hlaWdodDozMnB4O2p1c3RpZnktY29udGVudDpjZW50ZXI7bWFyZ2luLWxlZnQ6OHB4O3BhZGRpbmc6MDt0cmFuc2l0aW9uOmJhY2tncm91bmQtY29sb3IgMzAwbXMgZWFzZTt3aWR0aDozMnB4fUBtZWRpYSAobWF4LXdpZHRoOiAzNS45Mzc1ZW0pey5kdWV0LWRhdGVfX3ByZXYsLmR1ZXQtZGF0ZV9fbmV4dHtoZWlnaHQ6NDBweDt3aWR0aDo0MHB4fX0uZHVldC1kYXRlX19wcmV2OmZvY3VzLC5kdWV0LWRhdGVfX25leHQ6Zm9jdXN7Ym94LXNoYWRvdzowIDAgMCAycHggdmFyKC0tZHVldC1jb2xvci1wcmltYXJ5KTtvdXRsaW5lOjB9LmR1ZXQtZGF0ZV9fcHJldjphY3RpdmU6Zm9jdXMsLmR1ZXQtZGF0ZV9fbmV4dDphY3RpdmU6Zm9jdXN7Ym94LXNoYWRvdzpub25lfS5kdWV0LWRhdGVfX3ByZXY6ZGlzYWJsZWQsLmR1ZXQtZGF0ZV9fbmV4dDpkaXNhYmxlZHtjdXJzb3I6ZGVmYXVsdDtvcGFjaXR5OjAuNX0uZHVldC1kYXRlX19wcmV2IHN2ZywuZHVldC1kYXRlX19uZXh0IHN2Z3ttYXJnaW46MCBhdXRvfS5kdWV0LWRhdGVfX3NlbGVjdHtkaXNwbGF5OmlubGluZS1mbGV4O21hcmdpbi10b3A6NHB4O3Bvc2l0aW9uOnJlbGF0aXZlfS5kdWV0LWRhdGVfX3NlbGVjdCBzcGFue21hcmdpbi1yaWdodDo0cHh9LmR1ZXQtZGF0ZV9fc2VsZWN0IHNlbGVjdHtjdXJzb3I6cG9pbnRlcjtmb250LXNpemU6MXJlbTtoZWlnaHQ6MTAwJTtsZWZ0OjA7b3BhY2l0eTowO3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO3dpZHRoOjEwMCU7ei1pbmRleDoyfS5kdWV0LWRhdGVfX3NlbGVjdCBzZWxlY3Q6Zm9jdXMrLmR1ZXQtZGF0ZV9fc2VsZWN0LWxhYmVse2JveC1zaGFkb3c6MCAwIDAgMnB4IHZhcigtLWR1ZXQtY29sb3ItcHJpbWFyeSl9LmR1ZXQtZGF0ZV9fc2VsZWN0LWxhYmVse2FsaWduLWl0ZW1zOmNlbnRlcjtib3JkZXItcmFkaXVzOnZhcigtLWR1ZXQtcmFkaXVzKTtjb2xvcjp2YXIoLS1kdWV0LWNvbG9yLXRleHQpO2Rpc3BsYXk6ZmxleDtmb250LXNpemU6MS4yNXJlbTtmb250LXdlaWdodDp2YXIoLS1kdWV0LWZvbnQtYm9sZCk7bGluZS1oZWlnaHQ6MS4yNTtwYWRkaW5nOjAgNHB4IDAgOHB4O3BvaW50ZXItZXZlbnRzOm5vbmU7cG9zaXRpb246cmVsYXRpdmU7d2lkdGg6MTAwJTt6LWluZGV4OjF9LmR1ZXQtZGF0ZV9fc2VsZWN0LWxhYmVsIHN2Z3t3aWR0aDoxNnB4O2hlaWdodDoxNnB4fS5kdWV0LWRhdGVfX21vYmlsZXthbGlnbi1pdGVtczpjZW50ZXI7Ym9yZGVyLWJvdHRvbToxcHggc29saWQgcmdiYSgwLCAwLCAwLCAwLjEyKTtkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW47bWFyZ2luLWJvdHRvbToyMHB4O21hcmdpbi1sZWZ0Oi0xMCU7b3ZlcmZsb3c6aGlkZGVuO3BhZGRpbmc6MTJweCAyMHB4O3Bvc2l0aW9uOnJlbGF0aXZlO3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXM7d2hpdGUtc3BhY2U6bm93cmFwO3dpZHRoOjEyMCV9QG1lZGlhIChtaW4td2lkdGg6IDM2ZW0pey5kdWV0LWRhdGVfX21vYmlsZXtib3JkZXI6MDttYXJnaW46MDtvdmVyZmxvdzp2aXNpYmxlO3BhZGRpbmc6MDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDotOHB4O3RvcDotOHB4O3dpZHRoOmF1dG99fS5kdWV0LWRhdGVfX21vYmlsZS1oZWFkaW5ne2Rpc3BsYXk6aW5saW5lLWJsb2NrO2ZvbnQtd2VpZ2h0OnZhcigtLWR1ZXQtZm9udC1ib2xkKTttYXgtd2lkdGg6ODQlO292ZXJmbG93OmhpZGRlbjt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzO3doaXRlLXNwYWNlOm5vd3JhcH1AbWVkaWEgKG1pbi13aWR0aDogMzZlbSl7LmR1ZXQtZGF0ZV9fbW9iaWxlLWhlYWRpbmd7ZGlzcGxheTpub25lfX0uZHVldC1kYXRlX19jbG9zZXstd2Via2l0LWFwcGVhcmFuY2U6bm9uZTthbGlnbi1pdGVtczpjZW50ZXI7YXBwZWFyYW5jZTpub25lO2JhY2tncm91bmQ6dmFyKC0tZHVldC1jb2xvci1idXR0b24pO2JvcmRlcjowO2JvcmRlci1yYWRpdXM6NTAlO2NvbG9yOnZhcigtLWR1ZXQtY29sb3ItdGV4dCk7Y3Vyc29yOnBvaW50ZXI7ZGlzcGxheTpmbGV4O2hlaWdodDoyNHB4O2p1c3RpZnktY29udGVudDpjZW50ZXI7cGFkZGluZzowO3dpZHRoOjI0cHh9QG1lZGlhIChtaW4td2lkdGg6IDM2ZW0pey5kdWV0LWRhdGVfX2Nsb3Nle29wYWNpdHk6MH19LmR1ZXQtZGF0ZV9fY2xvc2U6Zm9jdXN7Ym94LXNoYWRvdzowIDAgMCAycHggdmFyKC0tZHVldC1jb2xvci1wcmltYXJ5KTtvdXRsaW5lOm5vbmV9QG1lZGlhIChtaW4td2lkdGg6IDM2ZW0pey5kdWV0LWRhdGVfX2Nsb3NlOmZvY3Vze29wYWNpdHk6MX19LmR1ZXQtZGF0ZV9fY2xvc2Ugc3Zne21hcmdpbjowIGF1dG99LmR1ZXQtZGF0ZV9fdmhpZGRlbntib3JkZXI6MDtjbGlwOnJlY3QoMXB4LCAxcHgsIDFweCwgMXB4KTtoZWlnaHQ6MXB4O292ZXJmbG93OmhpZGRlbjtwYWRkaW5nOjA7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7d2lkdGg6MXB4fVwiO1xuXG5mdW5jdGlvbiByYW5nZShmcm9tLCB0bykge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGkgPSBmcm9tOyBpIDw9IHRvOyBpKyspIHtcbiAgICByZXN1bHQucHVzaChpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3Qga2V5Q29kZSA9IHtcbiAgVEFCOiA5LFxuICBFU0M6IDI3LFxuICBTUEFDRTogMzIsXG4gIFBBR0VfVVA6IDMzLFxuICBQQUdFX0RPV046IDM0LFxuICBFTkQ6IDM1LFxuICBIT01FOiAzNixcbiAgTEVGVDogMzcsXG4gIFVQOiAzOCxcbiAgUklHSFQ6IDM5LFxuICBET1dOOiA0MCxcbn07XG5mdW5jdGlvbiBjbGVhblZhbHVlKGlucHV0LCByZWdleCkge1xuICBjb25zdCB2YWx1ZSA9IGlucHV0LnZhbHVlO1xuICBjb25zdCBjdXJzb3IgPSBpbnB1dC5zZWxlY3Rpb25TdGFydDtcbiAgY29uc3QgYmVmb3JlQ3Vyc29yID0gdmFsdWUuc2xpY2UoMCwgY3Vyc29yKTtcbiAgY29uc3QgYWZ0ZXJDdXJzb3IgPSB2YWx1ZS5zbGljZShjdXJzb3IsIHZhbHVlLmxlbmd0aCk7XG4gIGNvbnN0IGZpbHRlcmVkQmVmb3JlQ3Vyc29yID0gYmVmb3JlQ3Vyc29yLnJlcGxhY2UocmVnZXgsIFwiXCIpO1xuICBjb25zdCBmaWx0ZXJBZnRlckN1cnNvciA9IGFmdGVyQ3Vyc29yLnJlcGxhY2UocmVnZXgsIFwiXCIpO1xuICBjb25zdCBuZXdWYWx1ZSA9IGZpbHRlcmVkQmVmb3JlQ3Vyc29yICsgZmlsdGVyQWZ0ZXJDdXJzb3I7XG4gIGNvbnN0IG5ld0N1cnNvciA9IGZpbHRlcmVkQmVmb3JlQ3Vyc29yLmxlbmd0aDtcbiAgaW5wdXQudmFsdWUgPSBuZXdWYWx1ZTtcbiAgaW5wdXQuc2VsZWN0aW9uU3RhcnQgPSBpbnB1dC5zZWxlY3Rpb25FbmQgPSBuZXdDdXJzb3I7XG4gIHJldHVybiBuZXdWYWx1ZTtcbn1cbmNvbnN0IERJU0FMTE9XRURfQ0hBUkFDVEVSUyA9IC9bXjAtOVxcLlxcL1xcLV0rL2c7XG5jb25zdCBUUkFOU0lUSU9OX01TID0gMzAwO1xuY29uc3QgRHVldERhdGVQaWNrZXIgPSBjbGFzcyBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9fcmVnaXN0ZXJIb3N0KCk7XG4gICAgdGhpcy5kdWV0Q2hhbmdlID0gY3JlYXRlRXZlbnQodGhpcywgXCJkdWV0Q2hhbmdlXCIsIDcpO1xuICAgIHRoaXMuZHVldEJsdXIgPSBjcmVhdGVFdmVudCh0aGlzLCBcImR1ZXRCbHVyXCIsIDcpO1xuICAgIHRoaXMuZHVldEZvY3VzID0gY3JlYXRlRXZlbnQodGhpcywgXCJkdWV0Rm9jdXNcIiwgNyk7XG4gICAgdGhpcy5kdWV0T3BlbiA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiZHVldE9wZW5cIiwgNyk7XG4gICAgdGhpcy5kdWV0Q2xvc2UgPSBjcmVhdGVFdmVudCh0aGlzLCBcImR1ZXRDbG9zZVwiLCA3KTtcbiAgICAvKipcbiAgICAgKiBPd24gUHJvcGVydGllc1xuICAgICAqL1xuICAgIHRoaXMubW9udGhTZWxlY3RJZCA9IGNyZWF0ZUlkZW50aWZpZXIoXCJEdWV0RGF0ZU1vbnRoXCIpO1xuICAgIHRoaXMueWVhclNlbGVjdElkID0gY3JlYXRlSWRlbnRpZmllcihcIkR1ZXREYXRlWWVhclwiKTtcbiAgICB0aGlzLmRpYWxvZ0xhYmVsSWQgPSBjcmVhdGVJZGVudGlmaWVyKFwiRHVldERhdGVMYWJlbFwiKTtcbiAgICB0aGlzLmluaXRpYWxUb3VjaFggPSBudWxsO1xuICAgIHRoaXMuaW5pdGlhbFRvdWNoWSA9IG51bGw7XG4gICAgLyoqXG4gICAgICogU3RhdGUoKSB2YXJpYWJsZXNcbiAgICAgKi9cbiAgICB0aGlzLmFjdGl2ZUZvY3VzID0gZmFsc2U7XG4gICAgdGhpcy5mb2N1c2VkRGF5ID0gbmV3IERhdGUoKTtcbiAgICB0aGlzLm9wZW4gPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBQdWJsaWMgUHJvcGVydHkgQVBJXG4gICAgICovXG4gICAgLyoqXG4gICAgICogTmFtZSBvZiB0aGUgZGF0ZSBwaWNrZXIgaW5wdXQuXG4gICAgICovXG4gICAgdGhpcy5uYW1lID0gXCJkYXRlXCI7XG4gICAgLyoqXG4gICAgICogQWRkcyBhIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgZGF0ZSBwaWNrZXIgaW5wdXQuIFVzZSB0aGlzIGluc3RlYWQgb2YgaHRtbCBgaWRgIGF0dHJpYnV0ZS5cbiAgICAgKi9cbiAgICB0aGlzLmlkZW50aWZpZXIgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIE1ha2VzIHRoZSBkYXRlIHBpY2tlciBpbnB1dCBjb21wb25lbnQgZGlzYWJsZWQuIFRoaXMgcHJldmVudHMgdXNlcnMgZnJvbSBiZWluZyBhYmxlIHRvXG4gICAgICogaW50ZXJhY3Qgd2l0aCB0aGUgaW5wdXQsIGFuZCBjb252ZXlzIGl0cyBpbmFjdGl2ZSBzdGF0ZSB0byBhc3Npc3RpdmUgdGVjaG5vbG9naWVzLlxuICAgICAqL1xuICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBGb3JjZXMgdGhlIG9wZW5pbmcgZGlyZWN0aW9uIG9mIHRoZSBjYWxlbmRhciBtb2RhbCB0byBiZSBhbHdheXMgbGVmdCBvciByaWdodC5cbiAgICAgKiBUaGlzIHNldHRpbmcgY2FuIGJlIHVzZWZ1bCB3aGVuIHRoZSBpbnB1dCBpcyBzbWFsbGVyIHRoYW4gdGhlIG9wZW5pbmcgZGF0ZSBwaWNrZXJcbiAgICAgKiB3b3VsZCBiZSBhcyBieSBkZWZhdWx0IHRoZSBwaWNrZXIgYWx3YXlzIG9wZW5zIHRvd2FyZHMgcmlnaHQuXG4gICAgICovXG4gICAgdGhpcy5kaXJlY3Rpb24gPSBcInJpZ2h0XCI7XG4gICAgLyoqXG4gICAgICogU2hvdWxkIHRoZSBpbnB1dCBiZSBtYXJrZWQgYXMgcmVxdWlyZWQ/XG4gICAgICovXG4gICAgdGhpcy5yZXF1aXJlZCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIERhdGUgdmFsdWUuIE11c3QgYmUgaW4gSVMwLTg2MDEgZm9ybWF0OiBZWVlZLU1NLURELlxuICAgICAqL1xuICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIE1pbmltdW0gZGF0ZSBhbGxvd2VkIHRvIGJlIHBpY2tlZC4gTXVzdCBiZSBpbiBJUzAtODYwMSBmb3JtYXQ6IFlZWVktTU0tREQuXG4gICAgICogVGhpcyBzZXR0aW5nIGNhbiBiZSB1c2VkIGFsb25lIG9yIHRvZ2V0aGVyIHdpdGggdGhlIG1heCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICB0aGlzLm1pbiA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogTWF4aW11bSBkYXRlIGFsbG93ZWQgdG8gYmUgcGlja2VkLiBNdXN0IGJlIGluIElTMC04NjAxIGZvcm1hdDogWVlZWS1NTS1ERC5cbiAgICAgKiBUaGlzIHNldHRpbmcgY2FuIGJlIHVzZWQgYWxvbmUgb3IgdG9nZXRoZXIgd2l0aCB0aGUgbWluIHByb3BlcnR5LlxuICAgICAqL1xuICAgIHRoaXMubWF4ID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBXaGljaCBkYXkgaXMgY29uc2lkZXJlZCBmaXJzdCBkYXkgb2YgdGhlIHdlZWs/IGAwYCBmb3IgU3VuZGF5LCBgMWAgZm9yIE1vbmRheSwgZXRjLlxuICAgICAqIERlZmF1bHQgaXMgTW9uZGF5LlxuICAgICAqL1xuICAgIHRoaXMuZmlyc3REYXlPZldlZWsgPSBEYXlzT2ZXZWVrLk1vbmRheTtcbiAgICAvKipcbiAgICAgKiBCdXR0b24gbGFiZWxzLCBkYXkgbmFtZXMsIG1vbnRoIG5hbWVzLCBldGMsIHVzZWQgZm9yIGxvY2FsaXphdGlvbi5cbiAgICAgKiBEZWZhdWx0IGlzIEVuZ2xpc2guXG4gICAgICovXG4gICAgdGhpcy5sb2NhbGl6YXRpb24gPSBsb2NhbGl6YXRpb247XG4gICAgLyoqXG4gICAgICogRGF0ZSBhZGFwdGVyLCBmb3IgY3VzdG9tIHBhcnNpbmcvZm9ybWF0dGluZy5cbiAgICAgKiBNdXN0IGJlIG9iamVjdCB3aXRoIGEgYHBhcnNlYCBmdW5jdGlvbiB3aGljaCBhY2NlcHRzIGEgYHN0cmluZ2AgYW5kIHJldHVybnMgYSBgRGF0ZWAsXG4gICAgICogYW5kIGEgYGZvcm1hdGAgZnVuY3Rpb24gd2hpY2ggYWNjZXB0cyBhIGBEYXRlYCBhbmQgcmV0dXJucyBhIGBzdHJpbmdgLlxuICAgICAqIERlZmF1bHQgaXMgSVMwLTg2MDEgcGFyc2luZyBhbmQgZm9ybWF0dGluZy5cbiAgICAgKi9cbiAgICB0aGlzLmRhdGVBZGFwdGVyID0gaXNvQWRhcHRlcjtcbiAgICAvKipcbiAgICAgKiBDb250cm9scyB3aGljaCBkYXlzIGFyZSBkaXNhYmxlZCBhbmQgdGhlcmVmb3JlIGRpc2FsbG93ZWQuXG4gICAgICogRm9yIGV4YW1wbGUsIHRoaXMgY2FuIGJlIHVzZWQgdG8gZGlzYWxsb3cgc2VsZWN0aW9uIG9mIHdlZWtlbmRzLlxuICAgICAqL1xuICAgIHRoaXMuaXNEYXRlRGlzYWJsZWQgPSAoKSA9PiBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBMb2NhbCBtZXRob2RzLlxuICAgICAqL1xuICAgIHRoaXMuZW5hYmxlQWN0aXZlRm9jdXMgPSAoKSA9PiB7XG4gICAgICB0aGlzLmFjdGl2ZUZvY3VzID0gdHJ1ZTtcbiAgICB9O1xuICAgIHRoaXMuZGlzYWJsZUFjdGl2ZUZvY3VzID0gKCkgPT4ge1xuICAgICAgdGhpcy5hY3RpdmVGb2N1cyA9IGZhbHNlO1xuICAgIH07XG4gICAgdGhpcy50b2dnbGVPcGVuID0gKGUpID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMub3BlbiA/IHRoaXMuaGlkZShmYWxzZSkgOiB0aGlzLnNob3coKTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlRXNjS2V5ID0gKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0ga2V5Q29kZS5FU0MpIHtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZUJsdXIgPSAoZXZlbnQpID0+IHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgdGhpcy5kdWV0Qmx1ci5lbWl0KHtcbiAgICAgICAgY29tcG9uZW50OiBcImR1ZXQtZGF0ZS1waWNrZXJcIixcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVGb2N1cyA9IChldmVudCkgPT4ge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB0aGlzLmR1ZXRGb2N1cy5lbWl0KHtcbiAgICAgICAgY29tcG9uZW50OiBcImR1ZXQtZGF0ZS1waWNrZXJcIixcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVUb3VjaFN0YXJ0ID0gKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCB0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgdGhpcy5pbml0aWFsVG91Y2hYID0gdG91Y2gucGFnZVg7XG4gICAgICB0aGlzLmluaXRpYWxUb3VjaFkgPSB0b3VjaC5wYWdlWTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlVG91Y2hNb3ZlID0gKGV2ZW50KSA9PiB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVUb3VjaEVuZCA9IChldmVudCkgPT4ge1xuICAgICAgY29uc3QgdG91Y2ggPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICAgIGNvbnN0IGRpc3RYID0gdG91Y2gucGFnZVggLSB0aGlzLmluaXRpYWxUb3VjaFg7IC8vIGdldCBob3Jpem9udGFsIGRpc3QgdHJhdmVsZWRcbiAgICAgIGNvbnN0IGRpc3RZID0gdG91Y2gucGFnZVkgLSB0aGlzLmluaXRpYWxUb3VjaFk7IC8vIGdldCB2ZXJ0aWNhbCBkaXN0IHRyYXZlbGVkXG4gICAgICBjb25zdCB0aHJlc2hvbGQgPSA3MDtcbiAgICAgIGNvbnN0IGlzSG9yaXpvbnRhbFN3aXBlID0gTWF0aC5hYnMoZGlzdFgpID49IHRocmVzaG9sZCAmJiBNYXRoLmFicyhkaXN0WSkgPD0gdGhyZXNob2xkO1xuICAgICAgY29uc3QgaXNEb3dud2FyZHNTd2lwZSA9IE1hdGguYWJzKGRpc3RZKSA+PSB0aHJlc2hvbGQgJiYgTWF0aC5hYnMoZGlzdFgpIDw9IHRocmVzaG9sZCAmJiBkaXN0WSA+IDA7XG4gICAgICBpZiAoaXNIb3Jpem9udGFsU3dpcGUpIHtcbiAgICAgICAgdGhpcy5hZGRNb250aHMoZGlzdFggPCAwID8gMSA6IC0xKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzRG93bndhcmRzU3dpcGUpIHtcbiAgICAgICAgdGhpcy5oaWRlKGZhbHNlKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5pdGlhbFRvdWNoWSA9IG51bGw7XG4gICAgICB0aGlzLmluaXRpYWxUb3VjaFggPSBudWxsO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVOZXh0TW9udGhDbGljayA9IChldmVudCkgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuYWRkTW9udGhzKDEpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVQcmV2aW91c01vbnRoQ2xpY2sgPSAoZXZlbnQpID0+IHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLmFkZE1vbnRocygtMSk7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZUZpcnN0Rm9jdXNhYmxlS2V5ZG93biA9IChldmVudCkgPT4ge1xuICAgICAgLy8gdGhpcyBlbnN1cmVzIGZvY3VzIGlzIHRyYXBwZWQgaW5zaWRlIHRoZSBkaWFsb2dcbiAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBrZXlDb2RlLlRBQiAmJiBldmVudC5zaGlmdEtleSkge1xuICAgICAgICB0aGlzLmZvY3VzZWREYXlOb2RlLmZvY3VzKCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZUtleWJvYXJkTmF2aWdhdGlvbiA9IChldmVudCkgPT4ge1xuICAgICAgLy8gaGFuZGxlIHRhYiBzZXBhcmF0ZWx5LCBzaW5jZSBpdCBuZWVkcyB0byBiZSB0cmVhdGVkXG4gICAgICAvLyBkaWZmZXJlbnRseSB0byBvdGhlciBrZXlib2FyZCBpbnRlcmFjdGlvbnNcbiAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBrZXlDb2RlLlRBQiAmJiAhZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5maXJzdEZvY3VzYWJsZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG4gICAgICAgIGNhc2Uga2V5Q29kZS5SSUdIVDpcbiAgICAgICAgICB0aGlzLmFkZERheXMoMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Uga2V5Q29kZS5MRUZUOlxuICAgICAgICAgIHRoaXMuYWRkRGF5cygtMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Uga2V5Q29kZS5ET1dOOlxuICAgICAgICAgIHRoaXMuYWRkRGF5cyg3KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBrZXlDb2RlLlVQOlxuICAgICAgICAgIHRoaXMuYWRkRGF5cygtNyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Uga2V5Q29kZS5QQUdFX1VQOlxuICAgICAgICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgdGhpcy5hZGRZZWFycygtMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hZGRNb250aHMoLTEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBrZXlDb2RlLlBBR0VfRE9XTjpcbiAgICAgICAgICBpZiAoZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkWWVhcnMoMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hZGRNb250aHMoMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGtleUNvZGUuSE9NRTpcbiAgICAgICAgICB0aGlzLnN0YXJ0T2ZXZWVrKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Uga2V5Q29kZS5FTkQ6XG4gICAgICAgICAgdGhpcy5lbmRPZldlZWsoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBoYW5kbGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoaGFuZGxlZCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmVuYWJsZUFjdGl2ZUZvY3VzKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZURheVNlbGVjdCA9IChfZXZlbnQsIGRheSkgPT4ge1xuICAgICAgY29uc3QgaXNJblJhbmdlID0gaW5SYW5nZShkYXksIHBhcnNlSVNPRGF0ZSh0aGlzLm1pbiksIHBhcnNlSVNPRGF0ZSh0aGlzLm1heCkpO1xuICAgICAgY29uc3QgaXNBbGxvd2VkID0gIXRoaXMuaXNEYXRlRGlzYWJsZWQoZGF5KTtcbiAgICAgIGlmIChpc0luUmFuZ2UgJiYgaXNBbGxvd2VkKSB7XG4gICAgICAgIHRoaXMuc2V0VmFsdWUoZGF5KTtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gZm9yIGNvbnNpc3RlbmN5IHdlIHNob3VsZCBzZXQgdGhlIGZvY3VzZWQgZGF5IGluIGNhc2VzIHdoZXJlXG4gICAgICAgIC8vIHVzZXIgaGFzIHNlbGVjdGVkIGEgZGF5IHRoYXQgaGFzIGJlZW4gc3BlY2lmaWNhbGx5IGRpc2FsbG93ZWRcbiAgICAgICAgdGhpcy5zZXRGb2N1c2VkRGF5KGRheSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZU1vbnRoU2VsZWN0ID0gZSA9PiB7XG4gICAgICB0aGlzLnNldE1vbnRoKHBhcnNlSW50KGUudGFyZ2V0LnZhbHVlLCAxMCkpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVZZWFyU2VsZWN0ID0gZSA9PiB7XG4gICAgICB0aGlzLnNldFllYXIocGFyc2VJbnQoZS50YXJnZXQudmFsdWUsIDEwKSk7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZUlucHV0Q2hhbmdlID0gKCkgPT4ge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5kYXRlUGlja2VySW5wdXQ7XG4gICAgICAvLyBjbGVhbiB1cCBhbnkgaW52YWxpZCBjaGFyYWN0ZXJzXG4gICAgICBjbGVhblZhbHVlKHRhcmdldCwgRElTQUxMT1dFRF9DSEFSQUNURVJTKTtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZGF0ZUFkYXB0ZXIucGFyc2UodGFyZ2V0LnZhbHVlLCBjcmVhdGVEYXRlKTtcbiAgICAgIGlmIChwYXJzZWQgfHwgdGFyZ2V0LnZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgIHRoaXMuc2V0VmFsdWUocGFyc2VkKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMucHJvY2Vzc0ZvY3VzZWREYXlOb2RlID0gKGVsZW1lbnQpID0+IHtcbiAgICAgIHRoaXMuZm9jdXNlZERheU5vZGUgPSBlbGVtZW50O1xuICAgICAgaWYgKHRoaXMuYWN0aXZlRm9jdXMgJiYgdGhpcy5vcGVuKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gZWxlbWVudC5mb2N1cygpLCAwKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuY3JlYXRlRGF0ZUZvcm1hdHRlcnMoKTtcbiAgfVxuICBjcmVhdGVEYXRlRm9ybWF0dGVycygpIHtcbiAgICB0aGlzLmRhdGVGb3JtYXRTaG9ydCA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KHRoaXMubG9jYWxpemF0aW9uLmxvY2FsZSwgeyBkYXk6IFwibnVtZXJpY1wiLCBtb250aDogXCJsb25nXCIgfSk7XG4gICAgdGhpcy5kYXRlRm9ybWF0TG9uZyA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KHRoaXMubG9jYWxpemF0aW9uLmxvY2FsZSwge1xuICAgICAgZGF5OiBcIm51bWVyaWNcIixcbiAgICAgIG1vbnRoOiBcImxvbmdcIixcbiAgICAgIHllYXI6IFwibnVtZXJpY1wiLFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDb21wb25lbnQgZXZlbnQgaGFuZGxpbmcuXG4gICAqL1xuICBoYW5kbGVEb2N1bWVudENsaWNrKGUpIHtcbiAgICBpZiAoIXRoaXMub3Blbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyB0aGUgZGlhbG9nIGFuZCB0aGUgYnV0dG9uIGFyZW4ndCBjb25zaWRlcmVkIGNsaWNrcyBvdXRzaWRlLlxuICAgIC8vIGRpYWxvZyBmb3Igb2J2aW91cyByZWFzb25zLCBidXQgdGhlIGJ1dHRvbiBuZWVkcyB0byBiZSBza2lwcGVkXG4gICAgLy8gc28gdGhhdCB0d28gdGhpbmdzIGFyZSBwb3NzaWJsZTpcbiAgICAvL1xuICAgIC8vIGEpIGNsaWNraW5nIGFnYWluIG9uIHRoZSBidXR0b24gd2hlbiBkaWFsb2cgaXMgb3BlbiBzaG91bGQgY2xvc2UgdGhlIG1vZGFsLlxuICAgIC8vICAgIHdpdGhvdXQgc2tpcHBpbmcgdGhlIGJ1dHRvbiBoZXJlLCB3ZSB3b3VsZCBzZWUgYSBjbGljayBvdXRzaWRlXG4gICAgLy8gICAgX2FuZF8gYSBjbGljayBvbiB0aGUgYnV0dG9uLCBzbyB0aGUgYG9wZW5gIHN0YXRlIGdvZXNcbiAgICAvLyAgICBvcGVuIC0+IGNsb3NlIChjbGljayBvdXRzaWRlKSAtPiBvcGVuIChjbGljayBidXR0b24pXG4gICAgLy9cbiAgICAvLyBiKSBjbGlja2luZyBhbm90aGVyIGRhdGUgcGlja2VyJ3MgYnV0dG9uIHNob3VsZCBjbG9zZSB0aGUgY3VycmVudCBjYWxlbmRhclxuICAgIC8vICAgIGFuZCBvcGVuIHRoZSBuZXcgb25lLiB0aGlzIG1lYW5zIHdlIGNhbid0IHN0b3BQcm9wYWdhdGlvbigpIG9uIHRoZSBidXR0b24gaXRzZWxmXG4gICAgLy9cbiAgICAvLyB0aGlzIHdhcyB0aGUgb25seSBzYXRpc2ZhY3RvcnkgY29tYmluYXRpb24gb2YgdGhpbmdzIHRvIGdldCB0aGUgYWJvdmUgdG8gd29ya1xuICAgIGNvbnN0IGlzQ2xpY2tPdXRzaWRlID0gZVxuICAgICAgLmNvbXBvc2VkUGF0aCgpXG4gICAgICAuZXZlcnkobm9kZSA9PiBub2RlICE9PSB0aGlzLmRpYWxvZ1dyYXBwZXJOb2RlICYmIG5vZGUgIT09IHRoaXMuZGF0ZVBpY2tlckJ1dHRvbik7XG4gICAgaWYgKGlzQ2xpY2tPdXRzaWRlKSB7XG4gICAgICB0aGlzLmhpZGUoZmFsc2UpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUHVibGljIG1ldGhvZHMgQVBJXG4gICAqL1xuICAvKipcbiAgICogU2V0cyBmb2N1cyBvbiB0aGUgZGF0ZSBwaWNrZXIncyBpbnB1dC4gVXNlIHRoaXMgbWV0aG9kIGluc3RlYWQgb2YgdGhlIGdsb2JhbCBgZm9jdXMoKWAuXG4gICAqL1xuICBhc3luYyBzZXRGb2N1cygpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRlUGlja2VySW5wdXQuZm9jdXMoKTtcbiAgfVxuICAvKipcbiAgICogU2hvdyB0aGUgY2FsZW5kYXIgbW9kYWwsIG1vdmluZyBmb2N1cyB0byB0aGUgY2FsZW5kYXIgaW5zaWRlLlxuICAgKi9cbiAgYXN5bmMgc2hvdygpIHtcbiAgICB0aGlzLm9wZW4gPSB0cnVlO1xuICAgIHRoaXMuZHVldE9wZW4uZW1pdCh7XG4gICAgICBjb21wb25lbnQ6IFwiZHVldC1kYXRlLXBpY2tlclwiLFxuICAgIH0pO1xuICAgIHRoaXMuc2V0Rm9jdXNlZERheShwYXJzZUlTT0RhdGUodGhpcy52YWx1ZSkgfHwgbmV3IERhdGUoKSk7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuZm9jdXNUaW1lb3V0SWQpO1xuICAgIHRoaXMuZm9jdXNUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMubW9udGhTZWxlY3ROb2RlLmZvY3VzKCksIFRSQU5TSVRJT05fTVMpO1xuICB9XG4gIC8qKlxuICAgKiBIaWRlIHRoZSBjYWxlbmRhciBtb2RhbC4gU2V0IGBtb3ZlRm9jdXNUb0J1dHRvbmAgdG8gZmFsc2UgdG8gcHJldmVudCBmb2N1c1xuICAgKiByZXR1cm5pbmcgdG8gdGhlIGRhdGUgcGlja2VyJ3MgYnV0dG9uLiBEZWZhdWx0IGlzIHRydWUuXG4gICAqL1xuICBhc3luYyBoaWRlKG1vdmVGb2N1c1RvQnV0dG9uID0gdHJ1ZSkge1xuICAgIHRoaXMub3BlbiA9IGZhbHNlO1xuICAgIHRoaXMuZHVldENsb3NlLmVtaXQoe1xuICAgICAgY29tcG9uZW50OiBcImR1ZXQtZGF0ZS1waWNrZXJcIixcbiAgICB9KTtcbiAgICAvLyBpbiBjYXNlcyB3aGVyZSBjYWxlbmRhciBpcyBxdWlja2x5IHNob3duIGFuZCBoaWRkZW5cbiAgICAvLyB3ZSBzaG91bGQgYXZvaWQgbW92aW5nIGZvY3VzIHRvIHRoZSBidXR0b25cbiAgICBjbGVhclRpbWVvdXQodGhpcy5mb2N1c1RpbWVvdXRJZCk7XG4gICAgaWYgKG1vdmVGb2N1c1RvQnV0dG9uKSB7XG4gICAgICAvLyBpT1MgVm9pY2VPdmVyIG5lZWRzIHRvIHdhaXQgZm9yIGFsbCB0cmFuc2l0aW9ucyB0byBmaW5pc2guXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuZGF0ZVBpY2tlckJ1dHRvbi5mb2N1cygpLCBUUkFOU0lUSU9OX01TICsgMjAwKTtcbiAgICB9XG4gIH1cbiAgYWRkRGF5cyhkYXlzKSB7XG4gICAgdGhpcy5zZXRGb2N1c2VkRGF5KGFkZERheXModGhpcy5mb2N1c2VkRGF5LCBkYXlzKSk7XG4gIH1cbiAgYWRkTW9udGhzKG1vbnRocykge1xuICAgIHRoaXMuc2V0TW9udGgodGhpcy5mb2N1c2VkRGF5LmdldE1vbnRoKCkgKyBtb250aHMpO1xuICB9XG4gIGFkZFllYXJzKHllYXJzKSB7XG4gICAgdGhpcy5zZXRZZWFyKHRoaXMuZm9jdXNlZERheS5nZXRGdWxsWWVhcigpICsgeWVhcnMpO1xuICB9XG4gIHN0YXJ0T2ZXZWVrKCkge1xuICAgIHRoaXMuc2V0Rm9jdXNlZERheShzdGFydE9mV2Vlayh0aGlzLmZvY3VzZWREYXksIHRoaXMuZmlyc3REYXlPZldlZWspKTtcbiAgfVxuICBlbmRPZldlZWsoKSB7XG4gICAgdGhpcy5zZXRGb2N1c2VkRGF5KGVuZE9mV2Vlayh0aGlzLmZvY3VzZWREYXksIHRoaXMuZmlyc3REYXlPZldlZWspKTtcbiAgfVxuICBzZXRNb250aChtb250aCkge1xuICAgIGNvbnN0IG1pbiA9IHNldE1vbnRoKHN0YXJ0T2ZNb250aCh0aGlzLmZvY3VzZWREYXkpLCBtb250aCk7XG4gICAgY29uc3QgbWF4ID0gZW5kT2ZNb250aChtaW4pO1xuICAgIGNvbnN0IGRhdGUgPSBzZXRNb250aCh0aGlzLmZvY3VzZWREYXksIG1vbnRoKTtcbiAgICB0aGlzLnNldEZvY3VzZWREYXkoY2xhbXAoZGF0ZSwgbWluLCBtYXgpKTtcbiAgfVxuICBzZXRZZWFyKHllYXIpIHtcbiAgICBjb25zdCBtaW4gPSBzZXRZZWFyKHN0YXJ0T2ZNb250aCh0aGlzLmZvY3VzZWREYXkpLCB5ZWFyKTtcbiAgICBjb25zdCBtYXggPSBlbmRPZk1vbnRoKG1pbik7XG4gICAgY29uc3QgZGF0ZSA9IHNldFllYXIodGhpcy5mb2N1c2VkRGF5LCB5ZWFyKTtcbiAgICB0aGlzLnNldEZvY3VzZWREYXkoY2xhbXAoZGF0ZSwgbWluLCBtYXgpKTtcbiAgfVxuICBzZXRGb2N1c2VkRGF5KGRheSkge1xuICAgIHRoaXMuZm9jdXNlZERheSA9IGNsYW1wKGRheSwgcGFyc2VJU09EYXRlKHRoaXMubWluKSwgcGFyc2VJU09EYXRlKHRoaXMubWF4KSk7XG4gIH1cbiAgc2V0VmFsdWUoZGF0ZSkge1xuICAgIHRoaXMudmFsdWUgPSBwcmludElTT0RhdGUoZGF0ZSk7XG4gICAgdGhpcy5kdWV0Q2hhbmdlLmVtaXQoe1xuICAgICAgY29tcG9uZW50OiBcImR1ZXQtZGF0ZS1waWNrZXJcIixcbiAgICAgIHZhbHVlOiB0aGlzLnZhbHVlLFxuICAgICAgdmFsdWVBc0RhdGU6IGRhdGUsXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIHJlbmRlcigpIGZ1bmN0aW9uXG4gICAqIEFsd2F5cyB0aGUgbGFzdCBvbmUgaW4gdGhlIGNsYXNzLlxuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHZhbHVlQXNEYXRlID0gcGFyc2VJU09EYXRlKHRoaXMudmFsdWUpO1xuICAgIGNvbnN0IGZvcm1hdHRlZERhdGUgPSB2YWx1ZUFzRGF0ZSAmJiB0aGlzLmRhdGVBZGFwdGVyLmZvcm1hdCh2YWx1ZUFzRGF0ZSk7XG4gICAgY29uc3Qgc2VsZWN0ZWRZZWFyID0gKHZhbHVlQXNEYXRlIHx8IHRoaXMuZm9jdXNlZERheSkuZ2V0RnVsbFllYXIoKTtcbiAgICBjb25zdCBmb2N1c2VkTW9udGggPSB0aGlzLmZvY3VzZWREYXkuZ2V0TW9udGgoKTtcbiAgICBjb25zdCBmb2N1c2VkWWVhciA9IHRoaXMuZm9jdXNlZERheS5nZXRGdWxsWWVhcigpO1xuICAgIGNvbnN0IG1pbkRhdGUgPSBwYXJzZUlTT0RhdGUodGhpcy5taW4pO1xuICAgIGNvbnN0IG1heERhdGUgPSBwYXJzZUlTT0RhdGUodGhpcy5tYXgpO1xuICAgIGNvbnN0IHByZXZNb250aERpc2FibGVkID0gbWluRGF0ZSAhPSBudWxsICYmIG1pbkRhdGUuZ2V0TW9udGgoKSA9PT0gZm9jdXNlZE1vbnRoICYmIG1pbkRhdGUuZ2V0RnVsbFllYXIoKSA9PT0gZm9jdXNlZFllYXI7XG4gICAgY29uc3QgbmV4dE1vbnRoRGlzYWJsZWQgPSBtYXhEYXRlICE9IG51bGwgJiYgbWF4RGF0ZS5nZXRNb250aCgpID09PSBmb2N1c2VkTW9udGggJiYgbWF4RGF0ZS5nZXRGdWxsWWVhcigpID09PSBmb2N1c2VkWWVhcjtcbiAgICBjb25zdCBtaW5ZZWFyID0gbWluRGF0ZSA/IG1pbkRhdGUuZ2V0RnVsbFllYXIoKSA6IHNlbGVjdGVkWWVhciAtIDEwO1xuICAgIGNvbnN0IG1heFllYXIgPSBtYXhEYXRlID8gbWF4RGF0ZS5nZXRGdWxsWWVhcigpIDogc2VsZWN0ZWRZZWFyICsgMTA7XG4gICAgcmV0dXJuIChoKEhvc3QsIG51bGwsIGgoXCJkaXZcIiwgeyBjbGFzczogXCJkdWV0LWRhdGVcIiB9LCBoKERhdGVQaWNrZXJJbnB1dCwgeyBkYXRlRm9ybWF0dGVyOiB0aGlzLmRhdGVGb3JtYXRMb25nLCB2YWx1ZTogdGhpcy52YWx1ZSwgdmFsdWVBc0RhdGU6IHZhbHVlQXNEYXRlLCBmb3JtYXR0ZWRWYWx1ZTogZm9ybWF0dGVkRGF0ZSwgb25JbnB1dDogdGhpcy5oYW5kbGVJbnB1dENoYW5nZSwgb25CbHVyOiB0aGlzLmhhbmRsZUJsdXIsIG9uRm9jdXM6IHRoaXMuaGFuZGxlRm9jdXMsIG9uQ2xpY2s6IHRoaXMudG9nZ2xlT3BlbiwgbmFtZTogdGhpcy5uYW1lLCBkaXNhYmxlZDogdGhpcy5kaXNhYmxlZCwgcm9sZTogdGhpcy5yb2xlLCByZXF1aXJlZDogdGhpcy5yZXF1aXJlZCwgaWRlbnRpZmllcjogdGhpcy5pZGVudGlmaWVyLCBsb2NhbGl6YXRpb246IHRoaXMubG9jYWxpemF0aW9uLCBidXR0b25SZWY6IGVsZW1lbnQgPT4gKHRoaXMuZGF0ZVBpY2tlckJ1dHRvbiA9IGVsZW1lbnQpLCBpbnB1dFJlZjogZWxlbWVudCA9PiAodGhpcy5kYXRlUGlja2VySW5wdXQgPSBlbGVtZW50KSB9KSwgaChcImRpdlwiLCB7IGNsYXNzOiB7XG4gICAgICAgIFwiZHVldC1kYXRlX19kaWFsb2dcIjogdHJ1ZSxcbiAgICAgICAgXCJpcy1sZWZ0XCI6IHRoaXMuZGlyZWN0aW9uID09PSBcImxlZnRcIixcbiAgICAgICAgXCJpcy1hY3RpdmVcIjogdGhpcy5vcGVuLFxuICAgICAgfSwgcm9sZTogXCJkaWFsb2dcIiwgXCJhcmlhLW1vZGFsXCI6IFwidHJ1ZVwiLCBcImFyaWEtaGlkZGVuXCI6IHRoaXMub3BlbiA/IFwiZmFsc2VcIiA6IFwidHJ1ZVwiLCBcImFyaWEtbGFiZWxsZWRieVwiOiB0aGlzLmRpYWxvZ0xhYmVsSWQsIG9uVG91Y2hNb3ZlOiB0aGlzLmhhbmRsZVRvdWNoTW92ZSwgb25Ub3VjaFN0YXJ0OiB0aGlzLmhhbmRsZVRvdWNoU3RhcnQsIG9uVG91Y2hFbmQ6IHRoaXMuaGFuZGxlVG91Y2hFbmQgfSwgaChcImRpdlwiLCB7IGNsYXNzOiBcImR1ZXQtZGF0ZV9fZGlhbG9nLWNvbnRlbnRcIiwgb25LZXlEb3duOiB0aGlzLmhhbmRsZUVzY0tleSwgcmVmOiBlbGVtZW50ID0+ICh0aGlzLmRpYWxvZ1dyYXBwZXJOb2RlID0gZWxlbWVudCkgfSwgaChcImRpdlwiLCB7IGNsYXNzOiBcImR1ZXQtZGF0ZV9fbW9iaWxlXCIsIG9uRm9jdXNpbjogdGhpcy5kaXNhYmxlQWN0aXZlRm9jdXMgfSwgaChcImxhYmVsXCIsIHsgY2xhc3M6IFwiZHVldC1kYXRlX19tb2JpbGUtaGVhZGluZ1wiIH0sIHRoaXMubG9jYWxpemF0aW9uLmNhbGVuZGFySGVhZGluZyksIGgoXCJidXR0b25cIiwgeyBjbGFzczogXCJkdWV0LWRhdGVfX2Nsb3NlXCIsIHJlZjogZWxlbWVudCA9PiAodGhpcy5maXJzdEZvY3VzYWJsZUVsZW1lbnQgPSBlbGVtZW50KSwgb25LZXlEb3duOiB0aGlzLmhhbmRsZUZpcnN0Rm9jdXNhYmxlS2V5ZG93biwgb25DbGljazogKCkgPT4gdGhpcy5oaWRlKCksIHR5cGU6IFwiYnV0dG9uXCIgfSwgaChcInN2Z1wiLCB7IFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCIsIGZpbGw6IFwiY3VycmVudENvbG9yXCIsIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHdpZHRoOiBcIjE2XCIsIGhlaWdodDogXCIxNlwiLCB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiIH0sIGgoXCJwYXRoXCIsIHsgZDogXCJNMCAwaDI0djI0SDBWMHpcIiwgZmlsbDogXCJub25lXCIgfSksIGgoXCJwYXRoXCIsIHsgZDogXCJNMTguMyA1LjcxYy0uMzktLjM5LTEuMDItLjM5LTEuNDEgMEwxMiAxMC41OSA3LjExIDUuN2MtLjM5LS4zOS0xLjAyLS4zOS0xLjQxIDAtLjM5LjM5LS4zOSAxLjAyIDAgMS40MUwxMC41OSAxMiA1LjcgMTYuODljLS4zOS4zOS0uMzkgMS4wMiAwIDEuNDEuMzkuMzkgMS4wMi4zOSAxLjQxIDBMMTIgMTMuNDFsNC44OSA0Ljg5Yy4zOS4zOSAxLjAyLjM5IDEuNDEgMCAuMzktLjM5LjM5LTEuMDIgMC0xLjQxTDEzLjQxIDEybDQuODktNC44OWMuMzgtLjM4LjM4LTEuMDIgMC0xLjR6XCIgfSkpLCBoKFwic3BhblwiLCB7IGNsYXNzOiBcImR1ZXQtZGF0ZV9fdmhpZGRlblwiIH0sIHRoaXMubG9jYWxpemF0aW9uLmNsb3NlTGFiZWwpKSksIGgoXCJkaXZcIiwgeyBjbGFzczogXCJkdWV0LWRhdGVfX2hlYWRlclwiLCBvbkZvY3VzaW46IHRoaXMuZGlzYWJsZUFjdGl2ZUZvY3VzIH0sIGgoXCJkaXZcIiwgbnVsbCwgaChcImgyXCIsIHsgaWQ6IHRoaXMuZGlhbG9nTGFiZWxJZCwgY2xhc3M6IFwiZHVldC1kYXRlX192aGlkZGVuXCIsIFwiYXJpYS1saXZlXCI6IFwicG9saXRlXCIsIFwiYXJpYS1hdG9taWNcIjogXCJ0cnVlXCIgfSwgdGhpcy5sb2NhbGl6YXRpb24ubW9udGhOYW1lc1tmb2N1c2VkTW9udGhdLCBcIiBcIiwgdGhpcy5mb2N1c2VkRGF5LmdldEZ1bGxZZWFyKCkpLCBoKFwibGFiZWxcIiwgeyBodG1sRm9yOiB0aGlzLm1vbnRoU2VsZWN0SWQsIGNsYXNzOiBcImR1ZXQtZGF0ZV9fdmhpZGRlblwiIH0sIHRoaXMubG9jYWxpemF0aW9uLm1vbnRoU2VsZWN0TGFiZWwpLCBoKFwiZGl2XCIsIHsgY2xhc3M6IFwiZHVldC1kYXRlX19zZWxlY3RcIiB9LCBoKFwic2VsZWN0XCIsIHsgaWQ6IHRoaXMubW9udGhTZWxlY3RJZCwgY2xhc3M6IFwiZHVldC1kYXRlX19zZWxlY3QtLW1vbnRoXCIsIHJlZjogZWxlbWVudCA9PiAodGhpcy5tb250aFNlbGVjdE5vZGUgPSBlbGVtZW50KSwgb25DaGFuZ2U6IHRoaXMuaGFuZGxlTW9udGhTZWxlY3QgfSwgdGhpcy5sb2NhbGl6YXRpb24ubW9udGhOYW1lcy5tYXAoKG1vbnRoLCBpKSA9PiAoaChcIm9wdGlvblwiLCB7IGtleTogbW9udGgsIHZhbHVlOiBpLCBzZWxlY3RlZDogaSA9PT0gZm9jdXNlZE1vbnRoLCBkaXNhYmxlZDogIWluUmFuZ2UobmV3IERhdGUoZm9jdXNlZFllYXIsIGksIDEpLCBtaW5EYXRlID8gc3RhcnRPZk1vbnRoKG1pbkRhdGUpIDogbnVsbCwgbWF4RGF0ZSA/IGVuZE9mTW9udGgobWF4RGF0ZSkgOiBudWxsKSB9LCBtb250aCkpKSksIGgoXCJkaXZcIiwgeyBjbGFzczogXCJkdWV0LWRhdGVfX3NlbGVjdC1sYWJlbFwiLCBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiIH0sIGgoXCJzcGFuXCIsIG51bGwsIHRoaXMubG9jYWxpemF0aW9uLm1vbnRoTmFtZXNTaG9ydFtmb2N1c2VkTW9udGhdKSwgaChcInN2Z1wiLCB7IGZpbGw6IFwiY3VycmVudENvbG9yXCIsIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHdpZHRoOiBcIjE2XCIsIGhlaWdodDogXCIxNlwiLCB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiIH0sIGgoXCJwYXRoXCIsIHsgZDogXCJNOC4xMiA5LjI5TDEyIDEzLjE3bDMuODgtMy44OGMuMzktLjM5IDEuMDItLjM5IDEuNDEgMCAuMzkuMzkuMzkgMS4wMiAwIDEuNDFsLTQuNTkgNC41OWMtLjM5LjM5LTEuMDIuMzktMS40MSAwTDYuNyAxMC43Yy0uMzktLjM5LS4zOS0xLjAyIDAtMS40MS4zOS0uMzggMS4wMy0uMzkgMS40MiAwelwiIH0pKSkpLCBoKFwibGFiZWxcIiwgeyBodG1sRm9yOiB0aGlzLnllYXJTZWxlY3RJZCwgY2xhc3M6IFwiZHVldC1kYXRlX192aGlkZGVuXCIgfSwgdGhpcy5sb2NhbGl6YXRpb24ueWVhclNlbGVjdExhYmVsKSwgaChcImRpdlwiLCB7IGNsYXNzOiBcImR1ZXQtZGF0ZV9fc2VsZWN0XCIgfSwgaChcInNlbGVjdFwiLCB7IGlkOiB0aGlzLnllYXJTZWxlY3RJZCwgY2xhc3M6IFwiZHVldC1kYXRlX19zZWxlY3QtLXllYXJcIiwgb25DaGFuZ2U6IHRoaXMuaGFuZGxlWWVhclNlbGVjdCB9LCByYW5nZShtaW5ZZWFyLCBtYXhZZWFyKS5tYXAoeWVhciA9PiAoaChcIm9wdGlvblwiLCB7IGtleTogeWVhciwgc2VsZWN0ZWQ6IHllYXIgPT09IGZvY3VzZWRZZWFyIH0sIHllYXIpKSkpLCBoKFwiZGl2XCIsIHsgY2xhc3M6IFwiZHVldC1kYXRlX19zZWxlY3QtbGFiZWxcIiwgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIiB9LCBoKFwic3BhblwiLCBudWxsLCB0aGlzLmZvY3VzZWREYXkuZ2V0RnVsbFllYXIoKSksIGgoXCJzdmdcIiwgeyBmaWxsOiBcImN1cnJlbnRDb2xvclwiLCB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB3aWR0aDogXCIxNlwiLCBoZWlnaHQ6IFwiMTZcIiwgdmlld0JveDogXCIwIDAgMjQgMjRcIiB9LCBoKFwicGF0aFwiLCB7IGQ6IFwiTTguMTIgOS4yOUwxMiAxMy4xN2wzLjg4LTMuODhjLjM5LS4zOSAxLjAyLS4zOSAxLjQxIDAgLjM5LjM5LjM5IDEuMDIgMCAxLjQxbC00LjU5IDQuNTljLS4zOS4zOS0xLjAyLjM5LTEuNDEgMEw2LjcgMTAuN2MtLjM5LS4zOS0uMzktMS4wMiAwLTEuNDEuMzktLjM4IDEuMDMtLjM5IDEuNDIgMHpcIiB9KSkpKSksIGgoXCJkaXZcIiwgeyBjbGFzczogXCJkdWV0LWRhdGVfX25hdlwiIH0sIGgoXCJidXR0b25cIiwgeyBjbGFzczogXCJkdWV0LWRhdGVfX3ByZXZcIiwgb25DbGljazogdGhpcy5oYW5kbGVQcmV2aW91c01vbnRoQ2xpY2ssIGRpc2FibGVkOiBwcmV2TW9udGhEaXNhYmxlZCwgdHlwZTogXCJidXR0b25cIiB9LCBoKFwic3ZnXCIsIHsgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIiwgZmlsbDogXCJjdXJyZW50Q29sb3JcIiwgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgd2lkdGg6IFwiMjFcIiwgaGVpZ2h0OiBcIjIxXCIsIHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIgfSwgaChcInBhdGhcIiwgeyBkOiBcIk0xNC43MSAxNS44OEwxMC44MyAxMmwzLjg4LTMuODhjLjM5LS4zOS4zOS0xLjAyIDAtMS40MS0uMzktLjM5LTEuMDItLjM5LTEuNDEgMEw4LjcxIDExLjNjLS4zOS4zOS0uMzkgMS4wMiAwIDEuNDFsNC41OSA0LjU5Yy4zOS4zOSAxLjAyLjM5IDEuNDEgMCAuMzgtLjM5LjM5LTEuMDMgMC0xLjQyelwiIH0pKSwgaChcInNwYW5cIiwgeyBjbGFzczogXCJkdWV0LWRhdGVfX3ZoaWRkZW5cIiB9LCB0aGlzLmxvY2FsaXphdGlvbi5wcmV2TW9udGhMYWJlbCkpLCBoKFwiYnV0dG9uXCIsIHsgY2xhc3M6IFwiZHVldC1kYXRlX19uZXh0XCIsIG9uQ2xpY2s6IHRoaXMuaGFuZGxlTmV4dE1vbnRoQ2xpY2ssIGRpc2FibGVkOiBuZXh0TW9udGhEaXNhYmxlZCwgdHlwZTogXCJidXR0b25cIiB9LCBoKFwic3ZnXCIsIHsgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIiwgZmlsbDogXCJjdXJyZW50Q29sb3JcIiwgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgd2lkdGg6IFwiMjFcIiwgaGVpZ2h0OiBcIjIxXCIsIHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIgfSwgaChcInBhdGhcIiwgeyBkOiBcIk05LjI5IDE1Ljg4TDEzLjE3IDEyIDkuMjkgOC4xMmMtLjM5LS4zOS0uMzktMS4wMiAwLTEuNDEuMzktLjM5IDEuMDItLjM5IDEuNDEgMGw0LjU5IDQuNTljLjM5LjM5LjM5IDEuMDIgMCAxLjQxTDEwLjcgMTcuM2MtLjM5LjM5LTEuMDIuMzktMS40MSAwLS4zOC0uMzktLjM5LTEuMDMgMC0xLjQyelwiIH0pKSwgaChcInNwYW5cIiwgeyBjbGFzczogXCJkdWV0LWRhdGVfX3ZoaWRkZW5cIiB9LCB0aGlzLmxvY2FsaXphdGlvbi5uZXh0TW9udGhMYWJlbCkpKSksIGgoRGF0ZVBpY2tlck1vbnRoLCB7IGRhdGVGb3JtYXR0ZXI6IHRoaXMuZGF0ZUZvcm1hdFNob3J0LCBzZWxlY3RlZERhdGU6IHZhbHVlQXNEYXRlLCBmb2N1c2VkRGF0ZTogdGhpcy5mb2N1c2VkRGF5LCBvbkRhdGVTZWxlY3Q6IHRoaXMuaGFuZGxlRGF5U2VsZWN0LCBvbktleWJvYXJkTmF2aWdhdGlvbjogdGhpcy5oYW5kbGVLZXlib2FyZE5hdmlnYXRpb24sIGxhYmVsbGVkQnlJZDogdGhpcy5kaWFsb2dMYWJlbElkLCBsb2NhbGl6YXRpb246IHRoaXMubG9jYWxpemF0aW9uLCBmaXJzdERheU9mV2VlazogdGhpcy5maXJzdERheU9mV2VlaywgZm9jdXNlZERheVJlZjogdGhpcy5wcm9jZXNzRm9jdXNlZERheU5vZGUsIG1pbjogbWluRGF0ZSwgbWF4OiBtYXhEYXRlLCBpc0RhdGVEaXNhYmxlZDogdGhpcy5pc0RhdGVEaXNhYmxlZCB9KSkpKSkpO1xuICB9XG4gIGdldCBlbGVtZW50KCkgeyByZXR1cm4gdGhpczsgfVxuICBzdGF0aWMgZ2V0IHdhdGNoZXJzKCkgeyByZXR1cm4ge1xuICAgIFwibG9jYWxpemF0aW9uXCI6IFtcImNyZWF0ZURhdGVGb3JtYXR0ZXJzXCJdXG4gIH07IH1cbiAgc3RhdGljIGdldCBzdHlsZSgpIHsgcmV0dXJuIGR1ZXREYXRlUGlja2VyQ3NzOyB9XG59O1xuXG5jb25zdCBEdWV0RGF0ZVBpY2tlciQxID0gLypAX19QVVJFX18qL3Byb3h5Q3VzdG9tRWxlbWVudChEdWV0RGF0ZVBpY2tlciwgWzAsXCJkdWV0LWRhdGUtcGlja2VyXCIse1wibmFtZVwiOlsxXSxcImlkZW50aWZpZXJcIjpbMV0sXCJkaXNhYmxlZFwiOls1MTZdLFwicm9sZVwiOlsxXSxcImRpcmVjdGlvblwiOlsxXSxcInJlcXVpcmVkXCI6WzRdLFwidmFsdWVcIjpbMTUzN10sXCJtaW5cIjpbMV0sXCJtYXhcIjpbMV0sXCJmaXJzdERheU9mV2Vla1wiOlsyLFwiZmlyc3QtZGF5LW9mLXdlZWtcIl0sXCJsb2NhbGl6YXRpb25cIjpbMTZdLFwiZGF0ZUFkYXB0ZXJcIjpbMTZdLFwiaXNEYXRlRGlzYWJsZWRcIjpbMTZdLFwiYWN0aXZlRm9jdXNcIjpbMzJdLFwiZm9jdXNlZERheVwiOlszMl0sXCJvcGVuXCI6WzMyXX0sW1s2LFwiY2xpY2tcIixcImhhbmRsZURvY3VtZW50Q2xpY2tcIl1dXSk7XG5jb25zdCBkZWZpbmVDdXN0b21FbGVtZW50cyA9IChvcHRzKSA9PiB7XG4gIGlmICh0eXBlb2YgY3VzdG9tRWxlbWVudHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgW1xuICAgICAgRHVldERhdGVQaWNrZXIkMVxuICAgIF0uZm9yRWFjaChjbXAgPT4ge1xuICAgICAgaWYgKCFjdXN0b21FbGVtZW50cy5nZXQoY21wLmlzKSkge1xuICAgICAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUoY21wLmlzLCBjbXAsIG9wdHMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG5leHBvcnQgeyBEdWV0RGF0ZVBpY2tlciQxIGFzIER1ZXREYXRlUGlja2VyLCBkZWZpbmVDdXN0b21FbGVtZW50cyB9O1xuIiwibGV0IHNjb3BlSWQ7XG5sZXQgY29udGVudFJlZjtcbmxldCBob3N0VGFnTmFtZTtcbmxldCBjdXN0b21FcnJvcjtcbmxldCBpID0gMDtcbmxldCB1c2VOYXRpdmVTaGFkb3dEb20gPSBmYWxzZTtcbmxldCBjaGVja1Nsb3RGYWxsYmFja1Zpc2liaWxpdHkgPSBmYWxzZTtcbmxldCBjaGVja1Nsb3RSZWxvY2F0ZSA9IGZhbHNlO1xubGV0IGlzU3ZnTW9kZSA9IGZhbHNlO1xubGV0IHJlbmRlcmluZ1JlZiA9IG51bGw7XG5sZXQgcXVldWVDb25nZXN0aW9uID0gMDtcbmxldCBxdWV1ZVBlbmRpbmcgPSBmYWxzZTtcbi8qXG4gU3RlbmNpbCBDbGllbnQgUGxhdGZvcm0gdjIuNi4wIHwgTUlUIExpY2Vuc2VkIHwgaHR0cHM6Ly9zdGVuY2lsanMuY29tXG4gKi9cbmltcG9ydCB7IEJVSUxELCBOQU1FU1BBQ0UgfSBmcm9tICdAc3RlbmNpbC9jb3JlL2ludGVybmFsL2FwcC1kYXRhJztcbmNvbnN0IHdpbiA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDoge307XG5jb25zdCBDU1MgPSBCVUlMRC5jc3NWYXJTaGltID8gd2luLkNTUyA6IG51bGw7XG5jb25zdCBkb2MgPSB3aW4uZG9jdW1lbnQgfHwgeyBoZWFkOiB7fSB9O1xuY29uc3QgSCA9ICh3aW4uSFRNTEVsZW1lbnQgfHwgY2xhc3Mge1xufSk7XG5jb25zdCBwbHQgPSB7XG4gICAgJGZsYWdzJDogMCxcbiAgICAkcmVzb3VyY2VzVXJsJDogJycsXG4gICAgam1wOiBoID0+IGgoKSxcbiAgICByYWY6IGggPT4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGgpLFxuICAgIGFlbDogKGVsLCBldmVudE5hbWUsIGxpc3RlbmVyLCBvcHRzKSA9PiBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIG9wdHMpLFxuICAgIHJlbDogKGVsLCBldmVudE5hbWUsIGxpc3RlbmVyLCBvcHRzKSA9PiBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIG9wdHMpLFxuICAgIGNlOiAoZXZlbnROYW1lLCBvcHRzKSA9PiBuZXcgQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCBvcHRzKSxcbn07XG5jb25zdCBzZXRQbGF0Zm9ybUhlbHBlcnMgPSAoaGVscGVycykgPT4ge1xuICAgIE9iamVjdC5hc3NpZ24ocGx0LCBoZWxwZXJzKTtcbn07XG5jb25zdCBzdXBwb3J0c1NoYWRvdyA9IEJVSUxELnNoYWRvd0RvbVNoaW0gJiYgQlVJTEQuc2hhZG93RG9tID8gLypAX19QVVJFX18qLyAoKCkgPT4gKGRvYy5oZWFkLmF0dGFjaFNoYWRvdyArICcnKS5pbmRleE9mKCdbbmF0aXZlJykgPiAtMSkoKSA6IHRydWU7XG5jb25zdCBzdXBwb3J0c0xpc3RlbmVyT3B0aW9ucyA9IC8qQF9fUFVSRV9fKi8gKCgpID0+IHtcbiAgICBsZXQgc3VwcG9ydHNMaXN0ZW5lck9wdGlvbnMgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignZScsIG51bGwsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgc3VwcG9ydHNMaXN0ZW5lck9wdGlvbnMgPSB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkgeyB9XG4gICAgcmV0dXJuIHN1cHBvcnRzTGlzdGVuZXJPcHRpb25zO1xufSkoKTtcbmNvbnN0IHByb21pc2VSZXNvbHZlID0gKHYpID0+IFByb21pc2UucmVzb2x2ZSh2KTtcbmNvbnN0IHN1cHBvcnRzQ29uc3RydWN0aWJsZVN0eWxlc2hlZXRzID0gQlVJTEQuY29uc3RydWN0YWJsZUNTU1xuICAgID8gLypAX19QVVJFX18qLyAoKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbmV3IENTU1N0eWxlU2hlZXQoKTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgKG5ldyBDU1NTdHlsZVNoZWV0KCkpLnJlcGxhY2UgPT09ICdmdW5jdGlvbic7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSkoKVxuICAgIDogZmFsc2U7XG5jb25zdCBDb250ZXh0ID0ge307XG5jb25zdCBhZGRIb3N0RXZlbnRMaXN0ZW5lcnMgPSAoZWxtLCBob3N0UmVmLCBsaXN0ZW5lcnMsIGF0dGFjaFBhcmVudExpc3RlbmVycykgPT4ge1xuICAgIGlmIChCVUlMRC5ob3N0TGlzdGVuZXIgJiYgbGlzdGVuZXJzKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgY2FsbGVkIGltbWVkaWF0ZWx5IHdpdGhpbiB0aGUgZWxlbWVudCdzIGNvbnN0cnVjdG9yXG4gICAgICAgIC8vIGluaXRpYWxpemUgb3VyIGV2ZW50IGxpc3RlbmVycyBvbiB0aGUgaG9zdCBlbGVtZW50XG4gICAgICAgIC8vIHdlIGRvIHRoaXMgbm93IHNvIHRoYXQgd2UgY2FuIGxpc3RlbiB0byBldmVudHMgdGhhdCBtYXlcbiAgICAgICAgLy8gaGF2ZSBmaXJlZCBldmVuIGJlZm9yZSB0aGUgaW5zdGFuY2UgaXMgcmVhZHlcbiAgICAgICAgaWYgKEJVSUxELmhvc3RMaXN0ZW5lclRhcmdldFBhcmVudCkge1xuICAgICAgICAgICAgLy8gdGhpcyBjb21wb25lbnQgbWF5IGhhdmUgZXZlbnQgbGlzdGVuZXJzIHRoYXQgc2hvdWxkIGJlIGF0dGFjaGVkIHRvIHRoZSBwYXJlbnRcbiAgICAgICAgICAgIGlmIChhdHRhY2hQYXJlbnRMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGJlaW5nIHJhbiBmcm9tIHdpdGhpbiB0aGUgY29ubmVjdGVkQ2FsbGJhY2tcbiAgICAgICAgICAgICAgICAvLyB3aGljaCBpcyBpbXBvcnRhbnQgc28gdGhhdCB3ZSBrbm93IHRoZSBob3N0IGVsZW1lbnQgYWN0dWFsbHkgaGFzIGEgcGFyZW50IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAvLyBmaWx0ZXIgb3V0IHRoZSBsaXN0ZW5lcnMgdG8gb25seSBoYXZlIHRoZSBvbmVzIHRoYXQgQVJFIGJlaW5nIGF0dGFjaGVkIHRvIHRoZSBwYXJlbnRcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuZmlsdGVyKChbZmxhZ3NdKSA9PiBmbGFncyAmIDMyIC8qIFRhcmdldFBhcmVudCAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGJlaW5nIHJhbiBmcm9tIHdpdGhpbiB0aGUgY29tcG9uZW50IGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgLy8gZXZlcnl0aGluZyBCVVQgdGhlIHBhcmVudCBlbGVtZW50IGxpc3RlbmVycyBzaG91bGQgYmUgYXR0YWNoZWQgYXQgdGhpcyB0aW1lXG4gICAgICAgICAgICAgICAgLy8gZmlsdGVyIG91dCB0aGUgbGlzdGVuZXJzIHRoYXQgYXJlIE5PVCBiZWluZyBhdHRhY2hlZCB0byB0aGUgcGFyZW50XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLmZpbHRlcigoW2ZsYWdzXSkgPT4gIShmbGFncyAmIDMyIC8qIFRhcmdldFBhcmVudCAqLykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxpc3RlbmVycy5tYXAoKFtmbGFncywgbmFtZSwgbWV0aG9kXSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gQlVJTEQuaG9zdExpc3RlbmVyVGFyZ2V0ID8gZ2V0SG9zdExpc3RlbmVyVGFyZ2V0KGVsbSwgZmxhZ3MpIDogZWxtO1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IGhvc3RMaXN0ZW5lclByb3h5KGhvc3RSZWYsIG1ldGhvZCk7XG4gICAgICAgICAgICBjb25zdCBvcHRzID0gaG9zdExpc3RlbmVyT3B0cyhmbGFncyk7XG4gICAgICAgICAgICBwbHQuYWVsKHRhcmdldCwgbmFtZSwgaGFuZGxlciwgb3B0cyk7XG4gICAgICAgICAgICAoaG9zdFJlZi4kcm1MaXN0ZW5lcnMkID0gaG9zdFJlZi4kcm1MaXN0ZW5lcnMkIHx8IFtdKS5wdXNoKCgpID0+IHBsdC5yZWwodGFyZ2V0LCBuYW1lLCBoYW5kbGVyLCBvcHRzKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5jb25zdCBob3N0TGlzdGVuZXJQcm94eSA9IChob3N0UmVmLCBtZXRob2ROYW1lKSA9PiAoZXYpID0+IHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoQlVJTEQubGF6eUxvYWQpIHtcbiAgICAgICAgICAgIGlmIChob3N0UmVmLiRmbGFncyQgJiAyNTYgLyogaXNMaXN0ZW5SZWFkeSAqLykge1xuICAgICAgICAgICAgICAgIC8vIGluc3RhbmNlIGlzIHJlYWR5LCBsZXQncyBjYWxsIGl0J3MgbWVtYmVyIG1ldGhvZCBmb3IgdGhpcyBldmVudFxuICAgICAgICAgICAgICAgIGhvc3RSZWYuJGxhenlJbnN0YW5jZSRbbWV0aG9kTmFtZV0oZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgKGhvc3RSZWYuJHF1ZXVlZExpc3RlbmVycyQgPSBob3N0UmVmLiRxdWV1ZWRMaXN0ZW5lcnMkIHx8IFtdKS5wdXNoKFttZXRob2ROYW1lLCBldl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaG9zdFJlZi4kaG9zdEVsZW1lbnQkW21ldGhvZE5hbWVdKGV2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlRXJyb3IoZSk7XG4gICAgfVxufTtcbmNvbnN0IGdldEhvc3RMaXN0ZW5lclRhcmdldCA9IChlbG0sIGZsYWdzKSA9PiB7XG4gICAgaWYgKEJVSUxELmhvc3RMaXN0ZW5lclRhcmdldERvY3VtZW50ICYmIGZsYWdzICYgNCAvKiBUYXJnZXREb2N1bWVudCAqLylcbiAgICAgICAgcmV0dXJuIGRvYztcbiAgICBpZiAoQlVJTEQuaG9zdExpc3RlbmVyVGFyZ2V0V2luZG93ICYmIGZsYWdzICYgOCAvKiBUYXJnZXRXaW5kb3cgKi8pXG4gICAgICAgIHJldHVybiB3aW47XG4gICAgaWYgKEJVSUxELmhvc3RMaXN0ZW5lclRhcmdldEJvZHkgJiYgZmxhZ3MgJiAxNiAvKiBUYXJnZXRCb2R5ICovKVxuICAgICAgICByZXR1cm4gZG9jLmJvZHk7XG4gICAgaWYgKEJVSUxELmhvc3RMaXN0ZW5lclRhcmdldFBhcmVudCAmJiBmbGFncyAmIDMyIC8qIFRhcmdldFBhcmVudCAqLylcbiAgICAgICAgcmV0dXJuIGVsbS5wYXJlbnRFbGVtZW50O1xuICAgIHJldHVybiBlbG07XG59O1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBob3N0TGlzdGVuZXJPcHRzID0gKGZsYWdzKSA9PiBzdXBwb3J0c0xpc3RlbmVyT3B0aW9uc1xuICAgID8gKHtcbiAgICAgICAgcGFzc2l2ZTogKGZsYWdzICYgMSAvKiBQYXNzaXZlICovKSAhPT0gMCxcbiAgICAgICAgY2FwdHVyZTogKGZsYWdzICYgMiAvKiBDYXB0dXJlICovKSAhPT0gMCxcbiAgICB9KVxuICAgIDogKGZsYWdzICYgMiAvKiBDYXB0dXJlICovKSAhPT0gMDtcbmNvbnN0IENPTlRFTlRfUkVGX0lEID0gJ3InO1xuY29uc3QgT1JHX0xPQ0FUSU9OX0lEID0gJ28nO1xuY29uc3QgU0xPVF9OT0RFX0lEID0gJ3MnO1xuY29uc3QgVEVYVF9OT0RFX0lEID0gJ3QnO1xuY29uc3QgSFlEUkFURV9JRCA9ICdzLWlkJztcbmNvbnN0IEhZRFJBVEVEX1NUWUxFX0lEID0gJ3N0eS1pZCc7XG5jb25zdCBIWURSQVRFX0NISUxEX0lEID0gJ2MtaWQnO1xuY29uc3QgSFlEUkFURURfQ1NTID0gJ3t2aXNpYmlsaXR5OmhpZGRlbn0uaHlkcmF0ZWR7dmlzaWJpbGl0eTppbmhlcml0fSc7XG5jb25zdCBYTElOS19OUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcbmNvbnN0IGNyZWF0ZVRpbWUgPSAoZm5OYW1lLCB0YWdOYW1lID0gJycpID0+IHtcbiAgICBpZiAoQlVJTEQucHJvZmlsZSAmJiBwZXJmb3JtYW5jZS5tYXJrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGBzdDoke2ZuTmFtZX06JHt0YWdOYW1lfToke2krK31gO1xuICAgICAgICAvLyBTdGFydFxuICAgICAgICBwZXJmb3JtYW5jZS5tYXJrKGtleSk7XG4gICAgICAgIC8vIEVuZFxuICAgICAgICByZXR1cm4gKCkgPT4gcGVyZm9ybWFuY2UubWVhc3VyZShgW1N0ZW5jaWxdICR7Zm5OYW1lfSgpIDwke3RhZ05hbWV9PmAsIGtleSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9O1xuICAgIH1cbn07XG5jb25zdCB1bmlxdWVUaW1lID0gKGtleSwgbWVhc3VyZVRleHQpID0+IHtcbiAgICBpZiAoQlVJTEQucHJvZmlsZSAmJiBwZXJmb3JtYW5jZS5tYXJrKSB7XG4gICAgICAgIGlmIChwZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlOYW1lKGtleSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBwZXJmb3JtYW5jZS5tYXJrKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGlmIChwZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlOYW1lKG1lYXN1cmVUZXh0KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBwZXJmb3JtYW5jZS5tZWFzdXJlKG1lYXN1cmVUZXh0LCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICB9XG59O1xuY29uc3QgaW5zcGVjdCA9IChyZWYpID0+IHtcbiAgICBjb25zdCBob3N0UmVmID0gZ2V0SG9zdFJlZihyZWYpO1xuICAgIGlmICghaG9zdFJlZikge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBmbGFncyA9IGhvc3RSZWYuJGZsYWdzJDtcbiAgICBjb25zdCBob3N0RWxlbWVudCA9IGhvc3RSZWYuJGhvc3RFbGVtZW50JDtcbiAgICByZXR1cm4ge1xuICAgICAgICByZW5kZXJDb3VudDogaG9zdFJlZi4kcmVuZGVyQ291bnQkLFxuICAgICAgICBmbGFnczoge1xuICAgICAgICAgICAgaGFzUmVuZGVyZWQ6ICEhKGZsYWdzICYgMiAvKiBoYXNSZW5kZXJlZCAqLyksXG4gICAgICAgICAgICBoYXNDb25uZWN0ZWQ6ICEhKGZsYWdzICYgMSAvKiBoYXNDb25uZWN0ZWQgKi8pLFxuICAgICAgICAgICAgaXNXYWl0aW5nRm9yQ2hpbGRyZW46ICEhKGZsYWdzICYgNCAvKiBpc1dhaXRpbmdGb3JDaGlsZHJlbiAqLyksXG4gICAgICAgICAgICBpc0NvbnN0cnVjdGluZ0luc3RhbmNlOiAhIShmbGFncyAmIDggLyogaXNDb25zdHJ1Y3RpbmdJbnN0YW5jZSAqLyksXG4gICAgICAgICAgICBpc1F1ZXVlZEZvclVwZGF0ZTogISEoZmxhZ3MgJiAxNiAvKiBpc1F1ZXVlZEZvclVwZGF0ZSAqLyksXG4gICAgICAgICAgICBoYXNJbml0aWFsaXplZENvbXBvbmVudDogISEoZmxhZ3MgJiAzMiAvKiBoYXNJbml0aWFsaXplZENvbXBvbmVudCAqLyksXG4gICAgICAgICAgICBoYXNMb2FkZWRDb21wb25lbnQ6ICEhKGZsYWdzICYgNjQgLyogaGFzTG9hZGVkQ29tcG9uZW50ICovKSxcbiAgICAgICAgICAgIGlzV2F0Y2hSZWFkeTogISEoZmxhZ3MgJiAxMjggLyogaXNXYXRjaFJlYWR5ICovKSxcbiAgICAgICAgICAgIGlzTGlzdGVuUmVhZHk6ICEhKGZsYWdzICYgMjU2IC8qIGlzTGlzdGVuUmVhZHkgKi8pLFxuICAgICAgICAgICAgbmVlZHNSZXJlbmRlcjogISEoZmxhZ3MgJiA1MTIgLyogbmVlZHNSZXJlbmRlciAqLyksXG4gICAgICAgIH0sXG4gICAgICAgIGluc3RhbmNlVmFsdWVzOiBob3N0UmVmLiRpbnN0YW5jZVZhbHVlcyQsXG4gICAgICAgIGFuY2VzdG9yQ29tcG9uZW50OiBob3N0UmVmLiRhbmNlc3RvckNvbXBvbmVudCQsXG4gICAgICAgIGhvc3RFbGVtZW50LFxuICAgICAgICBsYXp5SW5zdGFuY2U6IGhvc3RSZWYuJGxhenlJbnN0YW5jZSQsXG4gICAgICAgIHZub2RlOiBob3N0UmVmLiR2bm9kZSQsXG4gICAgICAgIG1vZGVOYW1lOiBob3N0UmVmLiRtb2RlTmFtZSQsXG4gICAgICAgIG9uUmVhZHlQcm9taXNlOiBob3N0UmVmLiRvblJlYWR5UHJvbWlzZSQsXG4gICAgICAgIG9uUmVhZHlSZXNvbHZlOiBob3N0UmVmLiRvblJlYWR5UmVzb2x2ZSQsXG4gICAgICAgIG9uSW5zdGFuY2VQcm9taXNlOiBob3N0UmVmLiRvbkluc3RhbmNlUHJvbWlzZSQsXG4gICAgICAgIG9uSW5zdGFuY2VSZXNvbHZlOiBob3N0UmVmLiRvbkluc3RhbmNlUmVzb2x2ZSQsXG4gICAgICAgIG9uUmVuZGVyUmVzb2x2ZTogaG9zdFJlZi4kb25SZW5kZXJSZXNvbHZlJCxcbiAgICAgICAgcXVldWVkTGlzdGVuZXJzOiBob3N0UmVmLiRxdWV1ZWRMaXN0ZW5lcnMkLFxuICAgICAgICBybUxpc3RlbmVyczogaG9zdFJlZi4kcm1MaXN0ZW5lcnMkLFxuICAgICAgICBbJ3MtaWQnXTogaG9zdEVsZW1lbnRbJ3MtaWQnXSxcbiAgICAgICAgWydzLWNyJ106IGhvc3RFbGVtZW50WydzLWNyJ10sXG4gICAgICAgIFsncy1sciddOiBob3N0RWxlbWVudFsncy1sciddLFxuICAgICAgICBbJ3MtcCddOiBob3N0RWxlbWVudFsncy1wJ10sXG4gICAgICAgIFsncy1yYyddOiBob3N0RWxlbWVudFsncy1yYyddLFxuICAgICAgICBbJ3Mtc2MnXTogaG9zdEVsZW1lbnRbJ3Mtc2MnXSxcbiAgICB9O1xufTtcbmNvbnN0IGluc3RhbGxEZXZUb29scyA9ICgpID0+IHtcbiAgICBpZiAoQlVJTEQuZGV2VG9vbHMpIHtcbiAgICAgICAgY29uc3Qgc3RlbmNpbCA9ICh3aW4uc3RlbmNpbCA9IHdpbi5zdGVuY2lsIHx8IHt9KTtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxJbnNwZWN0ID0gc3RlbmNpbC5pbnNwZWN0O1xuICAgICAgICBzdGVuY2lsLmluc3BlY3QgPSAocmVmKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gaW5zcGVjdChyZWYpO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQgJiYgdHlwZW9mIG9yaWdpbmFsSW5zcGVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG9yaWdpbmFsSW5zcGVjdChyZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICB9XG59O1xuY29uc3Qgcm9vdEFwcGxpZWRTdHlsZXMgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgcmVnaXN0ZXJTdHlsZSA9IChzY29wZUlkLCBjc3NUZXh0LCBhbGxvd0NTKSA9PiB7XG4gICAgbGV0IHN0eWxlID0gc3R5bGVzLmdldChzY29wZUlkKTtcbiAgICBpZiAoc3VwcG9ydHNDb25zdHJ1Y3RpYmxlU3R5bGVzaGVldHMgJiYgYWxsb3dDUykge1xuICAgICAgICBzdHlsZSA9IChzdHlsZSB8fCBuZXcgQ1NTU3R5bGVTaGVldCgpKTtcbiAgICAgICAgc3R5bGUucmVwbGFjZShjc3NUZXh0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0eWxlID0gY3NzVGV4dDtcbiAgICB9XG4gICAgc3R5bGVzLnNldChzY29wZUlkLCBzdHlsZSk7XG59O1xuY29uc3QgYWRkU3R5bGUgPSAoc3R5bGVDb250YWluZXJOb2RlLCBjbXBNZXRhLCBtb2RlLCBob3N0RWxtKSA9PiB7XG4gICAgbGV0IHNjb3BlSWQgPSBnZXRTY29wZUlkKGNtcE1ldGEsIG1vZGUpO1xuICAgIGxldCBzdHlsZSA9IHN0eWxlcy5nZXQoc2NvcGVJZCk7XG4gICAgaWYgKCFCVUlMRC5hdHRhY2hTdHlsZXMpIHtcbiAgICAgICAgcmV0dXJuIHNjb3BlSWQ7XG4gICAgfVxuICAgIC8vIGlmIGFuIGVsZW1lbnQgaXMgTk9UIGNvbm5lY3RlZCB0aGVuIGdldFJvb3ROb2RlKCkgd2lsbCByZXR1cm4gdGhlIHdyb25nIHJvb3Qgbm9kZVxuICAgIC8vIHNvIHRoZSBmYWxsYmFjayBpcyB0byBhbHdheXMgdXNlIHRoZSBkb2N1bWVudCBmb3IgdGhlIHJvb3Qgbm9kZSBpbiB0aG9zZSBjYXNlc1xuICAgIHN0eWxlQ29udGFpbmVyTm9kZSA9IHN0eWxlQ29udGFpbmVyTm9kZS5ub2RlVHlwZSA9PT0gMTEgLyogRG9jdW1lbnRGcmFnbWVudCAqLyA/IHN0eWxlQ29udGFpbmVyTm9kZSA6IGRvYztcbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHN0eWxlQ29udGFpbmVyTm9kZSA9IHN0eWxlQ29udGFpbmVyTm9kZS5oZWFkIHx8IHN0eWxlQ29udGFpbmVyTm9kZTtcbiAgICAgICAgICAgIGxldCBhcHBsaWVkU3R5bGVzID0gcm9vdEFwcGxpZWRTdHlsZXMuZ2V0KHN0eWxlQ29udGFpbmVyTm9kZSk7XG4gICAgICAgICAgICBsZXQgc3R5bGVFbG07XG4gICAgICAgICAgICBpZiAoIWFwcGxpZWRTdHlsZXMpIHtcbiAgICAgICAgICAgICAgICByb290QXBwbGllZFN0eWxlcy5zZXQoc3R5bGVDb250YWluZXJOb2RlLCAoYXBwbGllZFN0eWxlcyA9IG5ldyBTZXQoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhcHBsaWVkU3R5bGVzLmhhcyhzY29wZUlkKSkge1xuICAgICAgICAgICAgICAgIGlmIChCVUlMRC5oeWRyYXRlQ2xpZW50U2lkZSAmJiBzdHlsZUNvbnRhaW5lck5vZGUuaG9zdCAmJiAoc3R5bGVFbG0gPSBzdHlsZUNvbnRhaW5lck5vZGUucXVlcnlTZWxlY3RvcihgWyR7SFlEUkFURURfU1RZTEVfSUR9PVwiJHtzY29wZUlkfVwiXWApKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIG9ubHkgaGFwcGVuaW5nIG9uIG5hdGl2ZSBzaGFkb3ctZG9tLCBkbyBub3QgbmVlZHMgQ1NTIHZhciBzaGltXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlRWxtLmlubmVySFRNTCA9IHN0eWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEJVSUxELmNzc1ZhclNoaW0gJiYgcGx0LiRjc3NTaGltJCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVFbG0gPSBwbHQuJGNzc1NoaW0kLmNyZWF0ZUhvc3RTdHlsZShob3N0RWxtLCBzY29wZUlkLCBzdHlsZSwgISEoY21wTWV0YS4kZmxhZ3MkICYgMTAgLyogbmVlZHNTY29wZWRFbmNhcHN1bGF0aW9uICovKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdTY29wZUlkID0gc3R5bGVFbG1bJ3Mtc2MnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdTY29wZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGVJZCA9IG5ld1Njb3BlSWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0byBhZGQgdGhpcyBzdHlsZUlEIHRvIHRoZSBhcHBsaWVkU3R5bGVzIFNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBjc3NWYXJTaGltIG1pZ2h0IG5lZWQgdG8gYXBwbHkgc2V2ZXJhbCBkaWZmZXJlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdHlsZXNoZWV0cyBmb3IgdGhlIHNhbWUgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbGllZFN0eWxlcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZUVsbSA9IGRvYy5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVFbG0uaW5uZXJIVE1MID0gc3R5bGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKEJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlIHx8IEJVSUxELmhvdE1vZHVsZVJlcGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZUVsbS5zZXRBdHRyaWJ1dGUoSFlEUkFURURfU1RZTEVfSUQsIHNjb3BlSWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlQ29udGFpbmVyTm9kZS5pbnNlcnRCZWZvcmUoc3R5bGVFbG0sIHN0eWxlQ29udGFpbmVyTm9kZS5xdWVyeVNlbGVjdG9yKCdsaW5rJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXBwbGllZFN0eWxlcykge1xuICAgICAgICAgICAgICAgICAgICBhcHBsaWVkU3R5bGVzLmFkZChzY29wZUlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQlVJTEQuY29uc3RydWN0YWJsZUNTUyAmJiAhc3R5bGVDb250YWluZXJOb2RlLmFkb3B0ZWRTdHlsZVNoZWV0cy5pbmNsdWRlcyhzdHlsZSkpIHtcbiAgICAgICAgICAgIHN0eWxlQ29udGFpbmVyTm9kZS5hZG9wdGVkU3R5bGVTaGVldHMgPSBbLi4uc3R5bGVDb250YWluZXJOb2RlLmFkb3B0ZWRTdHlsZVNoZWV0cywgc3R5bGVdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzY29wZUlkO1xufTtcbmNvbnN0IGF0dGFjaFN0eWxlcyA9IChob3N0UmVmKSA9PiB7XG4gICAgY29uc3QgY21wTWV0YSA9IGhvc3RSZWYuJGNtcE1ldGEkO1xuICAgIGNvbnN0IGVsbSA9IGhvc3RSZWYuJGhvc3RFbGVtZW50JDtcbiAgICBjb25zdCBmbGFncyA9IGNtcE1ldGEuJGZsYWdzJDtcbiAgICBjb25zdCBlbmRBdHRhY2hTdHlsZXMgPSBjcmVhdGVUaW1lKCdhdHRhY2hTdHlsZXMnLCBjbXBNZXRhLiR0YWdOYW1lJCk7XG4gICAgY29uc3Qgc2NvcGVJZCA9IGFkZFN0eWxlKEJVSUxELnNoYWRvd0RvbSAmJiBzdXBwb3J0c1NoYWRvdyAmJiBlbG0uc2hhZG93Um9vdCA/IGVsbS5zaGFkb3dSb290IDogZWxtLmdldFJvb3ROb2RlKCksIGNtcE1ldGEsIGhvc3RSZWYuJG1vZGVOYW1lJCwgZWxtKTtcbiAgICBpZiAoKEJVSUxELnNoYWRvd0RvbSB8fCBCVUlMRC5zY29wZWQpICYmIEJVSUxELmNzc0Fubm90YXRpb25zICYmIGZsYWdzICYgMTAgLyogbmVlZHNTY29wZWRFbmNhcHN1bGF0aW9uICovKSB7XG4gICAgICAgIC8vIG9ubHkgcmVxdWlyZWQgd2hlbiB3ZSdyZSBOT1QgdXNpbmcgbmF0aXZlIHNoYWRvdyBkb20gKHNsb3QpXG4gICAgICAgIC8vIG9yIHRoaXMgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgbmF0aXZlIHNoYWRvdyBkb21cbiAgICAgICAgLy8gYW5kIHRoaXMgaG9zdCBlbGVtZW50IHdhcyBOT1QgY3JlYXRlZCB3aXRoIFNTUlxuICAgICAgICAvLyBsZXQncyBwaWNrIG91dCB0aGUgaW5uZXIgY29udGVudCBmb3Igc2xvdCBwcm9qZWN0aW9uXG4gICAgICAgIC8vIGNyZWF0ZSBhIG5vZGUgdG8gcmVwcmVzZW50IHdoZXJlIHRoZSBvcmlnaW5hbFxuICAgICAgICAvLyBjb250ZW50IHdhcyBmaXJzdCBwbGFjZWQsIHdoaWNoIGlzIHVzZWZ1bCBsYXRlciBvblxuICAgICAgICAvLyBET00gV1JJVEUhIVxuICAgICAgICBlbG1bJ3Mtc2MnXSA9IHNjb3BlSWQ7XG4gICAgICAgIGVsbS5jbGFzc0xpc3QuYWRkKHNjb3BlSWQgKyAnLWgnKTtcbiAgICAgICAgaWYgKEJVSUxELnNjb3BlZCAmJiBmbGFncyAmIDIgLyogc2NvcGVkQ3NzRW5jYXBzdWxhdGlvbiAqLykge1xuICAgICAgICAgICAgZWxtLmNsYXNzTGlzdC5hZGQoc2NvcGVJZCArICctcycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVuZEF0dGFjaFN0eWxlcygpO1xufTtcbmNvbnN0IGdldFNjb3BlSWQgPSAoY21wLCBtb2RlKSA9PiAnc2MtJyArIChCVUlMRC5tb2RlICYmIG1vZGUgJiYgY21wLiRmbGFncyQgJiAzMiAvKiBoYXNNb2RlICovID8gY21wLiR0YWdOYW1lJCArICctJyArIG1vZGUgOiBjbXAuJHRhZ05hbWUkKTtcbmNvbnN0IGNvbnZlcnRTY29wZWRUb1NoYWRvdyA9IChjc3MpID0+IGNzcy5yZXBsYWNlKC9cXC9cXCohQChbXlxcL10rKVxcKlxcL1teXFx7XStcXHsvZywgJyQxeycpO1xuLy8gUHJpdmF0ZVxuY29uc3QgY29tcHV0ZU1vZGUgPSAoZWxtKSA9PiBtb2RlUmVzb2x1dGlvbkNoYWluLm1hcChoID0+IGgoZWxtKSkuZmluZChtID0+ICEhbSk7XG4vLyBQdWJsaWNcbmNvbnN0IHNldE1vZGUgPSAoaGFuZGxlcikgPT4gbW9kZVJlc29sdXRpb25DaGFpbi5wdXNoKGhhbmRsZXIpO1xuY29uc3QgZ2V0TW9kZSA9IChyZWYpID0+IGdldEhvc3RSZWYocmVmKS4kbW9kZU5hbWUkO1xuLyoqXG4gKiBEZWZhdWx0IHN0eWxlIG1vZGUgaWRcbiAqL1xuLyoqXG4gKiBSZXVzYWJsZSBlbXB0eSBvYmovYXJyYXlcbiAqIERvbid0IGFkZCB2YWx1ZXMgdG8gdGhlc2UhIVxuICovXG5jb25zdCBFTVBUWV9PQkogPSB7fTtcbi8qKlxuICogTmFtZXNwYWNlc1xuICovXG5jb25zdCBTVkdfTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuY29uc3QgSFRNTF9OUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcbmNvbnN0IGlzRGVmID0gKHYpID0+IHYgIT0gbnVsbDtcbmNvbnN0IGlzQ29tcGxleFR5cGUgPSAobykgPT4ge1xuICAgIC8vIGh0dHBzOi8vanNwZXJmLmNvbS90eXBlb2YtZm4tb2JqZWN0LzVcbiAgICBvID0gdHlwZW9mIG87XG4gICAgcmV0dXJuIG8gPT09ICdvYmplY3QnIHx8IG8gPT09ICdmdW5jdGlvbic7XG59O1xuLyoqXG4gKiBQcm9kdWN0aW9uIGgoKSBmdW5jdGlvbiBiYXNlZCBvbiBQcmVhY3QgYnlcbiAqIEphc29uIE1pbGxlciAoQGRldmVsb3BpdClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL2RldmVsb3BpdC9wcmVhY3QvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICpcbiAqIE1vZGlmaWVkIGZvciBTdGVuY2lsJ3MgY29tcGlsZXIgYW5kIHZkb21cbiAqL1xuLy8gY29uc3Qgc3RhY2s6IGFueVtdID0gW107XG4vLyBleHBvcnQgZnVuY3Rpb24gaChub2RlTmFtZTogc3RyaW5nIHwgZC5GdW5jdGlvbmFsQ29tcG9uZW50LCB2bm9kZURhdGE6IGQuUHJvcHNUeXBlLCBjaGlsZD86IGQuQ2hpbGRUeXBlKTogZC5WTm9kZTtcbi8vIGV4cG9ydCBmdW5jdGlvbiBoKG5vZGVOYW1lOiBzdHJpbmcgfCBkLkZ1bmN0aW9uYWxDb21wb25lbnQsIHZub2RlRGF0YTogZC5Qcm9wc1R5cGUsIC4uLmNoaWxkcmVuOiBkLkNoaWxkVHlwZVtdKTogZC5WTm9kZTtcbmNvbnN0IGggPSAobm9kZU5hbWUsIHZub2RlRGF0YSwgLi4uY2hpbGRyZW4pID0+IHtcbiAgICBsZXQgY2hpbGQgPSBudWxsO1xuICAgIGxldCBrZXkgPSBudWxsO1xuICAgIGxldCBzbG90TmFtZSA9IG51bGw7XG4gICAgbGV0IHNpbXBsZSA9IGZhbHNlO1xuICAgIGxldCBsYXN0U2ltcGxlID0gZmFsc2U7XG4gICAgbGV0IHZOb2RlQ2hpbGRyZW4gPSBbXTtcbiAgICBjb25zdCB3YWxrID0gKGMpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjaGlsZCA9IGNbaV07XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICB3YWxrKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkICE9IG51bGwgJiYgdHlwZW9mIGNoaWxkICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHNpbXBsZSA9IHR5cGVvZiBub2RlTmFtZSAhPT0gJ2Z1bmN0aW9uJyAmJiAhaXNDb21wbGV4VHlwZShjaGlsZCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkID0gU3RyaW5nKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoQlVJTEQuaXNEZXYgJiYgdHlwZW9mIG5vZGVOYW1lICE9PSAnZnVuY3Rpb24nICYmIGNoaWxkLiRmbGFncyQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlRGV2RXJyb3IoYHZOb2RlIHBhc3NlZCBhcyBjaGlsZHJlbiBoYXMgdW5leHBlY3RlZCB0eXBlLlxuTWFrZSBzdXJlIGl0J3MgdXNpbmcgdGhlIGNvcnJlY3QgaCgpIGZ1bmN0aW9uLlxuRW1wdHkgb2JqZWN0cyBjYW4gYWxzbyBiZSB0aGUgY2F1c2UsIGxvb2sgZm9yIEpTWCBjb21tZW50cyB0aGF0IGJlY2FtZSBvYmplY3RzLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2ltcGxlICYmIGxhc3RTaW1wbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHByZXZpb3VzIGNoaWxkIHdhcyBzaW1wbGUgKHN0cmluZyksIHdlIG1lcmdlIGJvdGhcbiAgICAgICAgICAgICAgICAgICAgdk5vZGVDaGlsZHJlblt2Tm9kZUNoaWxkcmVuLmxlbmd0aCAtIDFdLiR0ZXh0JCArPSBjaGlsZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCBhIG5ldyB2Tm9kZSwgaWYgaXQncyB0ZXh0LCB3ZSBjcmVhdGUgYSB0ZXh0IHZOb2RlXG4gICAgICAgICAgICAgICAgICAgIHZOb2RlQ2hpbGRyZW4ucHVzaChzaW1wbGUgPyBuZXdWTm9kZShudWxsLCBjaGlsZCkgOiBjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhc3RTaW1wbGUgPSBzaW1wbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHdhbGsoY2hpbGRyZW4pO1xuICAgIGlmICh2bm9kZURhdGEpIHtcbiAgICAgICAgaWYgKEJVSUxELmlzRGV2ICYmIG5vZGVOYW1lID09PSAnaW5wdXQnKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUlucHV0UHJvcGVydGllcyh2bm9kZURhdGEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vcm1hbGl6ZSBjbGFzcyAvIGNsYXNzbmFtZSBhdHRyaWJ1dGVzXG4gICAgICAgIGlmIChCVUlMRC52ZG9tS2V5ICYmIHZub2RlRGF0YS5rZXkpIHtcbiAgICAgICAgICAgIGtleSA9IHZub2RlRGF0YS5rZXk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJVSUxELnNsb3RSZWxvY2F0aW9uICYmIHZub2RlRGF0YS5uYW1lKSB7XG4gICAgICAgICAgICBzbG90TmFtZSA9IHZub2RlRGF0YS5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC52ZG9tQ2xhc3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsYXNzRGF0YSA9IHZub2RlRGF0YS5jbGFzc05hbWUgfHwgdm5vZGVEYXRhLmNsYXNzO1xuICAgICAgICAgICAgaWYgKGNsYXNzRGF0YSkge1xuICAgICAgICAgICAgICAgIHZub2RlRGF0YS5jbGFzcyA9XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBjbGFzc0RhdGEgIT09ICdvYmplY3QnXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNsYXNzRGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBPYmplY3Qua2V5cyhjbGFzc0RhdGEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihrID0+IGNsYXNzRGF0YVtrXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuam9pbignICcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChCVUlMRC5pc0RldiAmJiB2Tm9kZUNoaWxkcmVuLnNvbWUoaXNIb3N0KSkge1xuICAgICAgICBjb25zb2xlRGV2RXJyb3IoYFRoZSA8SG9zdD4gbXVzdCBiZSB0aGUgc2luZ2xlIHJvb3QgY29tcG9uZW50LiBNYWtlIHN1cmU6XG4tIFlvdSBhcmUgTk9UIHVzaW5nIGhvc3REYXRhKCkgYW5kIDxIb3N0PiBpbiB0aGUgc2FtZSBjb21wb25lbnQuXG4tIDxIb3N0PiBpcyB1c2VkIG9uY2UsIGFuZCBpdCdzIHRoZSBzaW5nbGUgcm9vdCBjb21wb25lbnQgb2YgdGhlIHJlbmRlcigpIGZ1bmN0aW9uLmApO1xuICAgIH1cbiAgICBpZiAoQlVJTEQudmRvbUZ1bmN0aW9uYWwgJiYgdHlwZW9mIG5vZGVOYW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vZGVOYW1lIGlzIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgICAgICAgcmV0dXJuIG5vZGVOYW1lKHZub2RlRGF0YSA9PT0gbnVsbCA/IHt9IDogdm5vZGVEYXRhLCB2Tm9kZUNoaWxkcmVuLCB2ZG9tRm5VdGlscyk7XG4gICAgfVxuICAgIGNvbnN0IHZub2RlID0gbmV3Vk5vZGUobm9kZU5hbWUsIG51bGwpO1xuICAgIHZub2RlLiRhdHRycyQgPSB2bm9kZURhdGE7XG4gICAgaWYgKHZOb2RlQ2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICB2bm9kZS4kY2hpbGRyZW4kID0gdk5vZGVDaGlsZHJlbjtcbiAgICB9XG4gICAgaWYgKEJVSUxELnZkb21LZXkpIHtcbiAgICAgICAgdm5vZGUuJGtleSQgPSBrZXk7XG4gICAgfVxuICAgIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbikge1xuICAgICAgICB2bm9kZS4kbmFtZSQgPSBzbG90TmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlO1xufTtcbmNvbnN0IG5ld1ZOb2RlID0gKHRhZywgdGV4dCkgPT4ge1xuICAgIGNvbnN0IHZub2RlID0ge1xuICAgICAgICAkZmxhZ3MkOiAwLFxuICAgICAgICAkdGFnJDogdGFnLFxuICAgICAgICAkdGV4dCQ6IHRleHQsXG4gICAgICAgICRlbG0kOiBudWxsLFxuICAgICAgICAkY2hpbGRyZW4kOiBudWxsLFxuICAgIH07XG4gICAgaWYgKEJVSUxELnZkb21BdHRyaWJ1dGUpIHtcbiAgICAgICAgdm5vZGUuJGF0dHJzJCA9IG51bGw7XG4gICAgfVxuICAgIGlmIChCVUlMRC52ZG9tS2V5KSB7XG4gICAgICAgIHZub2RlLiRrZXkkID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKEJVSUxELnNsb3RSZWxvY2F0aW9uKSB7XG4gICAgICAgIHZub2RlLiRuYW1lJCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiB2bm9kZTtcbn07XG5jb25zdCBIb3N0ID0ge307XG5jb25zdCBpc0hvc3QgPSAobm9kZSkgPT4gbm9kZSAmJiBub2RlLiR0YWckID09PSBIb3N0O1xuY29uc3QgdmRvbUZuVXRpbHMgPSB7XG4gICAgZm9yRWFjaDogKGNoaWxkcmVuLCBjYikgPT4gY2hpbGRyZW4ubWFwKGNvbnZlcnRUb1B1YmxpYykuZm9yRWFjaChjYiksXG4gICAgbWFwOiAoY2hpbGRyZW4sIGNiKSA9PiBjaGlsZHJlbi5tYXAoY29udmVydFRvUHVibGljKS5tYXAoY2IpLm1hcChjb252ZXJ0VG9Qcml2YXRlKSxcbn07XG5jb25zdCBjb252ZXJ0VG9QdWJsaWMgPSAobm9kZSkgPT4gKHtcbiAgICB2YXR0cnM6IG5vZGUuJGF0dHJzJCxcbiAgICB2Y2hpbGRyZW46IG5vZGUuJGNoaWxkcmVuJCxcbiAgICB2a2V5OiBub2RlLiRrZXkkLFxuICAgIHZuYW1lOiBub2RlLiRuYW1lJCxcbiAgICB2dGFnOiBub2RlLiR0YWckLFxuICAgIHZ0ZXh0OiBub2RlLiR0ZXh0JCxcbn0pO1xuY29uc3QgY29udmVydFRvUHJpdmF0ZSA9IChub2RlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBub2RlLnZ0YWcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3Qgdm5vZGVEYXRhID0gT2JqZWN0LmFzc2lnbih7fSwgbm9kZS52YXR0cnMpO1xuICAgICAgICBpZiAobm9kZS52a2V5KSB7XG4gICAgICAgICAgICB2bm9kZURhdGEua2V5ID0gbm9kZS52a2V5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnZuYW1lKSB7XG4gICAgICAgICAgICB2bm9kZURhdGEubmFtZSA9IG5vZGUudm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGgobm9kZS52dGFnLCB2bm9kZURhdGEsIC4uLihub2RlLnZjaGlsZHJlbiB8fCBbXSkpO1xuICAgIH1cbiAgICBjb25zdCB2bm9kZSA9IG5ld1ZOb2RlKG5vZGUudnRhZywgbm9kZS52dGV4dCk7XG4gICAgdm5vZGUuJGF0dHJzJCA9IG5vZGUudmF0dHJzO1xuICAgIHZub2RlLiRjaGlsZHJlbiQgPSBub2RlLnZjaGlsZHJlbjtcbiAgICB2bm9kZS4ka2V5JCA9IG5vZGUudmtleTtcbiAgICB2bm9kZS4kbmFtZSQgPSBub2RlLnZuYW1lO1xuICAgIHJldHVybiB2bm9kZTtcbn07XG5jb25zdCB2YWxpZGF0ZUlucHV0UHJvcGVydGllcyA9ICh2bm9kZURhdGEpID0+IHtcbiAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5rZXlzKHZub2RlRGF0YSk7XG4gICAgY29uc3QgdHlwZUluZGV4ID0gcHJvcHMuaW5kZXhPZigndHlwZScpO1xuICAgIGNvbnN0IG1pbkluZGV4ID0gcHJvcHMuaW5kZXhPZignbWluJyk7XG4gICAgY29uc3QgbWF4SW5kZXggPSBwcm9wcy5pbmRleE9mKCdtYXgnKTtcbiAgICBjb25zdCBzdGVwSW5kZXggPSBwcm9wcy5pbmRleE9mKCdtaW4nKTtcbiAgICBjb25zdCB2YWx1ZSA9IHByb3BzLmluZGV4T2YoJ3ZhbHVlJyk7XG4gICAgaWYgKHZhbHVlID09PSAtMSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh2YWx1ZSA8IHR5cGVJbmRleCB8fCB2YWx1ZSA8IG1pbkluZGV4IHx8IHZhbHVlIDwgbWF4SW5kZXggfHwgdmFsdWUgPCBzdGVwSW5kZXgpIHtcbiAgICAgICAgY29uc29sZURldldhcm4oYFRoZSBcInZhbHVlXCIgcHJvcCBvZiA8aW5wdXQ+IHNob3VsZCBiZSBzZXQgYWZ0ZXIgXCJtaW5cIiwgXCJtYXhcIiwgXCJ0eXBlXCIgYW5kIFwic3RlcFwiYCk7XG4gICAgfVxufTtcbi8qKlxuICogUHJvZHVjdGlvbiBzZXRBY2Nlc3NvcigpIGZ1bmN0aW9uIGJhc2VkIG9uIFByZWFjdCBieVxuICogSmFzb24gTWlsbGVyIChAZGV2ZWxvcGl0KVxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZGV2ZWxvcGl0L3ByZWFjdC9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogTW9kaWZpZWQgZm9yIFN0ZW5jaWwncyBjb21waWxlciBhbmQgdmRvbVxuICovXG5jb25zdCBzZXRBY2Nlc3NvciA9IChlbG0sIG1lbWJlck5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSwgaXNTdmcsIGZsYWdzKSA9PiB7XG4gICAgaWYgKG9sZFZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICBsZXQgaXNQcm9wID0gaXNNZW1iZXJJbkVsZW1lbnQoZWxtLCBtZW1iZXJOYW1lKTtcbiAgICAgICAgbGV0IGxuID0gbWVtYmVyTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoQlVJTEQudmRvbUNsYXNzICYmIG1lbWJlck5hbWUgPT09ICdjbGFzcycpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsYXNzTGlzdCA9IGVsbS5jbGFzc0xpc3Q7XG4gICAgICAgICAgICBjb25zdCBvbGRDbGFzc2VzID0gcGFyc2VDbGFzc0xpc3Qob2xkVmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgbmV3Q2xhc3NlcyA9IHBhcnNlQ2xhc3NMaXN0KG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIGNsYXNzTGlzdC5yZW1vdmUoLi4ub2xkQ2xhc3Nlcy5maWx0ZXIoYyA9PiBjICYmICFuZXdDbGFzc2VzLmluY2x1ZGVzKGMpKSk7XG4gICAgICAgICAgICBjbGFzc0xpc3QuYWRkKC4uLm5ld0NsYXNzZXMuZmlsdGVyKGMgPT4gYyAmJiAhb2xkQ2xhc3Nlcy5pbmNsdWRlcyhjKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEJVSUxELnZkb21TdHlsZSAmJiBtZW1iZXJOYW1lID09PSAnc3R5bGUnKSB7XG4gICAgICAgICAgICAvLyB1cGRhdGUgc3R5bGUgYXR0cmlidXRlLCBjc3MgcHJvcGVydGllcyBhbmQgdmFsdWVzXG4gICAgICAgICAgICBpZiAoQlVJTEQudXBkYXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIG9sZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmV3VmFsdWUgfHwgbmV3VmFsdWVbcHJvcF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFCVUlMRC5oeWRyYXRlU2VydmVyU2lkZSAmJiBwcm9wLmluY2x1ZGVzKCctJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbG0uc3R5bGUucmVtb3ZlUHJvcGVydHkocHJvcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbG0uc3R5bGVbcHJvcF0gPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICghb2xkVmFsdWUgfHwgbmV3VmFsdWVbcHJvcF0gIT09IG9sZFZhbHVlW3Byb3BdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGUgJiYgcHJvcC5pbmNsdWRlcygnLScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbG0uc3R5bGUuc2V0UHJvcGVydHkocHJvcCwgbmV3VmFsdWVbcHJvcF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxtLnN0eWxlW3Byb3BdID0gbmV3VmFsdWVbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQlVJTEQudmRvbUtleSAmJiBtZW1iZXJOYW1lID09PSAna2V5JylcbiAgICAgICAgICAgIDtcbiAgICAgICAgZWxzZSBpZiAoQlVJTEQudmRvbVJlZiAmJiBtZW1iZXJOYW1lID09PSAncmVmJykge1xuICAgICAgICAgICAgLy8gbWluaWZpZXIgd2lsbCBjbGVhbiB0aGlzIHVwXG4gICAgICAgICAgICBpZiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZShlbG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEJVSUxELnZkb21MaXN0ZW5lciAmJiAoQlVJTEQubGF6eUxvYWQgPyAhaXNQcm9wIDogIWVsbS5fX2xvb2t1cFNldHRlcl9fKG1lbWJlck5hbWUpKSAmJiBtZW1iZXJOYW1lWzBdID09PSAnbycgJiYgbWVtYmVyTmFtZVsxXSA9PT0gJ24nKSB7XG4gICAgICAgICAgICAvLyBFdmVudCBIYW5kbGVyc1xuICAgICAgICAgICAgLy8gc28gaWYgdGhlIG1lbWJlciBuYW1lIHN0YXJ0cyB3aXRoIFwib25cIiBhbmQgdGhlIDNyZCBjaGFyYWN0ZXJzIGlzXG4gICAgICAgICAgICAvLyBhIGNhcGl0YWwgbGV0dGVyLCBhbmQgaXQncyBub3QgYWxyZWFkeSBhIG1lbWJlciBvbiB0aGUgZWxlbWVudCxcbiAgICAgICAgICAgIC8vIHRoZW4gd2UncmUgYXNzdW1pbmcgaXQncyBhbiBldmVudCBsaXN0ZW5lclxuICAgICAgICAgICAgaWYgKG1lbWJlck5hbWVbMl0gPT09ICctJykge1xuICAgICAgICAgICAgICAgIC8vIG9uLSBwcmVmaXhlZCBldmVudHNcbiAgICAgICAgICAgICAgICAvLyBhbGxvd3MgdG8gYmUgZXhwbGljaXQgYWJvdXQgdGhlIGRvbSBldmVudCB0byBsaXN0ZW4gd2l0aG91dCBhbnkgbWFnaWNcbiAgICAgICAgICAgICAgICAvLyB1bmRlciB0aGUgaG9vZDpcbiAgICAgICAgICAgICAgICAvLyA8bXktY21wIG9uLWNsaWNrPiAvLyBsaXN0ZW5zIGZvciBcImNsaWNrXCJcbiAgICAgICAgICAgICAgICAvLyA8bXktY21wIG9uLUNsaWNrPiAvLyBsaXN0ZW5zIGZvciBcIkNsaWNrXCJcbiAgICAgICAgICAgICAgICAvLyA8bXktY21wIG9uLWlvbkNoYW5nZT4gLy8gbGlzdGVucyBmb3IgXCJpb25DaGFuZ2VcIlxuICAgICAgICAgICAgICAgIC8vIDxteS1jbXAgb24tRVZFTlRTPiAvLyBsaXN0ZW5zIGZvciBcIkVWRU5UU1wiXG4gICAgICAgICAgICAgICAgbWVtYmVyTmFtZSA9IG1lbWJlck5hbWUuc2xpY2UoMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc01lbWJlckluRWxlbWVudCh3aW4sIGxuKSkge1xuICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkIGV2ZW50XG4gICAgICAgICAgICAgICAgLy8gdGhlIEpTWCBhdHRyaWJ1dGUgY291bGQgaGF2ZSBiZWVuIFwib25Nb3VzZU92ZXJcIiBhbmQgdGhlXG4gICAgICAgICAgICAgICAgLy8gbWVtYmVyIG5hbWUgXCJvbm1vdXNlb3ZlclwiIGlzIG9uIHRoZSB3aW5kb3cncyBwcm90b3R5cGVcbiAgICAgICAgICAgICAgICAvLyBzbyBsZXQncyBhZGQgdGhlIGxpc3RlbmVyIFwibW91c2VvdmVyXCIsIHdoaWNoIGlzIGFsbCBsb3dlcmNhc2VkXG4gICAgICAgICAgICAgICAgbWVtYmVyTmFtZSA9IGxuLnNsaWNlKDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY3VzdG9tIGV2ZW50XG4gICAgICAgICAgICAgICAgLy8gdGhlIEpTWCBhdHRyaWJ1dGUgY291bGQgaGF2ZSBiZWVuIFwib25NeUN1c3RvbUV2ZW50XCJcbiAgICAgICAgICAgICAgICAvLyBzbyBsZXQncyB0cmltIG9mZiB0aGUgXCJvblwiIHByZWZpeCBhbmQgbG93ZXJjYXNlIHRoZSBmaXJzdCBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICAvLyBhbmQgYWRkIHRoZSBsaXN0ZW5lciBcIm15Q3VzdG9tRXZlbnRcIlxuICAgICAgICAgICAgICAgIC8vIGV4Y2VwdCBmb3IgdGhlIGZpcnN0IGNoYXJhY3Rlciwgd2Uga2VlcCB0aGUgZXZlbnQgbmFtZSBjYXNlXG4gICAgICAgICAgICAgICAgbWVtYmVyTmFtZSA9IGxuWzJdICsgbWVtYmVyTmFtZS5zbGljZSgzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbGRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHBsdC5yZWwoZWxtLCBtZW1iZXJOYW1lLCBvbGRWYWx1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcGx0LmFlbChlbG0sIG1lbWJlck5hbWUsIG5ld1ZhbHVlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQlVJTEQudmRvbVByb3BPckF0dHIpIHtcbiAgICAgICAgICAgIC8vIFNldCBwcm9wZXJ0eSBpZiBpdCBleGlzdHMgYW5kIGl0J3Mgbm90IGEgU1ZHXG4gICAgICAgICAgICBjb25zdCBpc0NvbXBsZXggPSBpc0NvbXBsZXhUeXBlKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIGlmICgoaXNQcm9wIHx8IChpc0NvbXBsZXggJiYgbmV3VmFsdWUgIT09IG51bGwpKSAmJiAhaXNTdmcpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVsbS50YWdOYW1lLmluY2x1ZGVzKCctJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuID0gbmV3VmFsdWUgPT0gbnVsbCA/ICcnIDogbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBTYWZhcmksIG1vdmluZyB0aGUgPGlucHV0PiBjYXJldCB3aGVuIHJlLWFzc2lnbmluZyB0aGUgc2FtZSB2YWx1ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZW1iZXJOYW1lID09PSAnbGlzdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1Byb3AgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IHRyaXBsZS1lcXVhbHNcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9sZFZhbHVlID09IG51bGwgfHwgZWxtW21lbWJlck5hbWVdICE9IG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbG1bbWVtYmVyTmFtZV0gPSBuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxtW21lbWJlck5hbWVdID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBOZWVkIHRvIG1hbnVhbGx5IHVwZGF0ZSBhdHRyaWJ1dGUgaWY6XG4gICAgICAgICAgICAgKiAtIG1lbWJlck5hbWUgaXMgbm90IGFuIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICogLSBpZiB3ZSBhcmUgcmVuZGVyaW5nIHRoZSBob3N0IGVsZW1lbnQgaW4gb3JkZXIgdG8gcmVmbGVjdCBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAqIC0gaWYgaXQncyBhIFNWRywgc2luY2UgcHJvcGVydGllcyBtaWdodCBub3Qgd29yayBpbiA8c3ZnPlxuICAgICAgICAgICAgICogLSBpZiB0aGUgbmV3VmFsdWUgaXMgbnVsbC91bmRlZmluZWQgb3IgJ2ZhbHNlJy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbGV0IHhsaW5rID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoQlVJTEQudmRvbVhsaW5rKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxuICE9PSAobG4gPSBsbi5yZXBsYWNlKC9eeGxpbmtcXDo/LywgJycpKSkge1xuICAgICAgICAgICAgICAgICAgICBtZW1iZXJOYW1lID0gbG47XG4gICAgICAgICAgICAgICAgICAgIHhsaW5rID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3VmFsdWUgPT0gbnVsbCB8fCBuZXdWYWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV3VmFsdWUgIT09IGZhbHNlIHx8IGVsbS5nZXRBdHRyaWJ1dGUobWVtYmVyTmFtZSkgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChCVUlMRC52ZG9tWGxpbmsgJiYgeGxpbmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGVOUyhYTElOS19OUywgbWVtYmVyTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKG1lbWJlck5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKCFpc1Byb3AgfHwgZmxhZ3MgJiA0IC8qIGlzSG9zdCAqLyB8fCBpc1N2ZykgJiYgIWlzQ29tcGxleCkge1xuICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gbmV3VmFsdWUgPT09IHRydWUgPyAnJyA6IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChCVUlMRC52ZG9tWGxpbmsgJiYgeGxpbmspIHtcbiAgICAgICAgICAgICAgICAgICAgZWxtLnNldEF0dHJpYnV0ZU5TKFhMSU5LX05TLCBtZW1iZXJOYW1lLCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbG0uc2V0QXR0cmlidXRlKG1lbWJlck5hbWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgcGFyc2VDbGFzc0xpc3RSZWdleCA9IC9cXHMvO1xuY29uc3QgcGFyc2VDbGFzc0xpc3QgPSAodmFsdWUpID0+ICghdmFsdWUgPyBbXSA6IHZhbHVlLnNwbGl0KHBhcnNlQ2xhc3NMaXN0UmVnZXgpKTtcbmNvbnN0IHVwZGF0ZUVsZW1lbnQgPSAob2xkVm5vZGUsIG5ld1Zub2RlLCBpc1N2Z01vZGUsIG1lbWJlck5hbWUpID0+IHtcbiAgICAvLyBpZiB0aGUgZWxlbWVudCBwYXNzZWQgaW4gaXMgYSBzaGFkb3cgcm9vdCwgd2hpY2ggaXMgYSBkb2N1bWVudCBmcmFnbWVudFxuICAgIC8vIHRoZW4gd2Ugd2FudCB0byBiZSBhZGRpbmcgYXR0cnMvcHJvcHMgdG8gdGhlIHNoYWRvdyByb290J3MgXCJob3N0XCIgZWxlbWVudFxuICAgIC8vIGlmIGl0J3Mgbm90IGEgc2hhZG93IHJvb3QsIHRoZW4gd2UgYWRkIGF0dHJzL3Byb3BzIHRvIHRoZSBzYW1lIGVsZW1lbnRcbiAgICBjb25zdCBlbG0gPSBuZXdWbm9kZS4kZWxtJC5ub2RlVHlwZSA9PT0gMTEgLyogRG9jdW1lbnRGcmFnbWVudCAqLyAmJiBuZXdWbm9kZS4kZWxtJC5ob3N0ID8gbmV3Vm5vZGUuJGVsbSQuaG9zdCA6IG5ld1Zub2RlLiRlbG0kO1xuICAgIGNvbnN0IG9sZFZub2RlQXR0cnMgPSAob2xkVm5vZGUgJiYgb2xkVm5vZGUuJGF0dHJzJCkgfHwgRU1QVFlfT0JKO1xuICAgIGNvbnN0IG5ld1Zub2RlQXR0cnMgPSBuZXdWbm9kZS4kYXR0cnMkIHx8IEVNUFRZX09CSjtcbiAgICBpZiAoQlVJTEQudXBkYXRhYmxlKSB7XG4gICAgICAgIC8vIHJlbW92ZSBhdHRyaWJ1dGVzIG5vIGxvbmdlciBwcmVzZW50IG9uIHRoZSB2bm9kZSBieSBzZXR0aW5nIHRoZW0gdG8gdW5kZWZpbmVkXG4gICAgICAgIGZvciAobWVtYmVyTmFtZSBpbiBvbGRWbm9kZUF0dHJzKSB7XG4gICAgICAgICAgICBpZiAoIShtZW1iZXJOYW1lIGluIG5ld1Zub2RlQXR0cnMpKSB7XG4gICAgICAgICAgICAgICAgc2V0QWNjZXNzb3IoZWxtLCBtZW1iZXJOYW1lLCBvbGRWbm9kZUF0dHJzW21lbWJlck5hbWVdLCB1bmRlZmluZWQsIGlzU3ZnTW9kZSwgbmV3Vm5vZGUuJGZsYWdzJCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYWRkIG5ldyAmIHVwZGF0ZSBjaGFuZ2VkIGF0dHJpYnV0ZXNcbiAgICBmb3IgKG1lbWJlck5hbWUgaW4gbmV3Vm5vZGVBdHRycykge1xuICAgICAgICBzZXRBY2Nlc3NvcihlbG0sIG1lbWJlck5hbWUsIG9sZFZub2RlQXR0cnNbbWVtYmVyTmFtZV0sIG5ld1Zub2RlQXR0cnNbbWVtYmVyTmFtZV0sIGlzU3ZnTW9kZSwgbmV3Vm5vZGUuJGZsYWdzJCk7XG4gICAgfVxufTtcbmNvbnN0IGNyZWF0ZUVsbSA9IChvbGRQYXJlbnRWTm9kZSwgbmV3UGFyZW50Vk5vZGUsIGNoaWxkSW5kZXgsIHBhcmVudEVsbSkgPT4ge1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogcHJlZmVyLWNvbnN0XG4gICAgbGV0IG5ld1ZOb2RlID0gbmV3UGFyZW50Vk5vZGUuJGNoaWxkcmVuJFtjaGlsZEluZGV4XTtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGVsbTtcbiAgICBsZXQgY2hpbGROb2RlO1xuICAgIGxldCBvbGRWTm9kZTtcbiAgICBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24gJiYgIXVzZU5hdGl2ZVNoYWRvd0RvbSkge1xuICAgICAgICAvLyByZW1lbWJlciBmb3IgbGF0ZXIgd2UgbmVlZCB0byBjaGVjayB0byByZWxvY2F0ZSBub2Rlc1xuICAgICAgICBjaGVja1Nsb3RSZWxvY2F0ZSA9IHRydWU7XG4gICAgICAgIGlmIChuZXdWTm9kZS4kdGFnJCA9PT0gJ3Nsb3QnKSB7XG4gICAgICAgICAgICBpZiAoc2NvcGVJZCkge1xuICAgICAgICAgICAgICAgIC8vIHNjb3BlZCBjc3MgbmVlZHMgdG8gYWRkIGl0cyBzY29wZWQgaWQgdG8gdGhlIHBhcmVudCBlbGVtZW50XG4gICAgICAgICAgICAgICAgcGFyZW50RWxtLmNsYXNzTGlzdC5hZGQoc2NvcGVJZCArICctcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3Vk5vZGUuJGZsYWdzJCB8PSBuZXdWTm9kZS4kY2hpbGRyZW4kXG4gICAgICAgICAgICAgICAgPyAvLyBzbG90IGVsZW1lbnQgaGFzIGZhbGxiYWNrIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgMiAvKiBpc1Nsb3RGYWxsYmFjayAqL1xuICAgICAgICAgICAgICAgIDogLy8gc2xvdCBlbGVtZW50IGRvZXMgbm90IGhhdmUgZmFsbGJhY2sgY29udGVudFxuICAgICAgICAgICAgICAgICAgICAxIC8qIGlzU2xvdFJlZmVyZW5jZSAqLztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoQlVJTEQuaXNEZXYgJiYgbmV3Vk5vZGUuJGVsbSQpIHtcbiAgICAgICAgY29uc29sZURldkVycm9yKGBUaGUgSlNYICR7bmV3Vk5vZGUuJHRleHQkICE9PSBudWxsID8gYFwiJHtuZXdWTm9kZS4kdGV4dCR9XCIgdGV4dGAgOiBgXCIke25ld1ZOb2RlLiR0YWckfVwiIGVsZW1lbnRgfSBub2RlIHNob3VsZCBub3QgYmUgc2hhcmVkIHdpdGhpbiB0aGUgc2FtZSByZW5kZXJlci4gVGhlIHJlbmRlcmVyIGNhY2hlcyBlbGVtZW50IGxvb2t1cHMgaW4gb3JkZXIgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZS4gSG93ZXZlciwgYSBzaWRlIGVmZmVjdCBmcm9tIHRoaXMgaXMgdGhhdCB0aGUgZXhhY3Qgc2FtZSBKU1ggbm9kZSBzaG91bGQgbm90IGJlIHJldXNlZC4gRm9yIG1vcmUgaW5mb3JtYXRpb24gcGxlYXNlIHNlZSBodHRwczovL3N0ZW5jaWxqcy5jb20vZG9jcy90ZW1wbGF0aW5nLWpzeCNhdm9pZC1zaGFyZWQtanN4LW5vZGVzYCk7XG4gICAgfVxuICAgIGlmIChCVUlMRC52ZG9tVGV4dCAmJiBuZXdWTm9kZS4kdGV4dCQgIT09IG51bGwpIHtcbiAgICAgICAgLy8gY3JlYXRlIHRleHQgbm9kZVxuICAgICAgICBlbG0gPSBuZXdWTm9kZS4kZWxtJCA9IGRvYy5jcmVhdGVUZXh0Tm9kZShuZXdWTm9kZS4kdGV4dCQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbiAmJiBuZXdWTm9kZS4kZmxhZ3MkICYgMSAvKiBpc1Nsb3RSZWZlcmVuY2UgKi8pIHtcbiAgICAgICAgLy8gY3JlYXRlIGEgc2xvdCByZWZlcmVuY2Ugbm9kZVxuICAgICAgICBlbG0gPSBuZXdWTm9kZS4kZWxtJCA9IEJVSUxELmlzRGVidWcgfHwgQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGUgPyBzbG90UmVmZXJlbmNlRGVidWdOb2RlKG5ld1ZOb2RlKSA6IGRvYy5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoQlVJTEQuc3ZnICYmICFpc1N2Z01vZGUpIHtcbiAgICAgICAgICAgIGlzU3ZnTW9kZSA9IG5ld1ZOb2RlLiR0YWckID09PSAnc3ZnJztcbiAgICAgICAgfVxuICAgICAgICAvLyBjcmVhdGUgZWxlbWVudFxuICAgICAgICBlbG0gPSBuZXdWTm9kZS4kZWxtJCA9IChCVUlMRC5zdmdcbiAgICAgICAgICAgID8gZG9jLmNyZWF0ZUVsZW1lbnROUyhpc1N2Z01vZGUgPyBTVkdfTlMgOiBIVE1MX05TLCBCVUlMRC5zbG90UmVsb2NhdGlvbiAmJiBuZXdWTm9kZS4kZmxhZ3MkICYgMiAvKiBpc1Nsb3RGYWxsYmFjayAqLyA/ICdzbG90LWZiJyA6IG5ld1ZOb2RlLiR0YWckKVxuICAgICAgICAgICAgOiBkb2MuY3JlYXRlRWxlbWVudChCVUlMRC5zbG90UmVsb2NhdGlvbiAmJiBuZXdWTm9kZS4kZmxhZ3MkICYgMiAvKiBpc1Nsb3RGYWxsYmFjayAqLyA/ICdzbG90LWZiJyA6IG5ld1ZOb2RlLiR0YWckKSk7XG4gICAgICAgIGlmIChCVUlMRC5zdmcgJiYgaXNTdmdNb2RlICYmIG5ld1ZOb2RlLiR0YWckID09PSAnZm9yZWlnbk9iamVjdCcpIHtcbiAgICAgICAgICAgIGlzU3ZnTW9kZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCBjc3MgY2xhc3NlcywgYXR0cnMsIHByb3BzLCBsaXN0ZW5lcnMsIGV0Yy5cbiAgICAgICAgaWYgKEJVSUxELnZkb21BdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIHVwZGF0ZUVsZW1lbnQobnVsbCwgbmV3Vk5vZGUsIGlzU3ZnTW9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChCVUlMRC5zaGFkb3dEb20gfHwgQlVJTEQuc2NvcGVkKSAmJiBpc0RlZihzY29wZUlkKSAmJiBlbG1bJ3Mtc2knXSAhPT0gc2NvcGVJZCkge1xuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSBzY29wZUlkIGFuZCB0aGlzIGlzIHRoZSBpbml0aWFsIHJlbmRlclxuICAgICAgICAgICAgLy8gdGhlbiBsZXQncyBhZGQgdGhlIHNjb3BlSWQgYXMgYSBjc3MgY2xhc3NcbiAgICAgICAgICAgIGVsbS5jbGFzc0xpc3QuYWRkKChlbG1bJ3Mtc2knXSA9IHNjb3BlSWQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3Vk5vZGUuJGNoaWxkcmVuJCkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5ld1ZOb2RlLiRjaGlsZHJlbiQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgdGhlIG5vZGVcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGUgPSBjcmVhdGVFbG0ob2xkUGFyZW50Vk5vZGUsIG5ld1ZOb2RlLCBpLCBlbG0pO1xuICAgICAgICAgICAgICAgIC8vIHJldHVybiBub2RlIGNvdWxkIGhhdmUgYmVlbiBudWxsXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBhcHBlbmQgb3VyIG5ldyBub2RlXG4gICAgICAgICAgICAgICAgICAgIGVsbS5hcHBlbmRDaGlsZChjaGlsZE5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQuc3ZnKSB7XG4gICAgICAgICAgICBpZiAobmV3Vk5vZGUuJHRhZyQgPT09ICdzdmcnKSB7XG4gICAgICAgICAgICAgICAgLy8gT25seSByZXNldCB0aGUgU1ZHIGNvbnRleHQgd2hlbiB3ZSdyZSBleGl0aW5nIDxzdmc+IGVsZW1lbnRcbiAgICAgICAgICAgICAgICBpc1N2Z01vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVsbS50YWdOYW1lID09PSAnZm9yZWlnbk9iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAvLyBSZWVudGVyIFNWRyBjb250ZXh0IHdoZW4gd2UncmUgZXhpdGluZyA8Zm9yZWlnbk9iamVjdD4gZWxlbWVudFxuICAgICAgICAgICAgICAgIGlzU3ZnTW9kZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKEJVSUxELnNsb3RSZWxvY2F0aW9uKSB7XG4gICAgICAgIGVsbVsncy1obiddID0gaG9zdFRhZ05hbWU7XG4gICAgICAgIGlmIChuZXdWTm9kZS4kZmxhZ3MkICYgKDIgLyogaXNTbG90RmFsbGJhY2sgKi8gfCAxIC8qIGlzU2xvdFJlZmVyZW5jZSAqLykpIHtcbiAgICAgICAgICAgIC8vIHJlbWVtYmVyIHRoZSBjb250ZW50IHJlZmVyZW5jZSBjb21tZW50XG4gICAgICAgICAgICBlbG1bJ3Mtc3InXSA9IHRydWU7XG4gICAgICAgICAgICAvLyByZW1lbWJlciB0aGUgY29udGVudCByZWZlcmVuY2UgY29tbWVudFxuICAgICAgICAgICAgZWxtWydzLWNyJ10gPSBjb250ZW50UmVmO1xuICAgICAgICAgICAgLy8gcmVtZW1iZXIgdGhlIHNsb3QgbmFtZSwgb3IgZW1wdHkgc3RyaW5nIGZvciBkZWZhdWx0IHNsb3RcbiAgICAgICAgICAgIGVsbVsncy1zbiddID0gbmV3Vk5vZGUuJG5hbWUkIHx8ICcnO1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgd2UndmUgZ290IGFuIG9sZCB2bm9kZSBmb3IgdGhpcyBzbG90XG4gICAgICAgICAgICBvbGRWTm9kZSA9IG9sZFBhcmVudFZOb2RlICYmIG9sZFBhcmVudFZOb2RlLiRjaGlsZHJlbiQgJiYgb2xkUGFyZW50Vk5vZGUuJGNoaWxkcmVuJFtjaGlsZEluZGV4XTtcbiAgICAgICAgICAgIGlmIChvbGRWTm9kZSAmJiBvbGRWTm9kZS4kdGFnJCA9PT0gbmV3Vk5vZGUuJHRhZyQgJiYgb2xkUGFyZW50Vk5vZGUuJGVsbSQpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSd2ZSBnb3QgYW4gb2xkIHNsb3Qgdm5vZGUgYW5kIHRoZSB3cmFwcGVyIGlzIGJlaW5nIHJlcGxhY2VkXG4gICAgICAgICAgICAgICAgLy8gc28gbGV0J3MgbW92ZSB0aGUgb2xkIHNsb3QgY29udGVudCBiYWNrIHRvIGl0J3Mgb3JpZ2luYWwgbG9jYXRpb25cbiAgICAgICAgICAgICAgICBwdXRCYWNrSW5PcmlnaW5hbExvY2F0aW9uKG9sZFBhcmVudFZOb2RlLiRlbG0kLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsbTtcbn07XG5jb25zdCBwdXRCYWNrSW5PcmlnaW5hbExvY2F0aW9uID0gKHBhcmVudEVsbSwgcmVjdXJzaXZlKSA9PiB7XG4gICAgcGx0LiRmbGFncyQgfD0gMSAvKiBpc1RtcERpc2Nvbm5lY3RlZCAqLztcbiAgICBjb25zdCBvbGRTbG90Q2hpbGROb2RlcyA9IHBhcmVudEVsbS5jaGlsZE5vZGVzO1xuICAgIGZvciAobGV0IGkgPSBvbGRTbG90Q2hpbGROb2Rlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBjaGlsZE5vZGUgPSBvbGRTbG90Q2hpbGROb2Rlc1tpXTtcbiAgICAgICAgaWYgKGNoaWxkTm9kZVsncy1obiddICE9PSBob3N0VGFnTmFtZSAmJiBjaGlsZE5vZGVbJ3Mtb2wnXSkge1xuICAgICAgICAgICAgLy8gLy8gdGhpcyBjaGlsZCBub2RlIGluIHRoZSBvbGQgZWxlbWVudCBpcyBmcm9tIGFub3RoZXIgY29tcG9uZW50XG4gICAgICAgICAgICAvLyAvLyByZW1vdmUgdGhpcyBub2RlIGZyb20gdGhlIG9sZCBzbG90J3MgcGFyZW50XG4gICAgICAgICAgICAvLyBjaGlsZE5vZGUucmVtb3ZlKCk7XG4gICAgICAgICAgICAvLyBhbmQgcmVsb2NhdGUgaXQgYmFjayB0byBpdCdzIG9yaWdpbmFsIGxvY2F0aW9uXG4gICAgICAgICAgICBwYXJlbnRSZWZlcmVuY2VOb2RlKGNoaWxkTm9kZSkuaW5zZXJ0QmVmb3JlKGNoaWxkTm9kZSwgcmVmZXJlbmNlTm9kZShjaGlsZE5vZGUpKTtcbiAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgb2xkIG9yaWdpbmFsIGxvY2F0aW9uIGNvbW1lbnQgZW50aXJlbHlcbiAgICAgICAgICAgIC8vIGxhdGVyIG9uIHRoZSBwYXRjaCBmdW5jdGlvbiB3aWxsIGtub3cgd2hhdCB0byBkb1xuICAgICAgICAgICAgLy8gYW5kIG1vdmUgdGhpcyB0byB0aGUgY29ycmVjdCBzcG90IGluIG5lZWQgYmVcbiAgICAgICAgICAgIGNoaWxkTm9kZVsncy1vbCddLnJlbW92ZSgpO1xuICAgICAgICAgICAgY2hpbGROb2RlWydzLW9sJ10gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjaGVja1Nsb3RSZWxvY2F0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlY3Vyc2l2ZSkge1xuICAgICAgICAgICAgcHV0QmFja0luT3JpZ2luYWxMb2NhdGlvbihjaGlsZE5vZGUsIHJlY3Vyc2l2ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGx0LiRmbGFncyQgJj0gfjEgLyogaXNUbXBEaXNjb25uZWN0ZWQgKi87XG59O1xuY29uc3QgYWRkVm5vZGVzID0gKHBhcmVudEVsbSwgYmVmb3JlLCBwYXJlbnRWTm9kZSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4KSA9PiB7XG4gICAgbGV0IGNvbnRhaW5lckVsbSA9ICgoQlVJTEQuc2xvdFJlbG9jYXRpb24gJiYgcGFyZW50RWxtWydzLWNyJ10gJiYgcGFyZW50RWxtWydzLWNyJ10ucGFyZW50Tm9kZSkgfHwgcGFyZW50RWxtKTtcbiAgICBsZXQgY2hpbGROb2RlO1xuICAgIGlmIChCVUlMRC5zaGFkb3dEb20gJiYgY29udGFpbmVyRWxtLnNoYWRvd1Jvb3QgJiYgY29udGFpbmVyRWxtLnRhZ05hbWUgPT09IGhvc3RUYWdOYW1lKSB7XG4gICAgICAgIGNvbnRhaW5lckVsbSA9IGNvbnRhaW5lckVsbS5zaGFkb3dSb290O1xuICAgIH1cbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICAgIGlmICh2bm9kZXNbc3RhcnRJZHhdKSB7XG4gICAgICAgICAgICBjaGlsZE5vZGUgPSBjcmVhdGVFbG0obnVsbCwgcGFyZW50Vk5vZGUsIHN0YXJ0SWR4LCBwYXJlbnRFbG0pO1xuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAgIHZub2Rlc1tzdGFydElkeF0uJGVsbSQgPSBjaGlsZE5vZGU7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyRWxtLmluc2VydEJlZm9yZShjaGlsZE5vZGUsIEJVSUxELnNsb3RSZWxvY2F0aW9uID8gcmVmZXJlbmNlTm9kZShiZWZvcmUpIDogYmVmb3JlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCByZW1vdmVWbm9kZXMgPSAodm5vZGVzLCBzdGFydElkeCwgZW5kSWR4LCB2bm9kZSwgZWxtKSA9PiB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgICBpZiAoKHZub2RlID0gdm5vZGVzW3N0YXJ0SWR4XSkpIHtcbiAgICAgICAgICAgIGVsbSA9IHZub2RlLiRlbG0kO1xuICAgICAgICAgICAgY2FsbE5vZGVSZWZzKHZub2RlKTtcbiAgICAgICAgICAgIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIHdlJ3JlIHJlbW92aW5nIHRoaXMgZWxlbWVudFxuICAgICAgICAgICAgICAgIC8vIHNvIGl0J3MgcG9zc2libGUgd2UgbmVlZCB0byBzaG93IHNsb3QgZmFsbGJhY2sgY29udGVudCBub3dcbiAgICAgICAgICAgICAgICBjaGVja1Nsb3RGYWxsYmFja1Zpc2liaWxpdHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChlbG1bJ3Mtb2wnXSkge1xuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIG9yaWdpbmFsIGxvY2F0aW9uIGNvbW1lbnRcbiAgICAgICAgICAgICAgICAgICAgZWxtWydzLW9sJ10ucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBpdCdzIHBvc3NpYmxlIHRoYXQgY2hpbGQgbm9kZXMgb2YgdGhlIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCdzIGJlaW5nIHJlbW92ZWQgYXJlIHNsb3Qgbm9kZXNcbiAgICAgICAgICAgICAgICAgICAgcHV0QmFja0luT3JpZ2luYWxMb2NhdGlvbihlbG0sIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgdm5vZGUncyBlbGVtZW50IGZyb20gdGhlIGRvbVxuICAgICAgICAgICAgZWxtLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IHVwZGF0ZUNoaWxkcmVuID0gKHBhcmVudEVsbSwgb2xkQ2gsIG5ld1ZOb2RlLCBuZXdDaCkgPT4ge1xuICAgIGxldCBvbGRTdGFydElkeCA9IDA7XG4gICAgbGV0IG5ld1N0YXJ0SWR4ID0gMDtcbiAgICBsZXQgaWR4SW5PbGQgPSAwO1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcbiAgICBsZXQgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICAgIGxldCBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgbGV0IG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XG4gICAgbGV0IG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgICBsZXQgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgIGxldCBub2RlO1xuICAgIGxldCBlbG1Ub01vdmU7XG4gICAgd2hpbGUgKG9sZFN0YXJ0SWR4IDw9IG9sZEVuZElkeCAmJiBuZXdTdGFydElkeCA8PSBuZXdFbmRJZHgpIHtcbiAgICAgICAgaWYgKG9sZFN0YXJ0Vm5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVm5vZGUgbWlnaHQgaGF2ZSBiZWVuIG1vdmVkIGxlZnRcbiAgICAgICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvbGRFbmRWbm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuZXdTdGFydFZub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuZXdFbmRWbm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1NhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICAgICAgcGF0Y2gob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSk7XG4gICAgICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNTYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlKSkge1xuICAgICAgICAgICAgcGF0Y2gob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlKTtcbiAgICAgICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNTYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG4gICAgICAgICAgICAvLyBWbm9kZSBtb3ZlZCByaWdodFxuICAgICAgICAgICAgaWYgKEJVSUxELnNsb3RSZWxvY2F0aW9uICYmIChvbGRTdGFydFZub2RlLiR0YWckID09PSAnc2xvdCcgfHwgbmV3RW5kVm5vZGUuJHRhZyQgPT09ICdzbG90JykpIHtcbiAgICAgICAgICAgICAgICBwdXRCYWNrSW5PcmlnaW5hbExvY2F0aW9uKG9sZFN0YXJ0Vm5vZGUuJGVsbSQucGFyZW50Tm9kZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF0Y2gob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUpO1xuICAgICAgICAgICAgcGFyZW50RWxtLmluc2VydEJlZm9yZShvbGRTdGFydFZub2RlLiRlbG0kLCBvbGRFbmRWbm9kZS4kZWxtJC5uZXh0U2libGluZyk7XG4gICAgICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1NhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgIC8vIFZub2RlIG1vdmVkIGxlZnRcbiAgICAgICAgICAgIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbiAmJiAob2xkU3RhcnRWbm9kZS4kdGFnJCA9PT0gJ3Nsb3QnIHx8IG5ld0VuZFZub2RlLiR0YWckID09PSAnc2xvdCcpKSB7XG4gICAgICAgICAgICAgICAgcHV0QmFja0luT3JpZ2luYWxMb2NhdGlvbihvbGRFbmRWbm9kZS4kZWxtJC5wYXJlbnROb2RlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXRjaChvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSk7XG4gICAgICAgICAgICBwYXJlbnRFbG0uaW5zZXJ0QmVmb3JlKG9sZEVuZFZub2RlLiRlbG0kLCBvbGRTdGFydFZub2RlLiRlbG0kKTtcbiAgICAgICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gY3JlYXRlS2V5VG9PbGRJZHhcbiAgICAgICAgICAgIGlkeEluT2xkID0gLTE7XG4gICAgICAgICAgICBpZiAoQlVJTEQudmRvbUtleSkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IG9sZFN0YXJ0SWR4OyBpIDw9IG9sZEVuZElkeDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRDaFtpXSAmJiBvbGRDaFtpXS4ka2V5JCAhPT0gbnVsbCAmJiBvbGRDaFtpXS4ka2V5JCA9PT0gbmV3U3RhcnRWbm9kZS4ka2V5JCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWR4SW5PbGQgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQlVJTEQudmRvbUtleSAmJiBpZHhJbk9sZCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgZWxtVG9Nb3ZlID0gb2xkQ2hbaWR4SW5PbGRdO1xuICAgICAgICAgICAgICAgIGlmIChlbG1Ub01vdmUuJHRhZyQgIT09IG5ld1N0YXJ0Vm5vZGUuJHRhZyQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGNyZWF0ZUVsbShvbGRDaCAmJiBvbGRDaFtuZXdTdGFydElkeF0sIG5ld1ZOb2RlLCBpZHhJbk9sZCwgcGFyZW50RWxtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGNoKGVsbVRvTW92ZSwgbmV3U3RhcnRWbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIG9sZENoW2lkeEluT2xkXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGVsbVRvTW92ZS4kZWxtJDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbmV3IGVsZW1lbnRcbiAgICAgICAgICAgICAgICBub2RlID0gY3JlYXRlRWxtKG9sZENoICYmIG9sZENoW25ld1N0YXJ0SWR4XSwgbmV3Vk5vZGUsIG5ld1N0YXJ0SWR4LCBwYXJlbnRFbG0pO1xuICAgICAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKEJVSUxELnNsb3RSZWxvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudFJlZmVyZW5jZU5vZGUob2xkU3RhcnRWbm9kZS4kZWxtJCkuaW5zZXJ0QmVmb3JlKG5vZGUsIHJlZmVyZW5jZU5vZGUob2xkU3RhcnRWbm9kZS4kZWxtJCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkU3RhcnRWbm9kZS4kZWxtJC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCBvbGRTdGFydFZub2RlLiRlbG0kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9sZFN0YXJ0SWR4ID4gb2xkRW5kSWR4KSB7XG4gICAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIG5ld0NoW25ld0VuZElkeCArIDFdID09IG51bGwgPyBudWxsIDogbmV3Q2hbbmV3RW5kSWR4ICsgMV0uJGVsbSQsIG5ld1ZOb2RlLCBuZXdDaCwgbmV3U3RhcnRJZHgsIG5ld0VuZElkeCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKEJVSUxELnVwZGF0YWJsZSAmJiBuZXdTdGFydElkeCA+IG5ld0VuZElkeCkge1xuICAgICAgICByZW1vdmVWbm9kZXMob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgIH1cbn07XG5jb25zdCBpc1NhbWVWbm9kZSA9ICh2bm9kZTEsIHZub2RlMikgPT4ge1xuICAgIC8vIGNvbXBhcmUgaWYgdHdvIHZub2RlIHRvIHNlZSBpZiB0aGV5J3JlIFwidGVjaG5pY2FsbHlcIiB0aGUgc2FtZVxuICAgIC8vIG5lZWQgdG8gaGF2ZSB0aGUgc2FtZSBlbGVtZW50IHRhZywgYW5kIHNhbWUga2V5IHRvIGJlIHRoZSBzYW1lXG4gICAgaWYgKHZub2RlMS4kdGFnJCA9PT0gdm5vZGUyLiR0YWckKSB7XG4gICAgICAgIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbiAmJiB2bm9kZTEuJHRhZyQgPT09ICdzbG90Jykge1xuICAgICAgICAgICAgcmV0dXJuIHZub2RlMS4kbmFtZSQgPT09IHZub2RlMi4kbmFtZSQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJVSUxELnZkb21LZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB2bm9kZTEuJGtleSQgPT09IHZub2RlMi4ka2V5JDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmNvbnN0IHJlZmVyZW5jZU5vZGUgPSAobm9kZSkgPT4ge1xuICAgIC8vIHRoaXMgbm9kZSB3YXMgcmVsb2NhdGVkIHRvIGEgbmV3IGxvY2F0aW9uIGluIHRoZSBkb21cbiAgICAvLyBiZWNhdXNlIG9mIHNvbWUgb3RoZXIgY29tcG9uZW50J3Mgc2xvdFxuICAgIC8vIGJ1dCB3ZSBzdGlsbCBoYXZlIGFuIGh0bWwgY29tbWVudCBpbiBwbGFjZSBvZiB3aGVyZVxuICAgIC8vIGl0J3Mgb3JpZ2luYWwgbG9jYXRpb24gd2FzIGFjY29yZGluZyB0byBpdCdzIG9yaWdpbmFsIHZkb21cbiAgICByZXR1cm4gKG5vZGUgJiYgbm9kZVsncy1vbCddKSB8fCBub2RlO1xufTtcbmNvbnN0IHBhcmVudFJlZmVyZW5jZU5vZGUgPSAobm9kZSkgPT4gKG5vZGVbJ3Mtb2wnXSA/IG5vZGVbJ3Mtb2wnXSA6IG5vZGUpLnBhcmVudE5vZGU7XG5jb25zdCBwYXRjaCA9IChvbGRWTm9kZSwgbmV3Vk5vZGUpID0+IHtcbiAgICBjb25zdCBlbG0gPSAobmV3Vk5vZGUuJGVsbSQgPSBvbGRWTm9kZS4kZWxtJCk7XG4gICAgY29uc3Qgb2xkQ2hpbGRyZW4gPSBvbGRWTm9kZS4kY2hpbGRyZW4kO1xuICAgIGNvbnN0IG5ld0NoaWxkcmVuID0gbmV3Vk5vZGUuJGNoaWxkcmVuJDtcbiAgICBjb25zdCB0YWcgPSBuZXdWTm9kZS4kdGFnJDtcbiAgICBjb25zdCB0ZXh0ID0gbmV3Vk5vZGUuJHRleHQkO1xuICAgIGxldCBkZWZhdWx0SG9sZGVyO1xuICAgIGlmICghQlVJTEQudmRvbVRleHQgfHwgdGV4dCA9PT0gbnVsbCkge1xuICAgICAgICBpZiAoQlVJTEQuc3ZnKSB7XG4gICAgICAgICAgICAvLyB0ZXN0IGlmIHdlJ3JlIHJlbmRlcmluZyBhbiBzdmcgZWxlbWVudCwgb3Igc3RpbGwgcmVuZGVyaW5nIG5vZGVzIGluc2lkZSBvZiBvbmVcbiAgICAgICAgICAgIC8vIG9ubHkgYWRkIHRoaXMgdG8gdGhlIHdoZW4gdGhlIGNvbXBpbGVyIHNlZXMgd2UncmUgdXNpbmcgYW4gc3ZnIHNvbWV3aGVyZVxuICAgICAgICAgICAgaXNTdmdNb2RlID0gdGFnID09PSAnc3ZnJyA/IHRydWUgOiB0YWcgPT09ICdmb3JlaWduT2JqZWN0JyA/IGZhbHNlIDogaXNTdmdNb2RlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVsZW1lbnQgbm9kZVxuICAgICAgICBpZiAoQlVJTEQudmRvbUF0dHJpYnV0ZSB8fCBCVUlMRC5yZWZsZWN0KSB7XG4gICAgICAgICAgICBpZiAoQlVJTEQuc2xvdCAmJiB0YWcgPT09ICdzbG90JylcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBlaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgcmVuZGVyIG9mIGFuIGVsZW1lbnQgT1IgaXQncyBhbiB1cGRhdGVcbiAgICAgICAgICAgICAgICAvLyBBTkQgd2UgYWxyZWFkeSBrbm93IGl0J3MgcG9zc2libGUgaXQgY291bGQgaGF2ZSBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgLy8gdGhpcyB1cGRhdGVzIHRoZSBlbGVtZW50J3MgY3NzIGNsYXNzZXMsIGF0dHJzLCBwcm9wcywgbGlzdGVuZXJzLCBldGMuXG4gICAgICAgICAgICAgICAgdXBkYXRlRWxlbWVudChvbGRWTm9kZSwgbmV3Vk5vZGUsIGlzU3ZnTW9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJVSUxELnVwZGF0YWJsZSAmJiBvbGRDaGlsZHJlbiAhPT0gbnVsbCAmJiBuZXdDaGlsZHJlbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gbG9va3MgbGlrZSB0aGVyZSdzIGNoaWxkIHZub2RlcyBmb3IgYm90aCB0aGUgb2xkIGFuZCBuZXcgdm5vZGVzXG4gICAgICAgICAgICB1cGRhdGVDaGlsZHJlbihlbG0sIG9sZENoaWxkcmVuLCBuZXdWTm9kZSwgbmV3Q2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5ld0NoaWxkcmVuICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBubyBvbGQgY2hpbGQgdm5vZGVzLCBidXQgdGhlcmUgYXJlIG5ldyBjaGlsZCB2bm9kZXMgdG8gYWRkXG4gICAgICAgICAgICBpZiAoQlVJTEQudXBkYXRhYmxlICYmIEJVSUxELnZkb21UZXh0ICYmIG9sZFZOb2RlLiR0ZXh0JCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIHRoZSBvbGQgdm5vZGUgd2FzIHRleHQsIHNvIGJlIHN1cmUgdG8gY2xlYXIgaXQgb3V0XG4gICAgICAgICAgICAgICAgZWxtLnRleHRDb250ZW50ID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhZGQgdGhlIG5ldyB2bm9kZSBjaGlsZHJlblxuICAgICAgICAgICAgYWRkVm5vZGVzKGVsbSwgbnVsbCwgbmV3Vk5vZGUsIG5ld0NoaWxkcmVuLCAwLCBuZXdDaGlsZHJlbi5sZW5ndGggLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChCVUlMRC51cGRhdGFibGUgJiYgb2xkQ2hpbGRyZW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG5vIG5ldyBjaGlsZCB2bm9kZXMsIGJ1dCB0aGVyZSBhcmUgb2xkIGNoaWxkIHZub2RlcyB0byByZW1vdmVcbiAgICAgICAgICAgIHJlbW92ZVZub2RlcyhvbGRDaGlsZHJlbiwgMCwgb2xkQ2hpbGRyZW4ubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJVSUxELnN2ZyAmJiBpc1N2Z01vZGUgJiYgdGFnID09PSAnc3ZnJykge1xuICAgICAgICAgICAgaXNTdmdNb2RlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoQlVJTEQudmRvbVRleHQgJiYgQlVJTEQuc2xvdFJlbG9jYXRpb24gJiYgKGRlZmF1bHRIb2xkZXIgPSBlbG1bJ3MtY3InXSkpIHtcbiAgICAgICAgLy8gdGhpcyBlbGVtZW50IGhhcyBzbG90dGVkIGNvbnRlbnRcbiAgICAgICAgZGVmYXVsdEhvbGRlci5wYXJlbnROb2RlLnRleHRDb250ZW50ID0gdGV4dDtcbiAgICB9XG4gICAgZWxzZSBpZiAoQlVJTEQudmRvbVRleHQgJiYgb2xkVk5vZGUuJHRleHQkICE9PSB0ZXh0KSB7XG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgdGV4dCBjb250ZW50IGZvciB0aGUgdGV4dCBvbmx5IHZub2RlXG4gICAgICAgIC8vIGFuZCBhbHNvIG9ubHkgaWYgdGhlIHRleHQgaXMgZGlmZmVyZW50IHRoYW4gYmVmb3JlXG4gICAgICAgIGVsbS5kYXRhID0gdGV4dDtcbiAgICB9XG59O1xuY29uc3QgdXBkYXRlRmFsbGJhY2tTbG90VmlzaWJpbGl0eSA9IChlbG0pID0+IHtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IHByZWZlci1jb25zdFxuICAgIGxldCBjaGlsZE5vZGVzID0gZWxtLmNoaWxkTm9kZXM7XG4gICAgbGV0IGNoaWxkTm9kZTtcbiAgICBsZXQgaTtcbiAgICBsZXQgaWxlbjtcbiAgICBsZXQgajtcbiAgICBsZXQgc2xvdE5hbWVBdHRyO1xuICAgIGxldCBub2RlVHlwZTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgaWYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gMSAvKiBFbGVtZW50Tm9kZSAqLykge1xuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZVsncy1zciddKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBhIHNsb3QgZmFsbGJhY2sgbm9kZVxuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgc2xvdCBuYW1lIGZvciB0aGlzIHNsb3QgcmVmZXJlbmNlIG5vZGVcbiAgICAgICAgICAgICAgICBzbG90TmFtZUF0dHIgPSBjaGlsZE5vZGVbJ3Mtc24nXTtcbiAgICAgICAgICAgICAgICAvLyBieSBkZWZhdWx0IGFsd2F5cyBzaG93IGEgZmFsbGJhY2sgc2xvdCBub2RlXG4gICAgICAgICAgICAgICAgLy8gdGhlbiBoaWRlIGl0IGlmIHRoZXJlIGFyZSBvdGhlciBzbG90cyBpbiB0aGUgbGlnaHQgZG9tXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBpbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZVR5cGUgPSBjaGlsZE5vZGVzW2pdLm5vZGVUeXBlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2Rlc1tqXVsncy1obiddICE9PSBjaGlsZE5vZGVbJ3MtaG4nXSB8fCBzbG90TmFtZUF0dHIgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHNpYmxpbmcgbm9kZSBpcyBmcm9tIGEgZGlmZmVyZW50IGNvbXBvbmVudCBPUiBpcyBhIG5hbWVkIGZhbGxiYWNrIHNsb3Qgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVUeXBlID09PSAxIC8qIEVsZW1lbnROb2RlICovICYmIHNsb3ROYW1lQXR0ciA9PT0gY2hpbGROb2Rlc1tqXS5nZXRBdHRyaWJ1dGUoJ3Nsb3QnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZS5oaWRkZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBhIGRlZmF1bHQgZmFsbGJhY2sgc2xvdCBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbnkgZWxlbWVudCBvciB0ZXh0IG5vZGUgKHdpdGggY29udGVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNob3VsZCBoaWRlIHRoZSBkZWZhdWx0IGZhbGxiYWNrIHNsb3Qgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVUeXBlID09PSAxIC8qIEVsZW1lbnROb2RlICovIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG5vZGVUeXBlID09PSAzIC8qIFRleHROb2RlICovICYmIGNoaWxkTm9kZXNbal0udGV4dENvbnRlbnQudHJpbSgpICE9PSAnJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGUuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGtlZXAgZHJpbGxpbmcgZG93blxuICAgICAgICAgICAgdXBkYXRlRmFsbGJhY2tTbG90VmlzaWJpbGl0eShjaGlsZE5vZGUpO1xuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IHJlbG9jYXRlTm9kZXMgPSBbXTtcbmNvbnN0IHJlbG9jYXRlU2xvdENvbnRlbnQgPSAoZWxtKSA9PiB7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBwcmVmZXItY29uc3RcbiAgICBsZXQgY2hpbGROb2RlO1xuICAgIGxldCBub2RlO1xuICAgIGxldCBob3N0Q29udGVudE5vZGVzO1xuICAgIGxldCBzbG90TmFtZUF0dHI7XG4gICAgbGV0IHJlbG9jYXRlTm9kZURhdGE7XG4gICAgbGV0IGo7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBjaGlsZE5vZGVzID0gZWxtLmNoaWxkTm9kZXM7XG4gICAgbGV0IGlsZW4gPSBjaGlsZE5vZGVzLmxlbmd0aDtcbiAgICBmb3IgKDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzW2ldO1xuICAgICAgICBpZiAoY2hpbGROb2RlWydzLXNyJ10gJiYgKG5vZGUgPSBjaGlsZE5vZGVbJ3MtY3InXSkgJiYgbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAvLyBmaXJzdCBnb3QgdGhlIGNvbnRlbnQgcmVmZXJlbmNlIGNvbW1lbnQgbm9kZVxuICAgICAgICAgICAgLy8gdGhlbiB3ZSBnb3QgaXQncyBwYXJlbnQsIHdoaWNoIGlzIHdoZXJlIGFsbCB0aGUgaG9zdCBjb250ZW50IGlzIGluIG5vd1xuICAgICAgICAgICAgaG9zdENvbnRlbnROb2RlcyA9IG5vZGUucGFyZW50Tm9kZS5jaGlsZE5vZGVzO1xuICAgICAgICAgICAgc2xvdE5hbWVBdHRyID0gY2hpbGROb2RlWydzLXNuJ107XG4gICAgICAgICAgICBmb3IgKGogPSBob3N0Q29udGVudE5vZGVzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IGhvc3RDb250ZW50Tm9kZXNbal07XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlWydzLWNuJ10gJiYgIW5vZGVbJ3MtbnInXSAmJiBub2RlWydzLWhuJ10gIT09IGNoaWxkTm9kZVsncy1obiddKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGxldCdzIGRvIHNvbWUgcmVsb2NhdGluZyB0byBpdHMgbmV3IGhvbWVcbiAgICAgICAgICAgICAgICAgICAgLy8gYnV0IG5ldmVyIHJlbG9jYXRlIGEgY29udGVudCByZWZlcmVuY2Ugbm9kZVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGF0IGlzIHN1cHBvc2UgdG8gYWx3YXlzIHJlcHJlc2VudCB0aGUgb3JpZ2luYWwgY29udGVudCBsb2NhdGlvblxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOb2RlTG9jYXRlZEluU2xvdChub2RlLCBzbG90TmFtZUF0dHIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCdzIHBvc3NpYmxlIHdlJ3ZlIGFscmVhZHkgZGVjaWRlZCB0byByZWxvY2F0ZSB0aGlzIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbG9jYXRlTm9kZURhdGEgPSByZWxvY2F0ZU5vZGVzLmZpbmQociA9PiByLiRub2RlVG9SZWxvY2F0ZSQgPT09IG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFkZSBzb21lIGNoYW5nZXMgdG8gc2xvdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxldCdzIG1ha2Ugc3VyZSB3ZSBhbHNvIGRvdWJsZSBjaGVja1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmFsbGJhY2tzIGFyZSBjb3JyZWN0bHkgaGlkZGVuIG9yIHNob3duXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja1Nsb3RGYWxsYmFja1Zpc2liaWxpdHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVsncy1zbiddID0gbm9kZVsncy1zbiddIHx8IHNsb3ROYW1lQXR0cjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWxvY2F0ZU5vZGVEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJldmlvdXNseSB3ZSBuZXZlciBmb3VuZCBhIHNsb3QgaG9tZSBmb3IgdGhpcyBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IHR1cm5zIG91dCB3ZSBkaWQsIHNvIGxldCdzIHJlbWVtYmVyIGl0IG5vd1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbG9jYXRlTm9kZURhdGEuJHNsb3RSZWZOb2RlJCA9IGNoaWxkTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCB0byBvdXIgbGlzdCBvZiBub2RlcyB0byByZWxvY2F0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbG9jYXRlTm9kZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzbG90UmVmTm9kZSQ6IGNoaWxkTm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJG5vZGVUb1JlbG9jYXRlJDogbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlWydzLXNyJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxvY2F0ZU5vZGVzLm1hcChyZWxvY2F0ZU5vZGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOb2RlTG9jYXRlZEluU2xvdChyZWxvY2F0ZU5vZGUuJG5vZGVUb1JlbG9jYXRlJCwgbm9kZVsncy1zbiddKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsb2NhdGVOb2RlRGF0YSA9IHJlbG9jYXRlTm9kZXMuZmluZChyID0+IHIuJG5vZGVUb1JlbG9jYXRlJCA9PT0gbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVsb2NhdGVOb2RlRGF0YSAmJiAhcmVsb2NhdGVOb2RlLiRzbG90UmVmTm9kZSQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxvY2F0ZU5vZGUuJHNsb3RSZWZOb2RlJCA9IHJlbG9jYXRlTm9kZURhdGEuJHNsb3RSZWZOb2RlJDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFyZWxvY2F0ZU5vZGVzLnNvbWUociA9PiByLiRub2RlVG9SZWxvY2F0ZSQgPT09IG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyBmYXIgdGhpcyBlbGVtZW50IGRvZXMgbm90IGhhdmUgYSBzbG90IGhvbWUsIG5vdCBzZXR0aW5nIHNsb3RSZWZOb2RlIG9uIHB1cnBvc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIG5ldmVyIGZpbmQgYSBob21lIGZvciB0aGlzIGVsZW1lbnQgdGhlbiB3ZSdsbCBuZWVkIHRvIGhpZGUgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbG9jYXRlTm9kZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJG5vZGVUb1JlbG9jYXRlJDogbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZE5vZGUubm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8pIHtcbiAgICAgICAgICAgIHJlbG9jYXRlU2xvdENvbnRlbnQoY2hpbGROb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBpc05vZGVMb2NhdGVkSW5TbG90ID0gKG5vZGVUb1JlbG9jYXRlLCBzbG90TmFtZUF0dHIpID0+IHtcbiAgICBpZiAobm9kZVRvUmVsb2NhdGUubm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8pIHtcbiAgICAgICAgaWYgKG5vZGVUb1JlbG9jYXRlLmdldEF0dHJpYnV0ZSgnc2xvdCcpID09PSBudWxsICYmIHNsb3ROYW1lQXR0ciA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlVG9SZWxvY2F0ZS5nZXRBdHRyaWJ1dGUoJ3Nsb3QnKSA9PT0gc2xvdE5hbWVBdHRyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChub2RlVG9SZWxvY2F0ZVsncy1zbiddID09PSBzbG90TmFtZUF0dHIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBzbG90TmFtZUF0dHIgPT09ICcnO1xufTtcbmNvbnN0IGNhbGxOb2RlUmVmcyA9ICh2Tm9kZSkgPT4ge1xuICAgIGlmIChCVUlMRC52ZG9tUmVmKSB7XG4gICAgICAgIHZOb2RlLiRhdHRycyQgJiYgdk5vZGUuJGF0dHJzJC5yZWYgJiYgdk5vZGUuJGF0dHJzJC5yZWYobnVsbCk7XG4gICAgICAgIHZOb2RlLiRjaGlsZHJlbiQgJiYgdk5vZGUuJGNoaWxkcmVuJC5tYXAoY2FsbE5vZGVSZWZzKTtcbiAgICB9XG59O1xuY29uc3QgcmVuZGVyVmRvbSA9IChob3N0UmVmLCByZW5kZXJGblJlc3VsdHMpID0+IHtcbiAgICBjb25zdCBob3N0RWxtID0gaG9zdFJlZi4kaG9zdEVsZW1lbnQkO1xuICAgIGNvbnN0IGNtcE1ldGEgPSBob3N0UmVmLiRjbXBNZXRhJDtcbiAgICBjb25zdCBvbGRWTm9kZSA9IGhvc3RSZWYuJHZub2RlJCB8fCBuZXdWTm9kZShudWxsLCBudWxsKTtcbiAgICBjb25zdCByb290Vm5vZGUgPSBpc0hvc3QocmVuZGVyRm5SZXN1bHRzKSA/IHJlbmRlckZuUmVzdWx0cyA6IGgobnVsbCwgbnVsbCwgcmVuZGVyRm5SZXN1bHRzKTtcbiAgICBob3N0VGFnTmFtZSA9IGhvc3RFbG0udGFnTmFtZTtcbiAgICAvLyA8SG9zdD4gcnVudGltZSBjaGVja1xuICAgIGlmIChCVUlMRC5pc0RldiAmJiBBcnJheS5pc0FycmF5KHJlbmRlckZuUmVzdWx0cykgJiYgcmVuZGVyRm5SZXN1bHRzLnNvbWUoaXNIb3N0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSA8SG9zdD4gbXVzdCBiZSB0aGUgc2luZ2xlIHJvb3QgY29tcG9uZW50LlxuTG9va3MgbGlrZSB0aGUgcmVuZGVyKCkgZnVuY3Rpb24gb2YgXCIke2hvc3RUYWdOYW1lLnRvTG93ZXJDYXNlKCl9XCIgaXMgcmV0dXJuaW5nIGFuIGFycmF5IHRoYXQgY29udGFpbnMgdGhlIDxIb3N0Pi5cblxuVGhlIHJlbmRlcigpIGZ1bmN0aW9uIHNob3VsZCBsb29rIGxpa2UgdGhpcyBpbnN0ZWFkOlxuXG5yZW5kZXIoKSB7XG4gIC8vIERvIG5vdCByZXR1cm4gYW4gYXJyYXlcbiAgcmV0dXJuIChcbiAgICA8SG9zdD57Y29udGVudH08L0hvc3Q+XG4gICk7XG59XG4gIGApO1xuICAgIH1cbiAgICBpZiAoQlVJTEQucmVmbGVjdCAmJiBjbXBNZXRhLiRhdHRyc1RvUmVmbGVjdCQpIHtcbiAgICAgICAgcm9vdFZub2RlLiRhdHRycyQgPSByb290Vm5vZGUuJGF0dHJzJCB8fCB7fTtcbiAgICAgICAgY21wTWV0YS4kYXR0cnNUb1JlZmxlY3QkLm1hcCgoW3Byb3BOYW1lLCBhdHRyaWJ1dGVdKSA9PiAocm9vdFZub2RlLiRhdHRycyRbYXR0cmlidXRlXSA9IGhvc3RFbG1bcHJvcE5hbWVdKSk7XG4gICAgfVxuICAgIHJvb3RWbm9kZS4kdGFnJCA9IG51bGw7XG4gICAgcm9vdFZub2RlLiRmbGFncyQgfD0gNCAvKiBpc0hvc3QgKi87XG4gICAgaG9zdFJlZi4kdm5vZGUkID0gcm9vdFZub2RlO1xuICAgIHJvb3RWbm9kZS4kZWxtJCA9IG9sZFZOb2RlLiRlbG0kID0gKEJVSUxELnNoYWRvd0RvbSA/IGhvc3RFbG0uc2hhZG93Um9vdCB8fCBob3N0RWxtIDogaG9zdEVsbSk7XG4gICAgaWYgKEJVSUxELnNjb3BlZCB8fCBCVUlMRC5zaGFkb3dEb20pIHtcbiAgICAgICAgc2NvcGVJZCA9IGhvc3RFbG1bJ3Mtc2MnXTtcbiAgICB9XG4gICAgaWYgKEJVSUxELnNsb3RSZWxvY2F0aW9uKSB7XG4gICAgICAgIGNvbnRlbnRSZWYgPSBob3N0RWxtWydzLWNyJ107XG4gICAgICAgIHVzZU5hdGl2ZVNoYWRvd0RvbSA9IHN1cHBvcnRzU2hhZG93ICYmIChjbXBNZXRhLiRmbGFncyQgJiAxIC8qIHNoYWRvd0RvbUVuY2Fwc3VsYXRpb24gKi8pICE9PSAwO1xuICAgICAgICAvLyBhbHdheXMgcmVzZXRcbiAgICAgICAgY2hlY2tTbG90RmFsbGJhY2tWaXNpYmlsaXR5ID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIHN5bmNocm9ub3VzIHBhdGNoXG4gICAgcGF0Y2gob2xkVk5vZGUsIHJvb3RWbm9kZSk7XG4gICAgaWYgKEJVSUxELnNsb3RSZWxvY2F0aW9uKSB7XG4gICAgICAgIC8vIHdoaWxlIHdlJ3JlIG1vdmluZyBub2RlcyBhcm91bmQgZXhpc3Rpbmcgbm9kZXMsIHRlbXBvcmFyaWx5IGRpc2FibGVcbiAgICAgICAgLy8gdGhlIGRpc2Nvbm5lY3RDYWxsYmFjayBmcm9tIHdvcmtpbmdcbiAgICAgICAgcGx0LiRmbGFncyQgfD0gMSAvKiBpc1RtcERpc2Nvbm5lY3RlZCAqLztcbiAgICAgICAgaWYgKGNoZWNrU2xvdFJlbG9jYXRlKSB7XG4gICAgICAgICAgICByZWxvY2F0ZVNsb3RDb250ZW50KHJvb3RWbm9kZS4kZWxtJCk7XG4gICAgICAgICAgICBsZXQgcmVsb2NhdGVEYXRhO1xuICAgICAgICAgICAgbGV0IG5vZGVUb1JlbG9jYXRlO1xuICAgICAgICAgICAgbGV0IG9yZ0xvY2F0aW9uTm9kZTtcbiAgICAgICAgICAgIGxldCBwYXJlbnROb2RlUmVmO1xuICAgICAgICAgICAgbGV0IGluc2VydEJlZm9yZU5vZGU7XG4gICAgICAgICAgICBsZXQgcmVmTm9kZTtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgcmVsb2NhdGVOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlbG9jYXRlRGF0YSA9IHJlbG9jYXRlTm9kZXNbaV07XG4gICAgICAgICAgICAgICAgbm9kZVRvUmVsb2NhdGUgPSByZWxvY2F0ZURhdGEuJG5vZGVUb1JlbG9jYXRlJDtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGVUb1JlbG9jYXRlWydzLW9sJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGEgcmVmZXJlbmNlIG5vZGUgbWFya2luZyB0aGlzIG5vZGUncyBvcmlnaW5hbCBsb2NhdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoaXMgbm9kZSBmb3IgbGF0ZXIgbG9va3Vwc1xuICAgICAgICAgICAgICAgICAgICBvcmdMb2NhdGlvbk5vZGUgPSBCVUlMRC5pc0RlYnVnIHx8IEJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlID8gb3JpZ2luYWxMb2NhdGlvbkRlYnVnTm9kZShub2RlVG9SZWxvY2F0ZSkgOiBkb2MuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgICAgICAgICAgICAgICAgICBvcmdMb2NhdGlvbk5vZGVbJ3MtbnInXSA9IG5vZGVUb1JlbG9jYXRlO1xuICAgICAgICAgICAgICAgICAgICBub2RlVG9SZWxvY2F0ZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSgobm9kZVRvUmVsb2NhdGVbJ3Mtb2wnXSA9IG9yZ0xvY2F0aW9uTm9kZSksIG5vZGVUb1JlbG9jYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmVsb2NhdGVOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlbG9jYXRlRGF0YSA9IHJlbG9jYXRlTm9kZXNbaV07XG4gICAgICAgICAgICAgICAgbm9kZVRvUmVsb2NhdGUgPSByZWxvY2F0ZURhdGEuJG5vZGVUb1JlbG9jYXRlJDtcbiAgICAgICAgICAgICAgICBpZiAocmVsb2NhdGVEYXRhLiRzbG90UmVmTm9kZSQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYnkgZGVmYXVsdCB3ZSdyZSBqdXN0IGdvaW5nIHRvIGluc2VydCBpdCBkaXJlY3RseVxuICAgICAgICAgICAgICAgICAgICAvLyBhZnRlciB0aGUgc2xvdCByZWZlcmVuY2Ugbm9kZVxuICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlUmVmID0gcmVsb2NhdGVEYXRhLiRzbG90UmVmTm9kZSQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0QmVmb3JlTm9kZSA9IHJlbG9jYXRlRGF0YS4kc2xvdFJlZk5vZGUkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICBvcmdMb2NhdGlvbk5vZGUgPSBub2RlVG9SZWxvY2F0ZVsncy1vbCddO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKG9yZ0xvY2F0aW9uTm9kZSA9IG9yZ0xvY2F0aW9uTm9kZS5wcmV2aW91c1NpYmxpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWZOb2RlID0gb3JnTG9jYXRpb25Ob2RlWydzLW5yJ107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVmTm9kZSAmJiByZWZOb2RlWydzLXNuJ10gPT09IG5vZGVUb1JlbG9jYXRlWydzLXNuJ10gJiYgcGFyZW50Tm9kZVJlZiA9PT0gcmVmTm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmTm9kZSA9IHJlZk5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWZOb2RlIHx8ICFyZWZOb2RlWydzLW5yJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0QmVmb3JlTm9kZSA9IHJlZk5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoKCFpbnNlcnRCZWZvcmVOb2RlICYmIHBhcmVudE5vZGVSZWYgIT09IG5vZGVUb1JlbG9jYXRlLnBhcmVudE5vZGUpIHx8IG5vZGVUb1JlbG9jYXRlLm5leHRTaWJsaW5nICE9PSBpbnNlcnRCZWZvcmVOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSd2ZSBjaGVja2VkIHRoYXQgaXQncyB3b3J0aCB3aGlsZSB0byByZWxvY2F0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2luY2UgdGhhdCB0aGUgbm9kZSB0byByZWxvY2F0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGFzIGEgZGlmZmVyZW50IG5leHQgc2libGluZyBvciBwYXJlbnQgcmVsb2NhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVRvUmVsb2NhdGUgIT09IGluc2VydEJlZm9yZU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGVUb1JlbG9jYXRlWydzLWhuJ10gJiYgbm9kZVRvUmVsb2NhdGVbJ3Mtb2wnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9iYWJseSBhIGNvbXBvbmVudCBpbiB0aGUgaW5kZXguaHRtbCB0aGF0IGRvZXNuJ3QgaGF2ZSBpdCdzIGhvc3RuYW1lIHNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlVG9SZWxvY2F0ZVsncy1obiddID0gbm9kZVRvUmVsb2NhdGVbJ3Mtb2wnXS5wYXJlbnROb2RlLm5vZGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgaXQgYmFjayB0byB0aGUgZG9tIGJ1dCBpbiBpdHMgbmV3IGhvbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlUmVmLmluc2VydEJlZm9yZShub2RlVG9SZWxvY2F0ZSwgaW5zZXJ0QmVmb3JlTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgbm9kZSBkb2Vzbid0IGhhdmUgYSBzbG90IGhvbWUgdG8gZ28gdG8sIHNvIGxldCdzIGhpZGUgaXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVUb1JlbG9jYXRlLm5vZGVUeXBlID09PSAxIC8qIEVsZW1lbnROb2RlICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlVG9SZWxvY2F0ZS5oaWRkZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjaGVja1Nsb3RGYWxsYmFja1Zpc2liaWxpdHkpIHtcbiAgICAgICAgICAgIHVwZGF0ZUZhbGxiYWNrU2xvdFZpc2liaWxpdHkocm9vdFZub2RlLiRlbG0kKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkb25lIG1vdmluZyBub2RlcyBhcm91bmRcbiAgICAgICAgLy8gYWxsb3cgdGhlIGRpc2Nvbm5lY3QgY2FsbGJhY2sgdG8gd29yayBhZ2FpblxuICAgICAgICBwbHQuJGZsYWdzJCAmPSB+MSAvKiBpc1RtcERpc2Nvbm5lY3RlZCAqLztcbiAgICAgICAgLy8gYWx3YXlzIHJlc2V0XG4gICAgICAgIHJlbG9jYXRlTm9kZXMubGVuZ3RoID0gMDtcbiAgICB9XG59O1xuLy8gc2xvdCBjb21tZW50IGRlYnVnIG5vZGVzIG9ubHkgY3JlYXRlZCB3aXRoIHRoZSBgLS1kZWJ1Z2AgZmxhZ1xuLy8gb3RoZXJ3aXNlIHRoZXNlIG5vZGVzIGFyZSB0ZXh0IG5vZGVzIHcvb3V0IGNvbnRlbnRcbmNvbnN0IHNsb3RSZWZlcmVuY2VEZWJ1Z05vZGUgPSAoc2xvdFZOb2RlKSA9PiBkb2MuY3JlYXRlQ29tbWVudChgPHNsb3Qke3Nsb3RWTm9kZS4kbmFtZSQgPyAnIG5hbWU9XCInICsgc2xvdFZOb2RlLiRuYW1lJCArICdcIicgOiAnJ30+IChob3N0PSR7aG9zdFRhZ05hbWUudG9Mb3dlckNhc2UoKX0pYCk7XG5jb25zdCBvcmlnaW5hbExvY2F0aW9uRGVidWdOb2RlID0gKG5vZGVUb1JlbG9jYXRlKSA9PiBkb2MuY3JlYXRlQ29tbWVudChgb3JnLWxvY2F0aW9uIGZvciBgICsgKG5vZGVUb1JlbG9jYXRlLmxvY2FsTmFtZSA/IGA8JHtub2RlVG9SZWxvY2F0ZS5sb2NhbE5hbWV9PiAoaG9zdD0ke25vZGVUb1JlbG9jYXRlWydzLWhuJ119KWAgOiBgWyR7bm9kZVRvUmVsb2NhdGUudGV4dENvbnRlbnR9XWApKTtcbmNvbnN0IGdldEVsZW1lbnQgPSAocmVmKSA9PiAoQlVJTEQubGF6eUxvYWQgPyBnZXRIb3N0UmVmKHJlZikuJGhvc3RFbGVtZW50JCA6IHJlZik7XG5jb25zdCBjcmVhdGVFdmVudCA9IChyZWYsIG5hbWUsIGZsYWdzKSA9PiB7XG4gICAgY29uc3QgZWxtID0gZ2V0RWxlbWVudChyZWYpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVtaXQ6IChkZXRhaWwpID0+IHtcbiAgICAgICAgICAgIGlmIChCVUlMRC5pc0RldiAmJiAhZWxtLmlzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZURldldhcm4oYFRoZSBcIiR7bmFtZX1cIiBldmVudCB3YXMgZW1pdHRlZCwgYnV0IHRoZSBkaXNwYXRjaGVyIG5vZGUgaXMgbm8gbG9uZ2VyIGNvbm5lY3RlZCB0byB0aGUgZG9tLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVtaXRFdmVudChlbG0sIG5hbWUsIHtcbiAgICAgICAgICAgICAgICBidWJibGVzOiAhIShmbGFncyAmIDQgLyogQnViYmxlcyAqLyksXG4gICAgICAgICAgICAgICAgY29tcG9zZWQ6ICEhKGZsYWdzICYgMiAvKiBDb21wb3NlZCAqLyksXG4gICAgICAgICAgICAgICAgY2FuY2VsYWJsZTogISEoZmxhZ3MgJiAxIC8qIENhbmNlbGxhYmxlICovKSxcbiAgICAgICAgICAgICAgICBkZXRhaWwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmNvbnN0IGVtaXRFdmVudCA9IChlbG0sIG5hbWUsIG9wdHMpID0+IHtcbiAgICBjb25zdCBldiA9IHBsdC5jZShuYW1lLCBvcHRzKTtcbiAgICBlbG0uZGlzcGF0Y2hFdmVudChldik7XG4gICAgcmV0dXJuIGV2O1xufTtcbmNvbnN0IGF0dGFjaFRvQW5jZXN0b3IgPSAoaG9zdFJlZiwgYW5jZXN0b3JDb21wb25lbnQpID0+IHtcbiAgICBpZiAoQlVJTEQuYXN5bmNMb2FkaW5nICYmIGFuY2VzdG9yQ29tcG9uZW50ICYmICFob3N0UmVmLiRvblJlbmRlclJlc29sdmUkICYmIGFuY2VzdG9yQ29tcG9uZW50WydzLXAnXSkge1xuICAgICAgICBhbmNlc3RvckNvbXBvbmVudFsncy1wJ10ucHVzaChuZXcgUHJvbWlzZShyID0+IChob3N0UmVmLiRvblJlbmRlclJlc29sdmUkID0gcikpKTtcbiAgICB9XG59O1xuY29uc3Qgc2NoZWR1bGVVcGRhdGUgPSAoaG9zdFJlZiwgaXNJbml0aWFsTG9hZCkgPT4ge1xuICAgIGlmIChCVUlMRC50YXNrUXVldWUgJiYgQlVJTEQudXBkYXRhYmxlKSB7XG4gICAgICAgIGhvc3RSZWYuJGZsYWdzJCB8PSAxNiAvKiBpc1F1ZXVlZEZvclVwZGF0ZSAqLztcbiAgICB9XG4gICAgaWYgKEJVSUxELmFzeW5jTG9hZGluZyAmJiBob3N0UmVmLiRmbGFncyQgJiA0IC8qIGlzV2FpdGluZ0ZvckNoaWxkcmVuICovKSB7XG4gICAgICAgIGhvc3RSZWYuJGZsYWdzJCB8PSA1MTIgLyogbmVlZHNSZXJlbmRlciAqLztcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhdHRhY2hUb0FuY2VzdG9yKGhvc3RSZWYsIGhvc3RSZWYuJGFuY2VzdG9yQ29tcG9uZW50JCk7XG4gICAgLy8gdGhlcmUgaXMgbm8gYW5jZXN0b3IgY29tcG9uZW50IG9yIHRoZSBhbmNlc3RvciBjb21wb25lbnRcbiAgICAvLyBoYXMgYWxyZWFkeSBmaXJlZCBvZmYgaXRzIGxpZmVjeWNsZSB1cGRhdGUgdGhlblxuICAgIC8vIGZpcmUgb2ZmIHRoZSBpbml0aWFsIHVwZGF0ZVxuICAgIGNvbnN0IGRpc3BhdGNoID0gKCkgPT4gZGlzcGF0Y2hIb29rcyhob3N0UmVmLCBpc0luaXRpYWxMb2FkKTtcbiAgICByZXR1cm4gQlVJTEQudGFza1F1ZXVlID8gd3JpdGVUYXNrKGRpc3BhdGNoKSA6IGRpc3BhdGNoKCk7XG59O1xuY29uc3QgZGlzcGF0Y2hIb29rcyA9IChob3N0UmVmLCBpc0luaXRpYWxMb2FkKSA9PiB7XG4gICAgY29uc3QgZWxtID0gaG9zdFJlZi4kaG9zdEVsZW1lbnQkO1xuICAgIGNvbnN0IGVuZFNjaGVkdWxlID0gY3JlYXRlVGltZSgnc2NoZWR1bGVVcGRhdGUnLCBob3N0UmVmLiRjbXBNZXRhJC4kdGFnTmFtZSQpO1xuICAgIGNvbnN0IGluc3RhbmNlID0gQlVJTEQubGF6eUxvYWQgPyBob3N0UmVmLiRsYXp5SW5zdGFuY2UkIDogZWxtO1xuICAgIGxldCBwcm9taXNlO1xuICAgIGlmIChpc0luaXRpYWxMb2FkKSB7XG4gICAgICAgIGlmIChCVUlMRC5sYXp5TG9hZCAmJiBCVUlMRC5ob3N0TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGhvc3RSZWYuJGZsYWdzJCB8PSAyNTYgLyogaXNMaXN0ZW5SZWFkeSAqLztcbiAgICAgICAgICAgIGlmIChob3N0UmVmLiRxdWV1ZWRMaXN0ZW5lcnMkKSB7XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kcXVldWVkTGlzdGVuZXJzJC5tYXAoKFttZXRob2ROYW1lLCBldmVudF0pID0+IHNhZmVDYWxsKGluc3RhbmNlLCBtZXRob2ROYW1lLCBldmVudCkpO1xuICAgICAgICAgICAgICAgIGhvc3RSZWYuJHF1ZXVlZExpc3RlbmVycyQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVtaXRMaWZlY3ljbGVFdmVudChlbG0sICdjb21wb25lbnRXaWxsTG9hZCcpO1xuICAgICAgICBpZiAoQlVJTEQuY21wV2lsbExvYWQpIHtcbiAgICAgICAgICAgIHByb21pc2UgPSBzYWZlQ2FsbChpbnN0YW5jZSwgJ2NvbXBvbmVudFdpbGxMb2FkJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVtaXRMaWZlY3ljbGVFdmVudChlbG0sICdjb21wb25lbnRXaWxsVXBkYXRlJyk7XG4gICAgICAgIGlmIChCVUlMRC5jbXBXaWxsVXBkYXRlKSB7XG4gICAgICAgICAgICBwcm9taXNlID0gc2FmZUNhbGwoaW5zdGFuY2UsICdjb21wb25lbnRXaWxsVXBkYXRlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW1pdExpZmVjeWNsZUV2ZW50KGVsbSwgJ2NvbXBvbmVudFdpbGxSZW5kZXInKTtcbiAgICBpZiAoQlVJTEQuY21wV2lsbFJlbmRlcikge1xuICAgICAgICBwcm9taXNlID0gdGhlbihwcm9taXNlLCAoKSA9PiBzYWZlQ2FsbChpbnN0YW5jZSwgJ2NvbXBvbmVudFdpbGxSZW5kZXInKSk7XG4gICAgfVxuICAgIGVuZFNjaGVkdWxlKCk7XG4gICAgcmV0dXJuIHRoZW4ocHJvbWlzZSwgKCkgPT4gdXBkYXRlQ29tcG9uZW50KGhvc3RSZWYsIGluc3RhbmNlLCBpc0luaXRpYWxMb2FkKSk7XG59O1xuY29uc3QgdXBkYXRlQ29tcG9uZW50ID0gYXN5bmMgKGhvc3RSZWYsIGluc3RhbmNlLCBpc0luaXRpYWxMb2FkKSA9PiB7XG4gICAgLy8gdXBkYXRlQ29tcG9uZW50XG4gICAgY29uc3QgZWxtID0gaG9zdFJlZi4kaG9zdEVsZW1lbnQkO1xuICAgIGNvbnN0IGVuZFVwZGF0ZSA9IGNyZWF0ZVRpbWUoJ3VwZGF0ZScsIGhvc3RSZWYuJGNtcE1ldGEkLiR0YWdOYW1lJCk7XG4gICAgY29uc3QgcmMgPSBlbG1bJ3MtcmMnXTtcbiAgICBpZiAoQlVJTEQuc3R5bGUgJiYgaXNJbml0aWFsTG9hZCkge1xuICAgICAgICAvLyBET00gV1JJVEUhXG4gICAgICAgIGF0dGFjaFN0eWxlcyhob3N0UmVmKTtcbiAgICB9XG4gICAgY29uc3QgZW5kUmVuZGVyID0gY3JlYXRlVGltZSgncmVuZGVyJywgaG9zdFJlZi4kY21wTWV0YSQuJHRhZ05hbWUkKTtcbiAgICBpZiAoQlVJTEQuaXNEZXYpIHtcbiAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDEwMjQgLyogZGV2T25SZW5kZXIgKi87XG4gICAgfVxuICAgIGlmIChCVUlMRC5oeWRyYXRlU2VydmVyU2lkZSkge1xuICAgICAgICBhd2FpdCBjYWxsUmVuZGVyKGhvc3RSZWYsIGluc3RhbmNlLCBlbG0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2FsbFJlbmRlcihob3N0UmVmLCBpbnN0YW5jZSwgZWxtKTtcbiAgICB9XG4gICAgaWYgKEJVSUxELmNzc1ZhclNoaW0gJiYgcGx0LiRjc3NTaGltJCkge1xuICAgICAgICBwbHQuJGNzc1NoaW0kLnVwZGF0ZUhvc3QoZWxtKTtcbiAgICB9XG4gICAgaWYgKEJVSUxELmlzRGV2KSB7XG4gICAgICAgIGhvc3RSZWYuJHJlbmRlckNvdW50JCsrO1xuICAgICAgICBob3N0UmVmLiRmbGFncyQgJj0gfjEwMjQgLyogZGV2T25SZW5kZXIgKi87XG4gICAgfVxuICAgIGlmIChCVUlMRC5oeWRyYXRlU2VydmVyU2lkZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gbWFudWFsbHkgY29ubmVjdGVkIGNoaWxkIGNvbXBvbmVudHMgZHVyaW5nIHNlcnZlci1zaWRlIGh5ZHJhdGVcbiAgICAgICAgICAgIHNlcnZlclNpZGVDb25uZWN0ZWQoZWxtKTtcbiAgICAgICAgICAgIGlmIChpc0luaXRpYWxMb2FkKSB7XG4gICAgICAgICAgICAgICAgLy8gdXNpbmcgb25seSBkdXJpbmcgc2VydmVyLXNpZGUgaHlkcmF0ZVxuICAgICAgICAgICAgICAgIGlmIChob3N0UmVmLiRjbXBNZXRhJC4kZmxhZ3MkICYgMSAvKiBzaGFkb3dEb21FbmNhcHN1bGF0aW9uICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsbVsncy1lbiddID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhvc3RSZWYuJGNtcE1ldGEkLiRmbGFncyQgJiAyIC8qIHNjb3BlZENzc0VuY2Fwc3VsYXRpb24gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgZWxtWydzLWVuJ10gPSAnYyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlRXJyb3IoZSwgZWxtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoQlVJTEQuYXN5bmNMb2FkaW5nICYmIHJjKSB7XG4gICAgICAgIC8vIG9rLCBzbyB0dXJucyBvdXQgdGhlcmUgYXJlIHNvbWUgY2hpbGQgaG9zdCBlbGVtZW50c1xuICAgICAgICAvLyB3YWl0aW5nIG9uIHRoaXMgcGFyZW50IGVsZW1lbnQgdG8gbG9hZFxuICAgICAgICAvLyBsZXQncyBmaXJlIG9mZiBhbGwgdXBkYXRlIGNhbGxiYWNrcyB3YWl0aW5nXG4gICAgICAgIHJjLm1hcChjYiA9PiBjYigpKTtcbiAgICAgICAgZWxtWydzLXJjJ10gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVuZFJlbmRlcigpO1xuICAgIGVuZFVwZGF0ZSgpO1xuICAgIGlmIChCVUlMRC5hc3luY0xvYWRpbmcpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW5Qcm9taXNlcyA9IGVsbVsncy1wJ107XG4gICAgICAgIGNvbnN0IHBvc3RVcGRhdGUgPSAoKSA9PiBwb3N0VXBkYXRlQ29tcG9uZW50KGhvc3RSZWYpO1xuICAgICAgICBpZiAoY2hpbGRyZW5Qcm9taXNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHBvc3RVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIFByb21pc2UuYWxsKGNoaWxkcmVuUHJvbWlzZXMpLnRoZW4ocG9zdFVwZGF0ZSk7XG4gICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gNCAvKiBpc1dhaXRpbmdGb3JDaGlsZHJlbiAqLztcbiAgICAgICAgICAgIGNoaWxkcmVuUHJvbWlzZXMubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcG9zdFVwZGF0ZUNvbXBvbmVudChob3N0UmVmKTtcbiAgICB9XG59O1xuY29uc3QgY2FsbFJlbmRlciA9IChob3N0UmVmLCBpbnN0YW5jZSwgZWxtKSA9PiB7XG4gICAgLy8gaW4gb3JkZXIgZm9yIGJ1bmRsZXJzIHRvIGNvcnJlY3RseSB0cmVlc2hha2UgdGhlIEJVSUxEIG9iamVjdFxuICAgIC8vIHdlIG5lZWQgdG8gZW5zdXJlIEJVSUxEIGlzIG5vdCBkZW9wdGltaXplZCB3aXRoaW4gYSB0cnkvY2F0Y2hcbiAgICAvLyBodHRwczovL3JvbGx1cGpzLm9yZy9ndWlkZS9lbi8jdHJlZXNoYWtlIHRyeUNhdGNoRGVvcHRpbWl6YXRpb25cbiAgICBjb25zdCBhbGxSZW5kZXJGbiA9IEJVSUxELmFsbFJlbmRlckZuID8gdHJ1ZSA6IGZhbHNlO1xuICAgIGNvbnN0IGxhenlMb2FkID0gQlVJTEQubGF6eUxvYWQgPyB0cnVlIDogZmFsc2U7XG4gICAgY29uc3QgdGFza1F1ZXVlID0gQlVJTEQudGFza1F1ZXVlID8gdHJ1ZSA6IGZhbHNlO1xuICAgIGNvbnN0IHVwZGF0YWJsZSA9IEJVSUxELnVwZGF0YWJsZSA/IHRydWUgOiBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICByZW5kZXJpbmdSZWYgPSBpbnN0YW5jZTtcbiAgICAgICAgaW5zdGFuY2UgPSBhbGxSZW5kZXJGbiA/IGluc3RhbmNlLnJlbmRlcigpIDogaW5zdGFuY2UucmVuZGVyICYmIGluc3RhbmNlLnJlbmRlcigpO1xuICAgICAgICBpZiAodXBkYXRhYmxlICYmIHRhc2tRdWV1ZSkge1xuICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkICY9IH4xNiAvKiBpc1F1ZXVlZEZvclVwZGF0ZSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRhYmxlIHx8IGxhenlMb2FkKSB7XG4gICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gMiAvKiBoYXNSZW5kZXJlZCAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQuaGFzUmVuZGVyRm4gfHwgQlVJTEQucmVmbGVjdCkge1xuICAgICAgICAgICAgaWYgKEJVSUxELnZkb21SZW5kZXIgfHwgQlVJTEQucmVmbGVjdCkge1xuICAgICAgICAgICAgICAgIC8vIGxvb2tzIGxpa2Ugd2UndmUgZ290IGNoaWxkIG5vZGVzIHRvIHJlbmRlciBpbnRvIHRoaXMgaG9zdCBlbGVtZW50XG4gICAgICAgICAgICAgICAgLy8gb3Igd2UgbmVlZCB0byB1cGRhdGUgdGhlIGNzcyBjbGFzcy9hdHRycyBvbiB0aGUgaG9zdCBlbGVtZW50XG4gICAgICAgICAgICAgICAgLy8gRE9NIFdSSVRFIVxuICAgICAgICAgICAgICAgIGlmIChCVUlMRC5oeWRyYXRlU2VydmVyU2lkZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGluc3RhbmNlKS50aGVuKHZhbHVlID0+IHJlbmRlclZkb20oaG9zdFJlZiwgdmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlclZkb20oaG9zdFJlZiwgaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsbS50ZXh0Q29udGVudCA9IGluc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGVFcnJvcihlLCBob3N0UmVmLiRob3N0RWxlbWVudCQpO1xuICAgIH1cbiAgICByZW5kZXJpbmdSZWYgPSBudWxsO1xuICAgIHJldHVybiBudWxsO1xufTtcbmNvbnN0IGdldFJlbmRlcmluZ1JlZiA9ICgpID0+IHJlbmRlcmluZ1JlZjtcbmNvbnN0IHBvc3RVcGRhdGVDb21wb25lbnQgPSAoaG9zdFJlZikgPT4ge1xuICAgIGNvbnN0IHRhZ05hbWUgPSBob3N0UmVmLiRjbXBNZXRhJC4kdGFnTmFtZSQ7XG4gICAgY29uc3QgZWxtID0gaG9zdFJlZi4kaG9zdEVsZW1lbnQkO1xuICAgIGNvbnN0IGVuZFBvc3RVcGRhdGUgPSBjcmVhdGVUaW1lKCdwb3N0VXBkYXRlJywgdGFnTmFtZSk7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBCVUlMRC5sYXp5TG9hZCA/IGhvc3RSZWYuJGxhenlJbnN0YW5jZSQgOiBlbG07XG4gICAgY29uc3QgYW5jZXN0b3JDb21wb25lbnQgPSBob3N0UmVmLiRhbmNlc3RvckNvbXBvbmVudCQ7XG4gICAgaWYgKEJVSUxELmNtcERpZFJlbmRlcikge1xuICAgICAgICBpZiAoQlVJTEQuaXNEZXYpIHtcbiAgICAgICAgICAgIGhvc3RSZWYuJGZsYWdzJCB8PSAxMDI0IC8qIGRldk9uUmVuZGVyICovO1xuICAgICAgICB9XG4gICAgICAgIHNhZmVDYWxsKGluc3RhbmNlLCAnY29tcG9uZW50RGlkUmVuZGVyJyk7XG4gICAgICAgIGlmIChCVUlMRC5pc0Rldikge1xuICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkICY9IH4xMDI0IC8qIGRldk9uUmVuZGVyICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVtaXRMaWZlY3ljbGVFdmVudChlbG0sICdjb21wb25lbnREaWRSZW5kZXInKTtcbiAgICBpZiAoIShob3N0UmVmLiRmbGFncyQgJiA2NCAvKiBoYXNMb2FkZWRDb21wb25lbnQgKi8pKSB7XG4gICAgICAgIGhvc3RSZWYuJGZsYWdzJCB8PSA2NCAvKiBoYXNMb2FkZWRDb21wb25lbnQgKi87XG4gICAgICAgIGlmIChCVUlMRC5hc3luY0xvYWRpbmcgJiYgQlVJTEQuY3NzQW5ub3RhdGlvbnMpIHtcbiAgICAgICAgICAgIC8vIERPTSBXUklURSFcbiAgICAgICAgICAgIGFkZEh5ZHJhdGVkRmxhZyhlbG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5jbXBEaWRMb2FkKSB7XG4gICAgICAgICAgICBpZiAoQlVJTEQuaXNEZXYpIHtcbiAgICAgICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gMjA0OCAvKiBkZXZPbkRpZExvYWQgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzYWZlQ2FsbChpbnN0YW5jZSwgJ2NvbXBvbmVudERpZExvYWQnKTtcbiAgICAgICAgICAgIGlmIChCVUlMRC5pc0Rldikge1xuICAgICAgICAgICAgICAgIGhvc3RSZWYuJGZsYWdzJCAmPSB+MjA0OCAvKiBkZXZPbkRpZExvYWQgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZW1pdExpZmVjeWNsZUV2ZW50KGVsbSwgJ2NvbXBvbmVudERpZExvYWQnKTtcbiAgICAgICAgZW5kUG9zdFVwZGF0ZSgpO1xuICAgICAgICBpZiAoQlVJTEQuYXN5bmNMb2FkaW5nKSB7XG4gICAgICAgICAgICBob3N0UmVmLiRvblJlYWR5UmVzb2x2ZSQoZWxtKTtcbiAgICAgICAgICAgIGlmICghYW5jZXN0b3JDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICBhcHBEaWRMb2FkKHRhZ05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoQlVJTEQuY21wRGlkVXBkYXRlKSB7XG4gICAgICAgICAgICAvLyB3ZSd2ZSBhbHJlYWR5IGxvYWRlZCB0aGlzIGNvbXBvbmVudFxuICAgICAgICAgICAgLy8gZmlyZSBvZmYgdGhlIHVzZXIncyBjb21wb25lbnREaWRVcGRhdGUgbWV0aG9kIChpZiBvbmUgd2FzIHByb3ZpZGVkKVxuICAgICAgICAgICAgLy8gY29tcG9uZW50RGlkVXBkYXRlIHJ1bnMgQUZURVIgcmVuZGVyKCkgaGFzIGJlZW4gY2FsbGVkXG4gICAgICAgICAgICAvLyBhbmQgYWxsIGNoaWxkIGNvbXBvbmVudHMgaGF2ZSBmaW5pc2hlZCB1cGRhdGluZ1xuICAgICAgICAgICAgaWYgKEJVSUxELmlzRGV2KSB7XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDEwMjQgLyogZGV2T25SZW5kZXIgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzYWZlQ2FsbChpbnN0YW5jZSwgJ2NvbXBvbmVudERpZFVwZGF0ZScpO1xuICAgICAgICAgICAgaWYgKEJVSUxELmlzRGV2KSB7XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkICY9IH4xMDI0IC8qIGRldk9uUmVuZGVyICovO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVtaXRMaWZlY3ljbGVFdmVudChlbG0sICdjb21wb25lbnREaWRVcGRhdGUnKTtcbiAgICAgICAgZW5kUG9zdFVwZGF0ZSgpO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuaG90TW9kdWxlUmVwbGFjZW1lbnQpIHtcbiAgICAgICAgZWxtWydzLWhtci1sb2FkJ10gJiYgZWxtWydzLWhtci1sb2FkJ10oKTtcbiAgICB9XG4gICAgaWYgKEJVSUxELm1ldGhvZCAmJiBCVUlMRC5sYXp5TG9hZCkge1xuICAgICAgICBob3N0UmVmLiRvbkluc3RhbmNlUmVzb2x2ZSQoZWxtKTtcbiAgICB9XG4gICAgLy8gbG9hZCBldmVudHMgZmlyZSBmcm9tIGJvdHRvbSB0byB0b3BcbiAgICAvLyB0aGUgZGVlcGVzdCBlbGVtZW50cyBsb2FkIGZpcnN0IHRoZW4gYnViYmxlcyB1cFxuICAgIGlmIChCVUlMRC5hc3luY0xvYWRpbmcpIHtcbiAgICAgICAgaWYgKGhvc3RSZWYuJG9uUmVuZGVyUmVzb2x2ZSQpIHtcbiAgICAgICAgICAgIGhvc3RSZWYuJG9uUmVuZGVyUmVzb2x2ZSQoKTtcbiAgICAgICAgICAgIGhvc3RSZWYuJG9uUmVuZGVyUmVzb2x2ZSQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvc3RSZWYuJGZsYWdzJCAmIDUxMiAvKiBuZWVkc1JlcmVuZGVyICovKSB7XG4gICAgICAgICAgICBuZXh0VGljaygoKSA9PiBzY2hlZHVsZVVwZGF0ZShob3N0UmVmLCBmYWxzZSkpO1xuICAgICAgICB9XG4gICAgICAgIGhvc3RSZWYuJGZsYWdzJCAmPSB+KDQgLyogaXNXYWl0aW5nRm9yQ2hpbGRyZW4gKi8gfCA1MTIgLyogbmVlZHNSZXJlbmRlciAqLyk7XG4gICAgfVxuICAgIC8vICgg4oCiX+KAoilcbiAgICAvLyAoIOKAol/igKIpPuKMkOKWoC3ilqBcbiAgICAvLyAo4oyQ4pagX+KWoClcbn07XG5jb25zdCBmb3JjZVVwZGF0ZSA9IChyZWYpID0+IHtcbiAgICBpZiAoQlVJTEQudXBkYXRhYmxlKSB7XG4gICAgICAgIGNvbnN0IGhvc3RSZWYgPSBnZXRIb3N0UmVmKHJlZik7XG4gICAgICAgIGNvbnN0IGlzQ29ubmVjdGVkID0gaG9zdFJlZi4kaG9zdEVsZW1lbnQkLmlzQ29ubmVjdGVkO1xuICAgICAgICBpZiAoaXNDb25uZWN0ZWQgJiYgKGhvc3RSZWYuJGZsYWdzJCAmICgyIC8qIGhhc1JlbmRlcmVkICovIHwgMTYgLyogaXNRdWV1ZWRGb3JVcGRhdGUgKi8pKSA9PT0gMiAvKiBoYXNSZW5kZXJlZCAqLykge1xuICAgICAgICAgICAgc2NoZWR1bGVVcGRhdGUoaG9zdFJlZiwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybnMgXCJ0cnVlXCIgd2hlbiB0aGUgZm9yY2VkIHVwZGF0ZSB3YXMgc3VjY2Vzc2Z1bGx5IHNjaGVkdWxlZFxuICAgICAgICByZXR1cm4gaXNDb25uZWN0ZWQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5jb25zdCBhcHBEaWRMb2FkID0gKHdobykgPT4ge1xuICAgIC8vIG9uIGFwcGxvYWRcbiAgICAvLyB3ZSBoYXZlIGZpbmlzaCB0aGUgZmlyc3QgYmlnIGluaXRpYWwgcmVuZGVyXG4gICAgaWYgKEJVSUxELmNzc0Fubm90YXRpb25zKSB7XG4gICAgICAgIGFkZEh5ZHJhdGVkRmxhZyhkb2MuZG9jdW1lbnRFbGVtZW50KTtcbiAgICB9XG4gICAgaWYgKEJVSUxELmFzeW5jUXVldWUpIHtcbiAgICAgICAgcGx0LiRmbGFncyQgfD0gMiAvKiBhcHBMb2FkZWQgKi87XG4gICAgfVxuICAgIG5leHRUaWNrKCgpID0+IGVtaXRFdmVudCh3aW4sICdhcHBsb2FkJywgeyBkZXRhaWw6IHsgbmFtZXNwYWNlOiBOQU1FU1BBQ0UgfSB9KSk7XG4gICAgaWYgKEJVSUxELnByb2ZpbGUgJiYgcGVyZm9ybWFuY2UubWVhc3VyZSkge1xuICAgICAgICBwZXJmb3JtYW5jZS5tZWFzdXJlKGBbU3RlbmNpbF0gJHtOQU1FU1BBQ0V9IGluaXRpYWwgbG9hZCAoYnkgJHt3aG99KWAsICdzdDphcHA6c3RhcnQnKTtcbiAgICB9XG59O1xuY29uc3Qgc2FmZUNhbGwgPSAoaW5zdGFuY2UsIG1ldGhvZCwgYXJnKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlW21ldGhvZF0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZVttZXRob2RdKGFyZyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGVFcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcbmNvbnN0IHRoZW4gPSAocHJvbWlzZSwgdGhlbkZuKSA9PiB7XG4gICAgcmV0dXJuIHByb21pc2UgJiYgcHJvbWlzZS50aGVuID8gcHJvbWlzZS50aGVuKHRoZW5GbikgOiB0aGVuRm4oKTtcbn07XG5jb25zdCBlbWl0TGlmZWN5Y2xlRXZlbnQgPSAoZWxtLCBsaWZlY3ljbGVOYW1lKSA9PiB7XG4gICAgaWYgKEJVSUxELmxpZmVjeWNsZURPTUV2ZW50cykge1xuICAgICAgICBlbWl0RXZlbnQoZWxtLCAnc3RlbmNpbF8nICsgbGlmZWN5Y2xlTmFtZSwge1xuICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgIGNvbXBvc2VkOiB0cnVlLFxuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlOiBOQU1FU1BBQ0UsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG59O1xuY29uc3QgYWRkSHlkcmF0ZWRGbGFnID0gKGVsbSkgPT4gKEJVSUxELmh5ZHJhdGVkQ2xhc3MgPyBlbG0uY2xhc3NMaXN0LmFkZCgnaHlkcmF0ZWQnKSA6IEJVSUxELmh5ZHJhdGVkQXR0cmlidXRlID8gZWxtLnNldEF0dHJpYnV0ZSgnaHlkcmF0ZWQnLCAnJykgOiB1bmRlZmluZWQpO1xuY29uc3Qgc2VydmVyU2lkZUNvbm5lY3RlZCA9IChlbG0pID0+IHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IGVsbS5jaGlsZHJlbjtcbiAgICBpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZEVsbSA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGlsZEVsbS5jb25uZWN0ZWRDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNoaWxkRWxtLmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXJ2ZXJTaWRlQ29ubmVjdGVkKGNoaWxkRWxtKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBpbml0aWFsaXplQ2xpZW50SHlkcmF0ZSA9IChob3N0RWxtLCB0YWdOYW1lLCBob3N0SWQsIGhvc3RSZWYpID0+IHtcbiAgICBjb25zdCBlbmRIeWRyYXRlID0gY3JlYXRlVGltZSgnaHlkcmF0ZUNsaWVudCcsIHRhZ05hbWUpO1xuICAgIGNvbnN0IHNoYWRvd1Jvb3QgPSBob3N0RWxtLnNoYWRvd1Jvb3Q7XG4gICAgY29uc3QgY2hpbGRSZW5kZXJOb2RlcyA9IFtdO1xuICAgIGNvbnN0IHNsb3ROb2RlcyA9IFtdO1xuICAgIGNvbnN0IHNoYWRvd1Jvb3ROb2RlcyA9IEJVSUxELnNoYWRvd0RvbSAmJiBzaGFkb3dSb290ID8gW10gOiBudWxsO1xuICAgIGNvbnN0IHZub2RlID0gKGhvc3RSZWYuJHZub2RlJCA9IG5ld1ZOb2RlKHRhZ05hbWUsIG51bGwpKTtcbiAgICBpZiAoIXBsdC4kb3JnTG9jTm9kZXMkKSB7XG4gICAgICAgIGluaXRpYWxpemVEb2N1bWVudEh5ZHJhdGUoZG9jLmJvZHksIChwbHQuJG9yZ0xvY05vZGVzJCA9IG5ldyBNYXAoKSkpO1xuICAgIH1cbiAgICBob3N0RWxtW0hZRFJBVEVfSURdID0gaG9zdElkO1xuICAgIGhvc3RFbG0ucmVtb3ZlQXR0cmlidXRlKEhZRFJBVEVfSUQpO1xuICAgIGNsaWVudEh5ZHJhdGUodm5vZGUsIGNoaWxkUmVuZGVyTm9kZXMsIHNsb3ROb2Rlcywgc2hhZG93Um9vdE5vZGVzLCBob3N0RWxtLCBob3N0RWxtLCBob3N0SWQpO1xuICAgIGNoaWxkUmVuZGVyTm9kZXMubWFwKGMgPT4ge1xuICAgICAgICBjb25zdCBvcmdMb2NhdGlvbklkID0gYy4kaG9zdElkJCArICcuJyArIGMuJG5vZGVJZCQ7XG4gICAgICAgIGNvbnN0IG9yZ0xvY2F0aW9uTm9kZSA9IHBsdC4kb3JnTG9jTm9kZXMkLmdldChvcmdMb2NhdGlvbklkKTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGMuJGVsbSQ7XG4gICAgICAgIGlmIChvcmdMb2NhdGlvbk5vZGUgJiYgc3VwcG9ydHNTaGFkb3cgJiYgb3JnTG9jYXRpb25Ob2RlWydzLWVuJ10gPT09ICcnKSB7XG4gICAgICAgICAgICBvcmdMb2NhdGlvbk5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgb3JnTG9jYXRpb25Ob2RlLm5leHRTaWJsaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNoYWRvd1Jvb3QpIHtcbiAgICAgICAgICAgIG5vZGVbJ3MtaG4nXSA9IHRhZ05hbWU7XG4gICAgICAgICAgICBpZiAob3JnTG9jYXRpb25Ob2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZVsncy1vbCddID0gb3JnTG9jYXRpb25Ob2RlO1xuICAgICAgICAgICAgICAgIG5vZGVbJ3Mtb2wnXVsncy1uciddID0gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwbHQuJG9yZ0xvY05vZGVzJC5kZWxldGUob3JnTG9jYXRpb25JZCk7XG4gICAgfSk7XG4gICAgaWYgKEJVSUxELnNoYWRvd0RvbSAmJiBzaGFkb3dSb290KSB7XG4gICAgICAgIHNoYWRvd1Jvb3ROb2Rlcy5tYXAoc2hhZG93Um9vdE5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKHNoYWRvd1Jvb3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgc2hhZG93Um9vdC5hcHBlbmRDaGlsZChzaGFkb3dSb290Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbmRIeWRyYXRlKCk7XG59O1xuY29uc3QgY2xpZW50SHlkcmF0ZSA9IChwYXJlbnRWTm9kZSwgY2hpbGRSZW5kZXJOb2Rlcywgc2xvdE5vZGVzLCBzaGFkb3dSb290Tm9kZXMsIGhvc3RFbG0sIG5vZGUsIGhvc3RJZCkgPT4ge1xuICAgIGxldCBjaGlsZE5vZGVUeXBlO1xuICAgIGxldCBjaGlsZElkU3BsdDtcbiAgICBsZXQgY2hpbGRWTm9kZTtcbiAgICBsZXQgaTtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSAvKiBFbGVtZW50Tm9kZSAqLykge1xuICAgICAgICBjaGlsZE5vZGVUeXBlID0gbm9kZS5nZXRBdHRyaWJ1dGUoSFlEUkFURV9DSElMRF9JRCk7XG4gICAgICAgIGlmIChjaGlsZE5vZGVUeXBlKSB7XG4gICAgICAgICAgICAvLyBnb3QgdGhlIG5vZGUgZGF0YSBmcm9tIHRoZSBlbGVtZW50J3MgYXR0cmlidXRlXG4gICAgICAgICAgICAvLyBgJHtob3N0SWR9LiR7bm9kZUlkfS4ke2RlcHRofS4ke2luZGV4fWBcbiAgICAgICAgICAgIGNoaWxkSWRTcGx0ID0gY2hpbGROb2RlVHlwZS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgaWYgKGNoaWxkSWRTcGx0WzBdID09PSBob3N0SWQgfHwgY2hpbGRJZFNwbHRbMF0gPT09ICcwJykge1xuICAgICAgICAgICAgICAgIGNoaWxkVk5vZGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICRmbGFncyQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICRob3N0SWQkOiBjaGlsZElkU3BsdFswXSxcbiAgICAgICAgICAgICAgICAgICAgJG5vZGVJZCQ6IGNoaWxkSWRTcGx0WzFdLFxuICAgICAgICAgICAgICAgICAgICAkZGVwdGgkOiBjaGlsZElkU3BsdFsyXSxcbiAgICAgICAgICAgICAgICAgICAgJGluZGV4JDogY2hpbGRJZFNwbHRbM10sXG4gICAgICAgICAgICAgICAgICAgICR0YWckOiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgJGVsbSQ6IG5vZGUsXG4gICAgICAgICAgICAgICAgICAgICRhdHRycyQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICRjaGlsZHJlbiQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICRrZXkkOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAkbmFtZSQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICR0ZXh0JDogbnVsbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNoaWxkUmVuZGVyTm9kZXMucHVzaChjaGlsZFZOb2RlKTtcbiAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShIWURSQVRFX0NISUxEX0lEKTtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGEgbmV3IGNoaWxkIHZub2RlXG4gICAgICAgICAgICAgICAgLy8gc28gZW5zdXJlIGl0cyBwYXJlbnQgdm5vZGUgaGFzIHRoZSB2Y2hpbGRyZW4gYXJyYXlcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmVudFZOb2RlLiRjaGlsZHJlbiQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Vk5vZGUuJGNoaWxkcmVuJCA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBhZGQgb3VyIGNoaWxkIHZub2RlIHRvIGEgc3BlY2lmaWMgaW5kZXggb2YgdGhlIHZub2RlJ3MgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICBwYXJlbnRWTm9kZS4kY2hpbGRyZW4kW2NoaWxkVk5vZGUuJGluZGV4JF0gPSBjaGlsZFZOb2RlO1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgbm93IHRoZSBuZXcgcGFyZW50IHZub2RlIGZvciBhbGwgdGhlIG5leHQgY2hpbGQgY2hlY2tzXG4gICAgICAgICAgICAgICAgcGFyZW50Vk5vZGUgPSBjaGlsZFZOb2RlO1xuICAgICAgICAgICAgICAgIGlmIChzaGFkb3dSb290Tm9kZXMgJiYgY2hpbGRWTm9kZS4kZGVwdGgkID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgc2hhZG93Um9vdE5vZGVzW2NoaWxkVk5vZGUuJGluZGV4JF0gPSBjaGlsZFZOb2RlLiRlbG0kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyByZWN1cnNpdmVseSBkcmlsbCBkb3duLCBlbmQgdG8gc3RhcnQgc28gd2UgY2FuIHJlbW92ZSBub2Rlc1xuICAgICAgICBmb3IgKGkgPSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNsaWVudEh5ZHJhdGUocGFyZW50Vk5vZGUsIGNoaWxkUmVuZGVyTm9kZXMsIHNsb3ROb2Rlcywgc2hhZG93Um9vdE5vZGVzLCBob3N0RWxtLCBub2RlLmNoaWxkTm9kZXNbaV0sIGhvc3RJZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuc2hhZG93Um9vdCkge1xuICAgICAgICAgICAgLy8ga2VlcCBkcmlsbGluZyBkb3duIHRocm91Z2ggdGhlIHNoYWRvdyByb290IG5vZGVzXG4gICAgICAgICAgICBmb3IgKGkgPSBub2RlLnNoYWRvd1Jvb3QuY2hpbGROb2Rlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGNsaWVudEh5ZHJhdGUocGFyZW50Vk5vZGUsIGNoaWxkUmVuZGVyTm9kZXMsIHNsb3ROb2Rlcywgc2hhZG93Um9vdE5vZGVzLCBob3N0RWxtLCBub2RlLnNoYWRvd1Jvb3QuY2hpbGROb2Rlc1tpXSwgaG9zdElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09PSA4IC8qIENvbW1lbnROb2RlICovKSB7XG4gICAgICAgIC8vIGAke0NPTU1FTlRfVFlQRX0uJHtob3N0SWR9LiR7bm9kZUlkfS4ke2RlcHRofS4ke2luZGV4fWBcbiAgICAgICAgY2hpbGRJZFNwbHQgPSBub2RlLm5vZGVWYWx1ZS5zcGxpdCgnLicpO1xuICAgICAgICBpZiAoY2hpbGRJZFNwbHRbMV0gPT09IGhvc3RJZCB8fCBjaGlsZElkU3BsdFsxXSA9PT0gJzAnKSB7XG4gICAgICAgICAgICAvLyBjb21tZW50IG5vZGUgZm9yIGVpdGhlciB0aGUgaG9zdCBpZCBvciBhIDAgaG9zdCBpZFxuICAgICAgICAgICAgY2hpbGROb2RlVHlwZSA9IGNoaWxkSWRTcGx0WzBdO1xuICAgICAgICAgICAgY2hpbGRWTm9kZSA9IHtcbiAgICAgICAgICAgICAgICAkZmxhZ3MkOiAwLFxuICAgICAgICAgICAgICAgICRob3N0SWQkOiBjaGlsZElkU3BsdFsxXSxcbiAgICAgICAgICAgICAgICAkbm9kZUlkJDogY2hpbGRJZFNwbHRbMl0sXG4gICAgICAgICAgICAgICAgJGRlcHRoJDogY2hpbGRJZFNwbHRbM10sXG4gICAgICAgICAgICAgICAgJGluZGV4JDogY2hpbGRJZFNwbHRbNF0sXG4gICAgICAgICAgICAgICAgJGVsbSQ6IG5vZGUsXG4gICAgICAgICAgICAgICAgJGF0dHJzJDogbnVsbCxcbiAgICAgICAgICAgICAgICAkY2hpbGRyZW4kOiBudWxsLFxuICAgICAgICAgICAgICAgICRrZXkkOiBudWxsLFxuICAgICAgICAgICAgICAgICRuYW1lJDogbnVsbCxcbiAgICAgICAgICAgICAgICAkdGFnJDogbnVsbCxcbiAgICAgICAgICAgICAgICAkdGV4dCQ6IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZVR5cGUgPT09IFRFWFRfTk9ERV9JRCkge1xuICAgICAgICAgICAgICAgIGNoaWxkVk5vZGUuJGVsbSQgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZFZOb2RlLiRlbG0kICYmIGNoaWxkVk5vZGUuJGVsbSQubm9kZVR5cGUgPT09IDMgLyogVGV4dE5vZGUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRWTm9kZS4kdGV4dCQgPSBjaGlsZFZOb2RlLiRlbG0kLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICBjaGlsZFJlbmRlck5vZGVzLnB1c2goY2hpbGRWTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgdGV4dCBjb21tZW50IHNpbmNlIGl0J3Mgbm8gbG9uZ2VyIG5lZWRlZFxuICAgICAgICAgICAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVudFZOb2RlLiRjaGlsZHJlbiQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFZOb2RlLiRjaGlsZHJlbiQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRWTm9kZS4kY2hpbGRyZW4kW2NoaWxkVk5vZGUuJGluZGV4JF0gPSBjaGlsZFZOb2RlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hhZG93Um9vdE5vZGVzICYmIGNoaWxkVk5vZGUuJGRlcHRoJCA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFkb3dSb290Tm9kZXNbY2hpbGRWTm9kZS4kaW5kZXgkXSA9IGNoaWxkVk5vZGUuJGVsbSQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGlsZFZOb2RlLiRob3N0SWQkID09PSBob3N0SWQpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNvbW1lbnQgbm9kZSBpcyBzcGVjaWZjYWxseSBmb3IgdGhpcyBob3N0IGlkXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZVR5cGUgPT09IFNMT1RfTk9ERV9JRCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBgJHtTTE9UX05PREVfSUR9LiR7aG9zdElkfS4ke25vZGVJZH0uJHtkZXB0aH0uJHtpbmRleH0uJHtzbG90TmFtZX1gO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZFZOb2RlLiR0YWckID0gJ3Nsb3QnO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRJZFNwbHRbNV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVbJ3Mtc24nXSA9IGNoaWxkVk5vZGUuJG5hbWUkID0gY2hpbGRJZFNwbHRbNV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlWydzLXNuJ10gPSAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBub2RlWydzLXNyJ10gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoQlVJTEQuc2hhZG93RG9tICYmIHNoYWRvd1Jvb3ROb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnJvd3NlciBzdXBwb3J0IHNoYWRvd1Jvb3QgYW5kIHRoaXMgaXMgYSBzaGFkb3cgZG9tIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlIGFuIGFjdHVhbCBzbG90IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkVk5vZGUuJGVsbSQgPSBkb2MuY3JlYXRlRWxlbWVudChjaGlsZFZOb2RlLiR0YWckKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZFZOb2RlLiRuYW1lJCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCB0aGUgc2xvdCBuYW1lIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkVk5vZGUuJGVsbSQuc2V0QXR0cmlidXRlKCduYW1lJywgY2hpbGRWTm9kZS4kbmFtZSQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5zZXJ0IHRoZSBuZXcgc2xvdCBlbGVtZW50IGJlZm9yZSB0aGUgc2xvdCBjb21tZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkVk5vZGUuJGVsbSQsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBzbG90IGNvbW1lbnQgc2luY2UgaXQncyBub3QgbmVlZGVkIGZvciBzaGFkb3dcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRWTm9kZS4kZGVwdGgkID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFkb3dSb290Tm9kZXNbY2hpbGRWTm9kZS4kaW5kZXgkXSA9IGNoaWxkVk5vZGUuJGVsbSQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2xvdE5vZGVzLnB1c2goY2hpbGRWTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyZW50Vk5vZGUuJGNoaWxkcmVuJCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Vk5vZGUuJGNoaWxkcmVuJCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudFZOb2RlLiRjaGlsZHJlbiRbY2hpbGRWTm9kZS4kaW5kZXgkXSA9IGNoaWxkVk5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkTm9kZVR5cGUgPT09IENPTlRFTlRfUkVGX0lEKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGAke0NPTlRFTlRfUkVGX0lEfS4ke2hvc3RJZH1gO1xuICAgICAgICAgICAgICAgICAgICBpZiAoQlVJTEQuc2hhZG93RG9tICYmIHNoYWRvd1Jvb3ROb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBjb250ZW50IHJlZiBjb21tZW50IHNpbmNlIGl0J3Mgbm90IG5lZWRlZCBmb3Igc2hhZG93XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKEJVSUxELnNsb3RSZWxvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0RWxtWydzLWNyJ10gPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVsncy1jbiddID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChwYXJlbnRWTm9kZSAmJiBwYXJlbnRWTm9kZS4kdGFnJCA9PT0gJ3N0eWxlJykge1xuICAgICAgICBjb25zdCB2bm9kZSA9IG5ld1ZOb2RlKG51bGwsIG5vZGUudGV4dENvbnRlbnQpO1xuICAgICAgICB2bm9kZS4kZWxtJCA9IG5vZGU7XG4gICAgICAgIHZub2RlLiRpbmRleCQgPSAnMCc7XG4gICAgICAgIHBhcmVudFZOb2RlLiRjaGlsZHJlbiQgPSBbdm5vZGVdO1xuICAgIH1cbn07XG5jb25zdCBpbml0aWFsaXplRG9jdW1lbnRIeWRyYXRlID0gKG5vZGUsIG9yZ0xvY05vZGVzKSA9PiB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8pIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBmb3IgKDsgaSA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaW5pdGlhbGl6ZURvY3VtZW50SHlkcmF0ZShub2RlLmNoaWxkTm9kZXNbaV0sIG9yZ0xvY05vZGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5zaGFkb3dSb290KSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbm9kZS5zaGFkb3dSb290LmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpbml0aWFsaXplRG9jdW1lbnRIeWRyYXRlKG5vZGUuc2hhZG93Um9vdC5jaGlsZE5vZGVzW2ldLCBvcmdMb2NOb2Rlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PT0gOCAvKiBDb21tZW50Tm9kZSAqLykge1xuICAgICAgICBjb25zdCBjaGlsZElkU3BsdCA9IG5vZGUubm9kZVZhbHVlLnNwbGl0KCcuJyk7XG4gICAgICAgIGlmIChjaGlsZElkU3BsdFswXSA9PT0gT1JHX0xPQ0FUSU9OX0lEKSB7XG4gICAgICAgICAgICBvcmdMb2NOb2Rlcy5zZXQoY2hpbGRJZFNwbHRbMV0gKyAnLicgKyBjaGlsZElkU3BsdFsyXSwgbm9kZSk7XG4gICAgICAgICAgICBub2RlLm5vZGVWYWx1ZSA9ICcnO1xuICAgICAgICAgICAgLy8gdXNlZnVsIHRvIGtub3cgaWYgdGhlIG9yaWdpbmFsIGxvY2F0aW9uIGlzXG4gICAgICAgICAgICAvLyB0aGUgcm9vdCBsaWdodC1kb20gb2YgYSBzaGFkb3cgZG9tIGNvbXBvbmVudFxuICAgICAgICAgICAgbm9kZVsncy1lbiddID0gY2hpbGRJZFNwbHRbM107XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgcGFyc2VQcm9wZXJ0eVZhbHVlID0gKHByb3BWYWx1ZSwgcHJvcFR5cGUpID0+IHtcbiAgICAvLyBlbnN1cmUgdGhpcyB2YWx1ZSBpcyBvZiB0aGUgY29ycmVjdCBwcm9wIHR5cGVcbiAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgIWlzQ29tcGxleFR5cGUocHJvcFZhbHVlKSkge1xuICAgICAgICBpZiAoQlVJTEQucHJvcEJvb2xlYW4gJiYgcHJvcFR5cGUgJiA0IC8qIEJvb2xlYW4gKi8pIHtcbiAgICAgICAgICAgIC8vIHBlciB0aGUgSFRNTCBzcGVjLCBhbnkgc3RyaW5nIHZhbHVlIG1lYW5zIGl0IGlzIGEgYm9vbGVhbiB0cnVlIHZhbHVlXG4gICAgICAgICAgICAvLyBidXQgd2UnbGwgY2hlYXQgaGVyZSBhbmQgc2F5IHRoYXQgdGhlIHN0cmluZyBcImZhbHNlXCIgaXMgdGhlIGJvb2xlYW4gZmFsc2VcbiAgICAgICAgICAgIHJldHVybiBwcm9wVmFsdWUgPT09ICdmYWxzZScgPyBmYWxzZSA6IHByb3BWYWx1ZSA9PT0gJycgfHwgISFwcm9wVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJVSUxELnByb3BOdW1iZXIgJiYgcHJvcFR5cGUgJiAyIC8qIE51bWJlciAqLykge1xuICAgICAgICAgICAgLy8gZm9yY2UgaXQgdG8gYmUgYSBudW1iZXJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHByb3BWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJVSUxELnByb3BTdHJpbmcgJiYgcHJvcFR5cGUgJiAxIC8qIFN0cmluZyAqLykge1xuICAgICAgICAgICAgLy8gY291bGQgaGF2ZSBiZWVuIHBhc3NlZCBhcyBhIG51bWJlciBvciBib29sZWFuXG4gICAgICAgICAgICAvLyBidXQgd2Ugc3RpbGwgd2FudCBpdCBhcyBhIHN0cmluZ1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhwcm9wVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlZHVuZGFudCByZXR1cm4gaGVyZSBmb3IgYmV0dGVyIG1pbmlmaWNhdGlvblxuICAgICAgICByZXR1cm4gcHJvcFZhbHVlO1xuICAgIH1cbiAgICAvLyBub3Qgc3VyZSBleGFjdGx5IHdoYXQgdHlwZSB3ZSB3YW50XG4gICAgLy8gc28gbm8gbmVlZCB0byBjaGFuZ2UgdG8gYSBkaWZmZXJlbnQgdHlwZVxuICAgIHJldHVybiBwcm9wVmFsdWU7XG59O1xuY29uc3QgZ2V0VmFsdWUgPSAocmVmLCBwcm9wTmFtZSkgPT4gZ2V0SG9zdFJlZihyZWYpLiRpbnN0YW5jZVZhbHVlcyQuZ2V0KHByb3BOYW1lKTtcbmNvbnN0IHNldFZhbHVlID0gKHJlZiwgcHJvcE5hbWUsIG5ld1ZhbCwgY21wTWV0YSkgPT4ge1xuICAgIC8vIGNoZWNrIG91ciBuZXcgcHJvcGVydHkgdmFsdWUgYWdhaW5zdCBvdXIgaW50ZXJuYWwgdmFsdWVcbiAgICBjb25zdCBob3N0UmVmID0gZ2V0SG9zdFJlZihyZWYpO1xuICAgIGNvbnN0IGVsbSA9IEJVSUxELmxhenlMb2FkID8gaG9zdFJlZi4kaG9zdEVsZW1lbnQkIDogcmVmO1xuICAgIGNvbnN0IG9sZFZhbCA9IGhvc3RSZWYuJGluc3RhbmNlVmFsdWVzJC5nZXQocHJvcE5hbWUpO1xuICAgIGNvbnN0IGZsYWdzID0gaG9zdFJlZi4kZmxhZ3MkO1xuICAgIGNvbnN0IGluc3RhbmNlID0gQlVJTEQubGF6eUxvYWQgPyBob3N0UmVmLiRsYXp5SW5zdGFuY2UkIDogZWxtO1xuICAgIG5ld1ZhbCA9IHBhcnNlUHJvcGVydHlWYWx1ZShuZXdWYWwsIGNtcE1ldGEuJG1lbWJlcnMkW3Byb3BOYW1lXVswXSk7XG4gICAgaWYgKCghQlVJTEQubGF6eUxvYWQgfHwgIShmbGFncyAmIDggLyogaXNDb25zdHJ1Y3RpbmdJbnN0YW5jZSAqLykgfHwgb2xkVmFsID09PSB1bmRlZmluZWQpICYmIG5ld1ZhbCAhPT0gb2xkVmFsKSB7XG4gICAgICAgIC8vIGdhZHpvb2tzISB0aGUgcHJvcGVydHkncyB2YWx1ZSBoYXMgY2hhbmdlZCEhXG4gICAgICAgIC8vIHNldCBvdXIgbmV3IHZhbHVlIVxuICAgICAgICBob3N0UmVmLiRpbnN0YW5jZVZhbHVlcyQuc2V0KHByb3BOYW1lLCBuZXdWYWwpO1xuICAgICAgICBpZiAoQlVJTEQuaXNEZXYpIHtcbiAgICAgICAgICAgIGlmIChob3N0UmVmLiRmbGFncyQgJiAxMDI0IC8qIGRldk9uUmVuZGVyICovKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZURldldhcm4oYFRoZSBzdGF0ZS9wcm9wIFwiJHtwcm9wTmFtZX1cIiBjaGFuZ2VkIGR1cmluZyByZW5kZXJpbmcuIFRoaXMgY2FuIHBvdGVudGlhbGx5IGxlYWQgdG8gaW5maW5pdGUtbG9vcHMgYW5kIG90aGVyIGJ1Z3MuYCwgJ1xcbkVsZW1lbnQnLCBlbG0sICdcXG5OZXcgdmFsdWUnLCBuZXdWYWwsICdcXG5PbGQgdmFsdWUnLCBvbGRWYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaG9zdFJlZi4kZmxhZ3MkICYgMjA0OCAvKiBkZXZPbkRpZExvYWQgKi8pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlRGV2V2FybihgVGhlIHN0YXRlL3Byb3AgXCIke3Byb3BOYW1lfVwiIGNoYW5nZWQgZHVyaW5nIFwiY29tcG9uZW50RGlkTG9hZCgpXCIsIHRoaXMgdHJpZ2dlcnMgZXh0cmEgcmUtcmVuZGVycywgdHJ5IHRvIHNldHVwIG9uIFwiY29tcG9uZW50V2lsbExvYWQoKVwiYCwgJ1xcbkVsZW1lbnQnLCBlbG0sICdcXG5OZXcgdmFsdWUnLCBuZXdWYWwsICdcXG5PbGQgdmFsdWUnLCBvbGRWYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghQlVJTEQubGF6eUxvYWQgfHwgaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIC8vIGdldCBhbiBhcnJheSBvZiBtZXRob2QgbmFtZXMgb2Ygd2F0Y2ggZnVuY3Rpb25zIHRvIGNhbGxcbiAgICAgICAgICAgIGlmIChCVUlMRC53YXRjaENhbGxiYWNrICYmIGNtcE1ldGEuJHdhdGNoZXJzJCAmJiBmbGFncyAmIDEyOCAvKiBpc1dhdGNoUmVhZHkgKi8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB3YXRjaE1ldGhvZHMgPSBjbXBNZXRhLiR3YXRjaGVycyRbcHJvcE5hbWVdO1xuICAgICAgICAgICAgICAgIGlmICh3YXRjaE1ldGhvZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpbnN0YW5jZSBpcyB3YXRjaGluZyBmb3Igd2hlbiB0aGlzIHByb3BlcnR5IGNoYW5nZWRcbiAgICAgICAgICAgICAgICAgICAgd2F0Y2hNZXRob2RzLm1hcCh3YXRjaE1ldGhvZE5hbWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaXJlIG9mZiBlYWNoIG9mIHRoZSB3YXRjaCBtZXRob2RzIHRoYXQgYXJlIHdhdGNoaW5nIHRoaXMgcHJvcGVydHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZVt3YXRjaE1ldGhvZE5hbWVdKG5ld1ZhbCwgb2xkVmFsLCBwcm9wTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGVFcnJvcihlLCBlbG0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQlVJTEQudXBkYXRhYmxlICYmIChmbGFncyAmICgyIC8qIGhhc1JlbmRlcmVkICovIHwgMTYgLyogaXNRdWV1ZWRGb3JVcGRhdGUgKi8pKSA9PT0gMiAvKiBoYXNSZW5kZXJlZCAqLykge1xuICAgICAgICAgICAgICAgIGlmIChCVUlMRC5jbXBTaG91bGRVcGRhdGUgJiYgaW5zdGFuY2UuY29tcG9uZW50U2hvdWxkVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5jb21wb25lbnRTaG91bGRVcGRhdGUobmV3VmFsLCBvbGRWYWwsIHByb3BOYW1lKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBsb29rcyBsaWtlIHRoaXMgdmFsdWUgYWN0dWFsbHkgY2hhbmdlZCwgc28gd2UndmUgZ290IHdvcmsgdG8gZG8hXG4gICAgICAgICAgICAgICAgLy8gYnV0IG9ubHkgaWYgd2UndmUgYWxyZWFkeSByZW5kZXJlZCwgb3RoZXJ3aXNlIGp1c3QgY2hpbGwgb3V0XG4gICAgICAgICAgICAgICAgLy8gcXVldWUgdGhhdCB3ZSBuZWVkIHRvIGRvIGFuIHVwZGF0ZSwgYnV0IGRvbid0IHdvcnJ5IGFib3V0IHF1ZXVpbmdcbiAgICAgICAgICAgICAgICAvLyB1cCBtaWxsaW9ucyBjdXogdGhpcyBmdW5jdGlvbiBlbnN1cmVzIGl0IG9ubHkgcnVucyBvbmNlXG4gICAgICAgICAgICAgICAgc2NoZWR1bGVVcGRhdGUoaG9zdFJlZiwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IHByb3h5Q29tcG9uZW50ID0gKENzdHIsIGNtcE1ldGEsIGZsYWdzKSA9PiB7XG4gICAgaWYgKEJVSUxELm1lbWJlciAmJiBjbXBNZXRhLiRtZW1iZXJzJCkge1xuICAgICAgICBpZiAoQlVJTEQud2F0Y2hDYWxsYmFjayAmJiBDc3RyLndhdGNoZXJzKSB7XG4gICAgICAgICAgICBjbXBNZXRhLiR3YXRjaGVycyQgPSBDc3RyLndhdGNoZXJzO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0J3MgYmV0dGVyIHRvIGhhdmUgYSBjb25zdCB0aGFuIHR3byBPYmplY3QuZW50cmllcygpXG4gICAgICAgIGNvbnN0IG1lbWJlcnMgPSBPYmplY3QuZW50cmllcyhjbXBNZXRhLiRtZW1iZXJzJCk7XG4gICAgICAgIGNvbnN0IHByb3RvdHlwZSA9IENzdHIucHJvdG90eXBlO1xuICAgICAgICBtZW1iZXJzLm1hcCgoW21lbWJlck5hbWUsIFttZW1iZXJGbGFnc11dKSA9PiB7XG4gICAgICAgICAgICBpZiAoKEJVSUxELnByb3AgfHwgQlVJTEQuc3RhdGUpICYmIChtZW1iZXJGbGFncyAmIDMxIC8qIFByb3AgKi8gfHwgKCghQlVJTEQubGF6eUxvYWQgfHwgZmxhZ3MgJiAyIC8qIHByb3h5U3RhdGUgKi8pICYmIG1lbWJlckZsYWdzICYgMzIgLyogU3RhdGUgKi8pKSkge1xuICAgICAgICAgICAgICAgIC8vIHByb3h5Q29tcG9uZW50IC0gcHJvcFxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsIG1lbWJlck5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJveHlDb21wb25lbnQsIGdldCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFZhbHVlKHRoaXMsIG1lbWJlck5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzZXQobmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgZHVyaW5nIGRldiB0aW1lXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQlVJTEQuaXNEZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWYgPSBnZXRIb3N0UmVmKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBhcmUgcHJveHlpbmcgdGhlIGluc3RhbmNlIChub3QgZWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZmxhZ3MgJiAxIC8qIGlzRWxlbWVudENvbnN0cnVjdG9yICovKSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZWxlbWVudCBpcyBub3QgY29uc3RydWN0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChyZWYuJGZsYWdzJCAmIDggLyogaXNDb25zdHJ1Y3RpbmdJbnN0YW5jZSAqLykgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG1lbWJlciBpcyBhIHByb3BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG1lbWJlckZsYWdzICYgMzEgLyogUHJvcCAqLykgIT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG1lbWJlciBpcyBub3QgbXV0YWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobWVtYmVyRmxhZ3MgJiAxMDI0IC8qIE11dGFibGUgKi8pID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGVEZXZXYXJuKGBAUHJvcCgpIFwiJHttZW1iZXJOYW1lfVwiIG9uIDwke2NtcE1ldGEuJHRhZ05hbWUkfT4gaXMgaW1tdXRhYmxlIGJ1dCB3YXMgbW9kaWZpZWQgZnJvbSB3aXRoaW4gdGhlIGNvbXBvbmVudC5cXG5Nb3JlIGluZm9ybWF0aW9uOiBodHRwczovL3N0ZW5jaWxqcy5jb20vZG9jcy9wcm9wZXJ0aWVzI3Byb3AtbXV0YWJpbGl0eWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb3h5Q29tcG9uZW50LCBzZXQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlKHRoaXMsIG1lbWJlck5hbWUsIG5ld1ZhbHVlLCBjbXBNZXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQlVJTEQubGF6eUxvYWQgJiYgQlVJTEQubWV0aG9kICYmIGZsYWdzICYgMSAvKiBpc0VsZW1lbnRDb25zdHJ1Y3RvciAqLyAmJiBtZW1iZXJGbGFncyAmIDY0IC8qIE1ldGhvZCAqLykge1xuICAgICAgICAgICAgICAgIC8vIHByb3h5Q29tcG9uZW50IC0gbWV0aG9kXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgbWVtYmVyTmFtZSwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWYgPSBnZXRIb3N0UmVmKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlZi4kb25JbnN0YW5jZVByb21pc2UkLnRoZW4oKCkgPT4gcmVmLiRsYXp5SW5zdGFuY2UkW21lbWJlck5hbWVdKC4uLmFyZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChCVUlMRC5vYnNlcnZlQXR0cmlidXRlICYmICghQlVJTEQubGF6eUxvYWQgfHwgZmxhZ3MgJiAxIC8qIGlzRWxlbWVudENvbnN0cnVjdG9yICovKSkge1xuICAgICAgICAgICAgY29uc3QgYXR0ck5hbWVUb1Byb3BOYW1lID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgcHJvdG90eXBlLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayA9IGZ1bmN0aW9uIChhdHRyTmFtZSwgX29sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHBsdC5qbXAoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wTmFtZSA9IGF0dHJOYW1lVG9Qcm9wTmFtZS5nZXQoYXR0ck5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzW3Byb3BOYW1lXSA9IG5ld1ZhbHVlID09PSBudWxsICYmIHR5cGVvZiB0aGlzW3Byb3BOYW1lXSA9PT0gJ2Jvb2xlYW4nID8gZmFsc2UgOiBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBjcmVhdGUgYW4gYXJyYXkgb2YgYXR0cmlidXRlcyB0byBvYnNlcnZlXG4gICAgICAgICAgICAvLyBhbmQgYWxzbyBjcmVhdGUgYSBtYXAgb2YgaHRtbCBhdHRyaWJ1dGUgbmFtZSB0byBqcyBwcm9wZXJ0eSBuYW1lXG4gICAgICAgICAgICBDc3RyLm9ic2VydmVkQXR0cmlidXRlcyA9IG1lbWJlcnNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChbXywgbV0pID0+IG1bMF0gJiAxNSAvKiBIYXNBdHRyaWJ1dGUgKi8pIC8vIGZpbHRlciB0byBvbmx5IGtlZXAgcHJvcHMgdGhhdCBzaG91bGQgbWF0Y2ggYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgIC5tYXAoKFtwcm9wTmFtZSwgbV0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhdHRyTmFtZSA9IG1bMV0gfHwgcHJvcE5hbWU7XG4gICAgICAgICAgICAgICAgYXR0ck5hbWVUb1Byb3BOYW1lLnNldChhdHRyTmFtZSwgcHJvcE5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChCVUlMRC5yZWZsZWN0ICYmIG1bMF0gJiA1MTIgLyogUmVmbGVjdEF0dHIgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgY21wTWV0YS4kYXR0cnNUb1JlZmxlY3QkLnB1c2goW3Byb3BOYW1lLCBhdHRyTmFtZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYXR0ck5hbWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gQ3N0cjtcbn07XG5jb25zdCBpbml0aWFsaXplQ29tcG9uZW50ID0gYXN5bmMgKGVsbSwgaG9zdFJlZiwgY21wTWV0YSwgaG1yVmVyc2lvbklkLCBDc3RyKSA9PiB7XG4gICAgLy8gaW5pdGlhbGl6ZUNvbXBvbmVudFxuICAgIGlmICgoQlVJTEQubGF6eUxvYWQgfHwgQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGUgfHwgQlVJTEQuc3R5bGUpICYmIChob3N0UmVmLiRmbGFncyQgJiAzMiAvKiBoYXNJbml0aWFsaXplZENvbXBvbmVudCAqLykgPT09IDApIHtcbiAgICAgICAgaWYgKEJVSUxELmxhenlMb2FkIHx8IEJVSUxELmh5ZHJhdGVDbGllbnRTaWRlKSB7XG4gICAgICAgICAgICAvLyB3ZSBoYXZlbid0IGluaXRpYWxpemVkIHRoaXMgZWxlbWVudCB5ZXRcbiAgICAgICAgICAgIGhvc3RSZWYuJGZsYWdzJCB8PSAzMiAvKiBoYXNJbml0aWFsaXplZENvbXBvbmVudCAqLztcbiAgICAgICAgICAgIC8vIGxhenkgbG9hZGVkIGNvbXBvbmVudHNcbiAgICAgICAgICAgIC8vIHJlcXVlc3QgdGhlIGNvbXBvbmVudCdzIGltcGxlbWVudGF0aW9uIHRvIGJlXG4gICAgICAgICAgICAvLyB3aXJlZCB1cCB3aXRoIHRoZSBob3N0IGVsZW1lbnRcbiAgICAgICAgICAgIENzdHIgPSBsb2FkTW9kdWxlKGNtcE1ldGEsIGhvc3RSZWYsIGhtclZlcnNpb25JZCk7XG4gICAgICAgICAgICBpZiAoQ3N0ci50aGVuKSB7XG4gICAgICAgICAgICAgICAgLy8gQXdhaXQgY3JlYXRlcyBhIG1pY3JvLXRhc2sgYXZvaWQgaWYgcG9zc2libGVcbiAgICAgICAgICAgICAgICBjb25zdCBlbmRMb2FkID0gdW5pcXVlVGltZShgc3Q6bG9hZDoke2NtcE1ldGEuJHRhZ05hbWUkfToke2hvc3RSZWYuJG1vZGVOYW1lJH1gLCBgW1N0ZW5jaWxdIExvYWQgbW9kdWxlIGZvciA8JHtjbXBNZXRhLiR0YWdOYW1lJH0+YCk7XG4gICAgICAgICAgICAgICAgQ3N0ciA9IGF3YWl0IENzdHI7XG4gICAgICAgICAgICAgICAgZW5kTG9hZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChCVUlMRC5pc0RldiB8fCBCVUlMRC5pc0RlYnVnKSAmJiAhQ3N0cikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29uc3RydWN0b3IgZm9yIFwiJHtjbXBNZXRhLiR0YWdOYW1lJH0jJHtob3N0UmVmLiRtb2RlTmFtZSR9XCIgd2FzIG5vdCBmb3VuZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEJVSUxELm1lbWJlciAmJiAhQ3N0ci5pc1Byb3hpZWQpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSdldmUgbmV2ZXIgcHJveGllZCB0aGlzIENvbnN0cnVjdG9yIGJlZm9yZVxuICAgICAgICAgICAgICAgIC8vIGxldCdzIGFkZCB0aGUgZ2V0dGVycy9zZXR0ZXJzIHRvIGl0cyBwcm90b3R5cGUgYmVmb3JlXG4gICAgICAgICAgICAgICAgLy8gdGhlIGZpcnN0IHRpbWUgd2UgY3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoZSBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgICAgIGlmIChCVUlMRC53YXRjaENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNtcE1ldGEuJHdhdGNoZXJzJCA9IENzdHIud2F0Y2hlcnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByb3h5Q29tcG9uZW50KENzdHIsIGNtcE1ldGEsIDIgLyogcHJveHlTdGF0ZSAqLyk7XG4gICAgICAgICAgICAgICAgQ3N0ci5pc1Byb3hpZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZW5kTmV3SW5zdGFuY2UgPSBjcmVhdGVUaW1lKCdjcmVhdGVJbnN0YW5jZScsIGNtcE1ldGEuJHRhZ05hbWUkKTtcbiAgICAgICAgICAgIC8vIG9rLCB0aW1lIHRvIGNvbnN0cnVjdCB0aGUgaW5zdGFuY2VcbiAgICAgICAgICAgIC8vIGJ1dCBsZXQncyBrZWVwIHRyYWNrIG9mIHdoZW4gd2Ugc3RhcnQgYW5kIHN0b3BcbiAgICAgICAgICAgIC8vIHNvIHRoYXQgdGhlIGdldHRlcnMvc2V0dGVycyBkb24ndCBpbmNvcnJlY3RseSBzdGVwIG9uIGRhdGFcbiAgICAgICAgICAgIGlmIChCVUlMRC5tZW1iZXIpIHtcbiAgICAgICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gOCAvKiBpc0NvbnN0cnVjdGluZ0luc3RhbmNlICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29uc3RydWN0IHRoZSBsYXp5LWxvYWRlZCBjb21wb25lbnQgaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAgIC8vIHBhc3NpbmcgdGhlIGhvc3RSZWYgaXMgdmVyeSBpbXBvcnRhbnQgZHVyaW5nXG4gICAgICAgICAgICAvLyBjb25zdHJ1Y3Rpb24gaW4gb3JkZXIgdG8gZGlyZWN0bHkgd2lyZSB0b2dldGhlciB0aGVcbiAgICAgICAgICAgIC8vIGhvc3QgZWxlbWVudCBhbmQgdGhlIGxhenktbG9hZGVkIGluc3RhbmNlXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG5ldyBDc3RyKGhvc3RSZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlRXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQlVJTEQubWVtYmVyKSB7XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkICY9IH44IC8qIGlzQ29uc3RydWN0aW5nSW5zdGFuY2UgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQlVJTEQud2F0Y2hDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGhvc3RSZWYuJGZsYWdzJCB8PSAxMjggLyogaXNXYXRjaFJlYWR5ICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5kTmV3SW5zdGFuY2UoKTtcbiAgICAgICAgICAgIGZpcmVDb25uZWN0ZWRDYWxsYmFjayhob3N0UmVmLiRsYXp5SW5zdGFuY2UkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHN5bmMgY29uc3RydWN0b3IgY29tcG9uZW50XG4gICAgICAgICAgICBDc3RyID0gZWxtLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDEyOCAvKiBpc1dhdGNoUmVhZHkgKi8gfCAzMiAvKiBoYXNJbml0aWFsaXplZENvbXBvbmVudCAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQuc3R5bGUgJiYgQ3N0ci5zdHlsZSkge1xuICAgICAgICAgICAgLy8gdGhpcyBjb21wb25lbnQgaGFzIHN0eWxlcyBidXQgd2UgaGF2ZW4ndCByZWdpc3RlcmVkIHRoZW0geWV0XG4gICAgICAgICAgICBsZXQgc3R5bGUgPSBDc3RyLnN0eWxlO1xuICAgICAgICAgICAgaWYgKEJVSUxELm1vZGUgJiYgdHlwZW9mIHN0eWxlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHN0eWxlID0gc3R5bGVbKGhvc3RSZWYuJG1vZGVOYW1lJCA9IGNvbXB1dGVNb2RlKGVsbSkpXTtcbiAgICAgICAgICAgICAgICBpZiAoQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGUgJiYgaG9zdFJlZi4kbW9kZU5hbWUkKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ3MtbW9kZScsIGhvc3RSZWYuJG1vZGVOYW1lJCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2NvcGVJZCA9IGdldFNjb3BlSWQoY21wTWV0YSwgaG9zdFJlZi4kbW9kZU5hbWUkKTtcbiAgICAgICAgICAgIGlmICghc3R5bGVzLmhhcyhzY29wZUlkKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuZFJlZ2lzdGVyU3R5bGVzID0gY3JlYXRlVGltZSgncmVnaXN0ZXJTdHlsZXMnLCBjbXBNZXRhLiR0YWdOYW1lJCk7XG4gICAgICAgICAgICAgICAgaWYgKCFCVUlMRC5oeWRyYXRlU2VydmVyU2lkZSAmJiBCVUlMRC5zaGFkb3dEb20gJiYgQlVJTEQuc2hhZG93RG9tU2hpbSAmJiBjbXBNZXRhLiRmbGFncyQgJiA4IC8qIG5lZWRzU2hhZG93RG9tU2hpbSAqLykge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZSA9IGF3YWl0IGltcG9ydCgnLi9zaGFkb3ctY3NzLmpzJykudGhlbihtID0+IG0uc2NvcGVDc3Moc3R5bGUsIHNjb3BlSWQsIGZhbHNlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlZ2lzdGVyU3R5bGUoc2NvcGVJZCwgc3R5bGUsICEhKGNtcE1ldGEuJGZsYWdzJCAmIDEgLyogc2hhZG93RG9tRW5jYXBzdWxhdGlvbiAqLykpO1xuICAgICAgICAgICAgICAgIGVuZFJlZ2lzdGVyU3R5bGVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gd2UndmUgc3VjY2Vzc2Z1bGx5IGNyZWF0ZWQgYSBsYXp5IGluc3RhbmNlXG4gICAgY29uc3QgYW5jZXN0b3JDb21wb25lbnQgPSBob3N0UmVmLiRhbmNlc3RvckNvbXBvbmVudCQ7XG4gICAgY29uc3Qgc2NoZWR1bGUgPSAoKSA9PiBzY2hlZHVsZVVwZGF0ZShob3N0UmVmLCB0cnVlKTtcbiAgICBpZiAoQlVJTEQuYXN5bmNMb2FkaW5nICYmIGFuY2VzdG9yQ29tcG9uZW50ICYmIGFuY2VzdG9yQ29tcG9uZW50WydzLXJjJ10pIHtcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgaW50aWFsIGxvYWQgYW5kIHRoaXMgY29tcG9uZW50IGl0IGhhcyBhbiBhbmNlc3RvciBjb21wb25lbnRcbiAgICAgICAgLy8gYnV0IHRoZSBhbmNlc3RvciBjb21wb25lbnQgaGFzIE5PVCBmaXJlZCBpdHMgd2lsbCB1cGRhdGUgbGlmZWN5Y2xlIHlldFxuICAgICAgICAvLyBzbyBsZXQncyBqdXN0IGNvb2wgb3VyIGpldHMgYW5kIHdhaXQgZm9yIHRoZSBhbmNlc3RvciB0byBjb250aW51ZSBmaXJzdFxuICAgICAgICAvLyB0aGlzIHdpbGwgZ2V0IGZpcmVkIG9mZiB3aGVuIHRoZSBhbmNlc3RvciBjb21wb25lbnRcbiAgICAgICAgLy8gZmluYWxseSBnZXRzIGFyb3VuZCB0byByZW5kZXJpbmcgaXRzIGxhenkgc2VsZlxuICAgICAgICAvLyBmaXJlIG9mZiB0aGUgaW5pdGlhbCB1cGRhdGVcbiAgICAgICAgYW5jZXN0b3JDb21wb25lbnRbJ3MtcmMnXS5wdXNoKHNjaGVkdWxlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNjaGVkdWxlKCk7XG4gICAgfVxufTtcbmNvbnN0IGZpcmVDb25uZWN0ZWRDYWxsYmFjayA9IChpbnN0YW5jZSkgPT4ge1xuICAgIGlmIChCVUlMRC5sYXp5TG9hZCAmJiBCVUlMRC5jb25uZWN0ZWRDYWxsYmFjaykge1xuICAgICAgICBzYWZlQ2FsbChpbnN0YW5jZSwgJ2Nvbm5lY3RlZENhbGxiYWNrJyk7XG4gICAgfVxufTtcbmNvbnN0IGNvbm5lY3RlZENhbGxiYWNrID0gKGVsbSkgPT4ge1xuICAgIGlmICgocGx0LiRmbGFncyQgJiAxIC8qIGlzVG1wRGlzY29ubmVjdGVkICovKSA9PT0gMCkge1xuICAgICAgICBjb25zdCBob3N0UmVmID0gZ2V0SG9zdFJlZihlbG0pO1xuICAgICAgICBjb25zdCBjbXBNZXRhID0gaG9zdFJlZi4kY21wTWV0YSQ7XG4gICAgICAgIGNvbnN0IGVuZENvbm5lY3RlZCA9IGNyZWF0ZVRpbWUoJ2Nvbm5lY3RlZENhbGxiYWNrJywgY21wTWV0YS4kdGFnTmFtZSQpO1xuICAgICAgICBpZiAoQlVJTEQuaG9zdExpc3RlbmVyVGFyZ2V0UGFyZW50KSB7XG4gICAgICAgICAgICAvLyBvbmx5IHJ1biBpZiB3ZSBoYXZlIGxpc3RlbmVycyBiZWluZyBhdHRhY2hlZCB0byBhIHBhcmVudFxuICAgICAgICAgICAgYWRkSG9zdEV2ZW50TGlzdGVuZXJzKGVsbSwgaG9zdFJlZiwgY21wTWV0YS4kbGlzdGVuZXJzJCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoaG9zdFJlZi4kZmxhZ3MkICYgMSAvKiBoYXNDb25uZWN0ZWQgKi8pKSB7XG4gICAgICAgICAgICAvLyBmaXJzdCB0aW1lIHRoaXMgY29tcG9uZW50IGhhcyBjb25uZWN0ZWRcbiAgICAgICAgICAgIGhvc3RSZWYuJGZsYWdzJCB8PSAxIC8qIGhhc0Nvbm5lY3RlZCAqLztcbiAgICAgICAgICAgIGxldCBob3N0SWQ7XG4gICAgICAgICAgICBpZiAoQlVJTEQuaHlkcmF0ZUNsaWVudFNpZGUpIHtcbiAgICAgICAgICAgICAgICBob3N0SWQgPSBlbG0uZ2V0QXR0cmlidXRlKEhZRFJBVEVfSUQpO1xuICAgICAgICAgICAgICAgIGlmIChob3N0SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEJVSUxELnNoYWRvd0RvbSAmJiBzdXBwb3J0c1NoYWRvdyAmJiBjbXBNZXRhLiRmbGFncyQgJiAxIC8qIHNoYWRvd0RvbUVuY2Fwc3VsYXRpb24gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjb3BlSWQgPSBCVUlMRC5tb2RlID8gYWRkU3R5bGUoZWxtLnNoYWRvd1Jvb3QsIGNtcE1ldGEsIGVsbS5nZXRBdHRyaWJ1dGUoJ3MtbW9kZScpKSA6IGFkZFN0eWxlKGVsbS5zaGFkb3dSb290LCBjbXBNZXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsbS5jbGFzc0xpc3QucmVtb3ZlKHNjb3BlSWQgKyAnLWgnLCBzY29wZUlkICsgJy1zJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbGl6ZUNsaWVudEh5ZHJhdGUoZWxtLCBjbXBNZXRhLiR0YWdOYW1lJCwgaG9zdElkLCBob3N0UmVmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24gJiYgIWhvc3RJZCkge1xuICAgICAgICAgICAgICAgIC8vIGluaXRVcGRhdGVcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgc2xvdCBwb2x5ZmlsbCBpcyByZXF1aXJlZCB3ZSdsbCBuZWVkIHRvIHB1dCBzb21lIG5vZGVzXG4gICAgICAgICAgICAgICAgLy8gaW4gaGVyZSB0byBhY3QgYXMgb3JpZ2luYWwgY29udGVudCBhbmNob3JzIGFzIHdlIG1vdmUgbm9kZXMgYXJvdW5kXG4gICAgICAgICAgICAgICAgLy8gaG9zdCBlbGVtZW50IGhhcyBiZWVuIGNvbm5lY3RlZCB0byB0aGUgRE9NXG4gICAgICAgICAgICAgICAgaWYgKEJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlIHx8ICgoQlVJTEQuc2xvdCB8fCBCVUlMRC5zaGFkb3dEb20pICYmIGNtcE1ldGEuJGZsYWdzJCAmICg0IC8qIGhhc1Nsb3RSZWxvY2F0aW9uICovIHwgOCAvKiBuZWVkc1NoYWRvd0RvbVNoaW0gKi8pKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRDb250ZW50UmVmZXJlbmNlKGVsbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEJVSUxELmFzeW5jTG9hZGluZykge1xuICAgICAgICAgICAgICAgIC8vIGZpbmQgdGhlIGZpcnN0IGFuY2VzdG9yIGNvbXBvbmVudCAoaWYgdGhlcmUgaXMgb25lKSBhbmQgcmVnaXN0ZXJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNvbXBvbmVudCBhcyBvbmUgb2YgdGhlIGFjdGl2ZWx5IGxvYWRpbmcgY2hpbGQgY29tcG9uZW50cyBmb3IgaXRzIGFuY2VzdG9yXG4gICAgICAgICAgICAgICAgbGV0IGFuY2VzdG9yQ29tcG9uZW50ID0gZWxtO1xuICAgICAgICAgICAgICAgIHdoaWxlICgoYW5jZXN0b3JDb21wb25lbnQgPSBhbmNlc3RvckNvbXBvbmVudC5wYXJlbnROb2RlIHx8IGFuY2VzdG9yQ29tcG9uZW50Lmhvc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNsaW1iIHVwIHRoZSBhbmNlc3RvcnMgbG9va2luZyBmb3IgdGhlIGZpcnN0XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudCB0aGF0IGhhc24ndCBmaW5pc2hlZCBpdHMgbGlmZWN5Y2xlIHVwZGF0ZSB5ZXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKChCVUlMRC5oeWRyYXRlQ2xpZW50U2lkZSAmJiBhbmNlc3RvckNvbXBvbmVudC5ub2RlVHlwZSA9PT0gMSAvKiBFbGVtZW50Tm9kZSAqLyAmJiBhbmNlc3RvckNvbXBvbmVudC5oYXNBdHRyaWJ1dGUoJ3MtaWQnKSAmJiBhbmNlc3RvckNvbXBvbmVudFsncy1wJ10pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmNlc3RvckNvbXBvbmVudFsncy1wJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGZvdW5kIHRoaXMgY29tcG9uZW50cyBmaXJzdCBhbmNlc3RvciBjb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhpcyBjb21wb25lbnQncyBhbmNlc3RvciBjb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFjaFRvQW5jZXN0b3IoaG9zdFJlZiwgKGhvc3RSZWYuJGFuY2VzdG9yQ29tcG9uZW50JCA9IGFuY2VzdG9yQ29tcG9uZW50KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIExhenkgcHJvcGVydGllc1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vd2ViL2Z1bmRhbWVudGFscy93ZWItY29tcG9uZW50cy9iZXN0LXByYWN0aWNlcyNsYXp5LXByb3BlcnRpZXNcbiAgICAgICAgICAgIGlmIChCVUlMRC5wcm9wICYmIEJVSUxELmxhenlMb2FkICYmICFCVUlMRC5oeWRyYXRlU2VydmVyU2lkZSAmJiBjbXBNZXRhLiRtZW1iZXJzJCkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGNtcE1ldGEuJG1lbWJlcnMkKS5tYXAoKFttZW1iZXJOYW1lLCBbbWVtYmVyRmxhZ3NdXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVtYmVyRmxhZ3MgJiAzMSAvKiBQcm9wICovICYmIGVsbS5oYXNPd25Qcm9wZXJ0eShtZW1iZXJOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBlbG1bbWVtYmVyTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZWxtW21lbWJlck5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxtW21lbWJlck5hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCVUlMRC5pbml0aWFsaXplTmV4dFRpY2spIHtcbiAgICAgICAgICAgICAgICAvLyBjb25uZWN0ZWRDYWxsYmFjaywgdGFza1F1ZXVlLCBpbml0aWFsTG9hZFxuICAgICAgICAgICAgICAgIC8vIGFuZ3VsYXIgc2V0cyBhdHRyaWJ1dGUgQUZURVIgY29ubmVjdENhbGxiYWNrXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMTg5MDlcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8xOTk0MFxuICAgICAgICAgICAgICAgIG5leHRUaWNrKCgpID0+IGluaXRpYWxpemVDb21wb25lbnQoZWxtLCBob3N0UmVmLCBjbXBNZXRhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbml0aWFsaXplQ29tcG9uZW50KGVsbSwgaG9zdFJlZiwgY21wTWV0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBub3QgdGhlIGZpcnN0IHRpbWUgdGhpcyBoYXMgY29ubmVjdGVkXG4gICAgICAgICAgICAvLyByZWF0dGFjaCBhbnkgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBob3N0XG4gICAgICAgICAgICAvLyBzaW5jZSB0aGV5IHdvdWxkIGhhdmUgYmVlbiByZW1vdmVkIHdoZW4gZGlzY29ubmVjdGVkXG4gICAgICAgICAgICBhZGRIb3N0RXZlbnRMaXN0ZW5lcnMoZWxtLCBob3N0UmVmLCBjbXBNZXRhLiRsaXN0ZW5lcnMkLCBmYWxzZSk7XG4gICAgICAgICAgICAvLyBmaXJlIG9mZiBjb25uZWN0ZWRDYWxsYmFjaygpIG9uIGNvbXBvbmVudCBpbnN0YW5jZVxuICAgICAgICAgICAgZmlyZUNvbm5lY3RlZENhbGxiYWNrKGhvc3RSZWYuJGxhenlJbnN0YW5jZSQpO1xuICAgICAgICB9XG4gICAgICAgIGVuZENvbm5lY3RlZCgpO1xuICAgIH1cbn07XG5jb25zdCBzZXRDb250ZW50UmVmZXJlbmNlID0gKGVsbSkgPT4ge1xuICAgIC8vIG9ubHkgcmVxdWlyZWQgd2hlbiB3ZSdyZSBOT1QgdXNpbmcgbmF0aXZlIHNoYWRvdyBkb20gKHNsb3QpXG4gICAgLy8gb3IgdGhpcyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBuYXRpdmUgc2hhZG93IGRvbVxuICAgIC8vIGFuZCB0aGlzIGhvc3QgZWxlbWVudCB3YXMgTk9UIGNyZWF0ZWQgd2l0aCBTU1JcbiAgICAvLyBsZXQncyBwaWNrIG91dCB0aGUgaW5uZXIgY29udGVudCBmb3Igc2xvdCBwcm9qZWN0aW9uXG4gICAgLy8gY3JlYXRlIGEgbm9kZSB0byByZXByZXNlbnQgd2hlcmUgdGhlIG9yaWdpbmFsXG4gICAgLy8gY29udGVudCB3YXMgZmlyc3QgcGxhY2VkLCB3aGljaCBpcyB1c2VmdWwgbGF0ZXIgb25cbiAgICBjb25zdCBjb250ZW50UmVmRWxtID0gKGVsbVsncy1jciddID0gZG9jLmNyZWF0ZUNvbW1lbnQoQlVJTEQuaXNEZWJ1ZyA/IGBjb250ZW50LXJlZiAoaG9zdD0ke2VsbS5sb2NhbE5hbWV9KWAgOiAnJykpO1xuICAgIGNvbnRlbnRSZWZFbG1bJ3MtY24nXSA9IHRydWU7XG4gICAgZWxtLmluc2VydEJlZm9yZShjb250ZW50UmVmRWxtLCBlbG0uZmlyc3RDaGlsZCk7XG59O1xuY29uc3QgZGlzY29ubmVjdGVkQ2FsbGJhY2sgPSAoZWxtKSA9PiB7XG4gICAgaWYgKChwbHQuJGZsYWdzJCAmIDEgLyogaXNUbXBEaXNjb25uZWN0ZWQgKi8pID09PSAwKSB7XG4gICAgICAgIGNvbnN0IGhvc3RSZWYgPSBnZXRIb3N0UmVmKGVsbSk7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gQlVJTEQubGF6eUxvYWQgPyBob3N0UmVmLiRsYXp5SW5zdGFuY2UkIDogZWxtO1xuICAgICAgICBpZiAoQlVJTEQuaG9zdExpc3RlbmVyKSB7XG4gICAgICAgICAgICBpZiAoaG9zdFJlZi4kcm1MaXN0ZW5lcnMkKSB7XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kcm1MaXN0ZW5lcnMkLm1hcChybUxpc3RlbmVyID0+IHJtTGlzdGVuZXIoKSk7XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kcm1MaXN0ZW5lcnMkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNsZWFyIENTUyB2YXItc2hpbSB0cmFja2luZ1xuICAgICAgICBpZiAoQlVJTEQuY3NzVmFyU2hpbSAmJiBwbHQuJGNzc1NoaW0kKSB7XG4gICAgICAgICAgICBwbHQuJGNzc1NoaW0kLnJlbW92ZUhvc3QoZWxtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQubGF6eUxvYWQgJiYgQlVJTEQuZGlzY29ubmVjdGVkQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHNhZmVDYWxsKGluc3RhbmNlLCAnZGlzY29ubmVjdGVkQ2FsbGJhY2snKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQuY21wRGlkVW5sb2FkKSB7XG4gICAgICAgICAgICBzYWZlQ2FsbChpbnN0YW5jZSwgJ2NvbXBvbmVudERpZFVubG9hZCcpO1xuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IGRlZmluZUN1c3RvbUVsZW1lbnQgPSAoQ3N0ciwgY29tcGFjdE1ldGEpID0+IHtcbiAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUoY29tcGFjdE1ldGFbMV0sIHByb3h5Q3VzdG9tRWxlbWVudChDc3RyLCBjb21wYWN0TWV0YSkpO1xufTtcbmNvbnN0IHByb3h5Q3VzdG9tRWxlbWVudCA9IChDc3RyLCBjb21wYWN0TWV0YSkgPT4ge1xuICAgIGNvbnN0IGNtcE1ldGEgPSB7XG4gICAgICAgICRmbGFncyQ6IGNvbXBhY3RNZXRhWzBdLFxuICAgICAgICAkdGFnTmFtZSQ6IGNvbXBhY3RNZXRhWzFdLFxuICAgIH07XG4gICAgaWYgKEJVSUxELm1lbWJlcikge1xuICAgICAgICBjbXBNZXRhLiRtZW1iZXJzJCA9IGNvbXBhY3RNZXRhWzJdO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuaG9zdExpc3RlbmVyKSB7XG4gICAgICAgIGNtcE1ldGEuJGxpc3RlbmVycyQgPSBjb21wYWN0TWV0YVszXTtcbiAgICB9XG4gICAgaWYgKEJVSUxELndhdGNoQ2FsbGJhY2spIHtcbiAgICAgICAgY21wTWV0YS4kd2F0Y2hlcnMkID0gQ3N0ci4kd2F0Y2hlcnMkO1xuICAgIH1cbiAgICBpZiAoQlVJTEQucmVmbGVjdCkge1xuICAgICAgICBjbXBNZXRhLiRhdHRyc1RvUmVmbGVjdCQgPSBbXTtcbiAgICB9XG4gICAgaWYgKEJVSUxELnNoYWRvd0RvbSAmJiAhc3VwcG9ydHNTaGFkb3cgJiYgY21wTWV0YS4kZmxhZ3MkICYgMSAvKiBzaGFkb3dEb21FbmNhcHN1bGF0aW9uICovKSB7XG4gICAgICAgIGNtcE1ldGEuJGZsYWdzJCB8PSA4IC8qIG5lZWRzU2hhZG93RG9tU2hpbSAqLztcbiAgICB9XG4gICAgY29uc3Qgb3JpZ2luYWxDb25uZWN0ZWRDYWxsYmFjayA9IENzdHIucHJvdG90eXBlLmNvbm5lY3RlZENhbGxiYWNrO1xuICAgIGNvbnN0IG9yaWdpbmFsRGlzY29ubmVjdGVkQ2FsbGJhY2sgPSBDc3RyLnByb3RvdHlwZS5kaXNjb25uZWN0ZWRDYWxsYmFjaztcbiAgICBPYmplY3QuYXNzaWduKENzdHIucHJvdG90eXBlLCB7XG4gICAgICAgIF9fcmVnaXN0ZXJIb3N0KCkge1xuICAgICAgICAgICAgcmVnaXN0ZXJIb3N0KHRoaXMsIGNtcE1ldGEpO1xuICAgICAgICB9LFxuICAgICAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgIGNvbm5lY3RlZENhbGxiYWNrKHRoaXMpO1xuICAgICAgICAgICAgaWYgKEJVSUxELmNvbm5lY3RlZENhbGxiYWNrICYmIG9yaWdpbmFsQ29ubmVjdGVkQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbENvbm5lY3RlZENhbGxiYWNrLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICAgICAgZGlzY29ubmVjdGVkQ2FsbGJhY2sodGhpcyk7XG4gICAgICAgICAgICBpZiAoQlVJTEQuZGlzY29ubmVjdGVkQ2FsbGJhY2sgJiYgb3JpZ2luYWxEaXNjb25uZWN0ZWRDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsRGlzY29ubmVjdGVkQ2FsbGJhY2suY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICBDc3RyLmlzID0gY21wTWV0YS4kdGFnTmFtZSQ7XG4gICAgcmV0dXJuIHByb3h5Q29tcG9uZW50KENzdHIsIGNtcE1ldGEsIDEgLyogaXNFbGVtZW50Q29uc3RydWN0b3IgKi8gfCAyIC8qIHByb3h5U3RhdGUgKi8pO1xufTtcbmNvbnN0IGZvcmNlTW9kZVVwZGF0ZSA9IChlbG0pID0+IHtcbiAgICBpZiAoQlVJTEQuc3R5bGUgJiYgQlVJTEQubW9kZSAmJiAhQlVJTEQubGF6eUxvYWQpIHtcbiAgICAgICAgY29uc3QgbW9kZSA9IGNvbXB1dGVNb2RlKGVsbSk7XG4gICAgICAgIGNvbnN0IGhvc3RSZWYgPSBnZXRIb3N0UmVmKGVsbSk7XG4gICAgICAgIGlmIChob3N0UmVmLiRtb2RlTmFtZSQgIT09IG1vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNtcE1ldGEgPSBob3N0UmVmLiRjbXBNZXRhJDtcbiAgICAgICAgICAgIGNvbnN0IG9sZFNjb3BlSWQgPSBlbG1bJ3Mtc2MnXTtcbiAgICAgICAgICAgIGNvbnN0IHNjb3BlSWQgPSBnZXRTY29wZUlkKGNtcE1ldGEsIG1vZGUpO1xuICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSBlbG0uY29uc3RydWN0b3Iuc3R5bGVbbW9kZV07XG4gICAgICAgICAgICBjb25zdCBmbGFncyA9IGNtcE1ldGEuJGZsYWdzJDtcbiAgICAgICAgICAgIGlmIChzdHlsZSkge1xuICAgICAgICAgICAgICAgIGlmICghc3R5bGVzLmhhcyhzY29wZUlkKSkge1xuICAgICAgICAgICAgICAgICAgICByZWdpc3RlclN0eWxlKHNjb3BlSWQsIHN0eWxlLCAhIShmbGFncyAmIDEgLyogc2hhZG93RG9tRW5jYXBzdWxhdGlvbiAqLykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBob3N0UmVmLiRtb2RlTmFtZSQgPSBtb2RlO1xuICAgICAgICAgICAgICAgIGVsbS5jbGFzc0xpc3QucmVtb3ZlKG9sZFNjb3BlSWQgKyAnLWgnLCBvbGRTY29wZUlkICsgJy1zJyk7XG4gICAgICAgICAgICAgICAgYXR0YWNoU3R5bGVzKGhvc3RSZWYpO1xuICAgICAgICAgICAgICAgIGZvcmNlVXBkYXRlKGVsbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgYXR0YWNoU2hhZG93ID0gKGVsKSA9PiB7XG4gICAgaWYgKHN1cHBvcnRzU2hhZG93KSB7XG4gICAgICAgIGVsLmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVsLnNoYWRvd1Jvb3QgPSBlbDtcbiAgICB9XG59O1xuY29uc3QgaG1yU3RhcnQgPSAoZWxtLCBjbXBNZXRhLCBobXJWZXJzaW9uSWQpID0+IHtcbiAgICAvLyDCr1xcXyjjg4QpXy/Cr1xuICAgIGNvbnN0IGhvc3RSZWYgPSBnZXRIb3N0UmVmKGVsbSk7XG4gICAgLy8gcmVzZXQgc3RhdGUgZmxhZ3MgdG8gb25seSBoYXZlIGJlZW4gY29ubmVjdGVkXG4gICAgaG9zdFJlZi4kZmxhZ3MkID0gMSAvKiBoYXNDb25uZWN0ZWQgKi87XG4gICAgLy8gVE9ET1xuICAgIC8vIGRldGF0Y2ggYW55IGV2ZW50IGxpc3RlbmVycyB0aGF0IG1heSBoYXZlIGJlZW4gYWRkZWRcbiAgICAvLyBiZWNhdXNlIHdlJ3JlIG5vdCBwYXNzaW5nIGFuIGV4YWN0IGV2ZW50IG5hbWUgaXQnbGxcbiAgICAvLyByZW1vdmUgYWxsIG9mIHRoaXMgZWxlbWVudCdzIGV2ZW50LCB3aGljaCBpcyBnb29kXG4gICAgLy8gY3JlYXRlIGEgY2FsbGJhY2sgZm9yIHdoZW4gdGhpcyBjb21wb25lbnQgZmluaXNoZXMgaG1yXG4gICAgZWxtWydzLWhtci1sb2FkJ10gPSAoKSA9PiB7XG4gICAgICAgIC8vIGZpbmlzaGVkIGhtciBmb3IgdGhpcyBlbGVtZW50XG4gICAgICAgIGRlbGV0ZSBlbG1bJ3MtaG1yLWxvYWQnXTtcbiAgICB9O1xuICAgIC8vIHJlLWluaXRpYWxpemUgdGhlIGNvbXBvbmVudFxuICAgIGluaXRpYWxpemVDb21wb25lbnQoZWxtLCBob3N0UmVmLCBjbXBNZXRhLCBobXJWZXJzaW9uSWQpO1xufTtcbmNvbnN0IHBhdGNoQ2xvbmVOb2RlID0gKEhvc3RFbGVtZW50UHJvdG90eXBlKSA9PiB7XG4gICAgY29uc3Qgb3JnQ2xvbmVOb2RlID0gSG9zdEVsZW1lbnRQcm90b3R5cGUuY2xvbmVOb2RlO1xuICAgIEhvc3RFbGVtZW50UHJvdG90eXBlLmNsb25lTm9kZSA9IGZ1bmN0aW9uIChkZWVwKSB7XG4gICAgICAgIGNvbnN0IHNyY05vZGUgPSB0aGlzO1xuICAgICAgICBjb25zdCBpc1NoYWRvd0RvbSA9IEJVSUxELnNoYWRvd0RvbSA/IHNyY05vZGUuc2hhZG93Um9vdCAmJiBzdXBwb3J0c1NoYWRvdyA6IGZhbHNlO1xuICAgICAgICBjb25zdCBjbG9uZWROb2RlID0gb3JnQ2xvbmVOb2RlLmNhbGwoc3JjTm9kZSwgaXNTaGFkb3dEb20gPyBkZWVwIDogZmFsc2UpO1xuICAgICAgICBpZiAoQlVJTEQuc2xvdCAmJiAhaXNTaGFkb3dEb20gJiYgZGVlcCkge1xuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgbGV0IHNsb3R0ZWQsIG5vblN0ZW5jaWxOb2RlO1xuICAgICAgICAgICAgbGV0IHN0ZW5jaWxQcml2YXRlcyA9IFsncy1pZCcsICdzLWNyJywgJ3MtbHInLCAncy1yYycsICdzLXNjJywgJ3MtcCcsICdzLWNuJywgJ3Mtc3InLCAncy1zbicsICdzLWhuJywgJ3Mtb2wnLCAncy1ucicsICdzLXNpJ107XG4gICAgICAgICAgICBmb3IgKDsgaSA8IHNyY05vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHNsb3R0ZWQgPSBzcmNOb2RlLmNoaWxkTm9kZXNbaV1bJ3MtbnInXTtcbiAgICAgICAgICAgICAgICBub25TdGVuY2lsTm9kZSA9IHN0ZW5jaWxQcml2YXRlcy5ldmVyeSgocHJpdmF0ZUZpZWxkKSA9PiAhc3JjTm9kZS5jaGlsZE5vZGVzW2ldW3ByaXZhdGVGaWVsZF0pO1xuICAgICAgICAgICAgICAgIGlmIChzbG90dGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChCVUlMRC5hcHBlbmRDaGlsZFNsb3RGaXggJiYgY2xvbmVkTm9kZS5fX2FwcGVuZENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9uZWROb2RlLl9fYXBwZW5kQ2hpbGQoc2xvdHRlZC5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVkTm9kZS5hcHBlbmRDaGlsZChzbG90dGVkLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5vblN0ZW5jaWxOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb25lZE5vZGUuYXBwZW5kQ2hpbGQoc3JjTm9kZS5jaGlsZE5vZGVzW2ldLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbG9uZWROb2RlO1xuICAgIH07XG59O1xuY29uc3QgcGF0Y2hTbG90QXBwZW5kQ2hpbGQgPSAoSG9zdEVsZW1lbnRQcm90b3R5cGUpID0+IHtcbiAgICBIb3N0RWxlbWVudFByb3RvdHlwZS5fX2FwcGVuZENoaWxkID0gSG9zdEVsZW1lbnRQcm90b3R5cGUuYXBwZW5kQ2hpbGQ7XG4gICAgSG9zdEVsZW1lbnRQcm90b3R5cGUuYXBwZW5kQ2hpbGQgPSBmdW5jdGlvbiAobmV3Q2hpbGQpIHtcbiAgICAgICAgY29uc3Qgc2xvdE5hbWUgPSAobmV3Q2hpbGRbJ3Mtc24nXSA9IGdldFNsb3ROYW1lKG5ld0NoaWxkKSk7XG4gICAgICAgIGNvbnN0IHNsb3ROb2RlID0gZ2V0SG9zdFNsb3ROb2RlKHRoaXMuY2hpbGROb2Rlcywgc2xvdE5hbWUpO1xuICAgICAgICBpZiAoc2xvdE5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHNsb3RDaGlsZE5vZGVzID0gZ2V0SG9zdFNsb3RDaGlsZE5vZGVzKHNsb3ROb2RlLCBzbG90TmFtZSk7XG4gICAgICAgICAgICBjb25zdCBhcHBlbmRBZnRlciA9IHNsb3RDaGlsZE5vZGVzW3Nsb3RDaGlsZE5vZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgcmV0dXJuIGFwcGVuZEFmdGVyLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld0NoaWxkLCBhcHBlbmRBZnRlci5uZXh0U2libGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX19hcHBlbmRDaGlsZChuZXdDaGlsZCk7XG4gICAgfTtcbn07XG5jb25zdCBwYXRjaENoaWxkU2xvdE5vZGVzID0gKGVsbSwgY21wTWV0YSkgPT4ge1xuICAgIGNsYXNzIEZha2VOb2RlTGlzdCBleHRlbmRzIEFycmF5IHtcbiAgICAgICAgaXRlbShuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tuXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY21wTWV0YS4kZmxhZ3MkICYgOCAvKiBuZWVkc1NoYWRvd0RvbVNoaW0gKi8pIHtcbiAgICAgICAgY29uc3QgY2hpbGROb2Rlc0ZuID0gZWxtLl9fbG9va3VwR2V0dGVyX18oJ2NoaWxkTm9kZXMnKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsbSwgJ2NoaWxkcmVuJywge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkTm9kZXMubWFwKChuKSA9PiBuLm5vZGVUeXBlID09PSAxKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxtLCAnY2hpbGRFbGVtZW50Q291bnQnLCB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsbS5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsbSwgJ2NoaWxkTm9kZXMnLCB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGROb2RlcyA9IGNoaWxkTm9kZXNGbi5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmICgocGx0LiRmbGFncyQgJiAxIC8qIGlzVG1wRGlzY29ubmVjdGVkICovKSA9PT0gMCAmJiBnZXRIb3N0UmVmKHRoaXMpLiRmbGFncyQgJiAyIC8qIGhhc1JlbmRlcmVkICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBGYWtlTm9kZUxpc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzbG90ID0gY2hpbGROb2Rlc1tpXVsncy1uciddO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNsb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzbG90KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gRmFrZU5vZGVMaXN0LmZyb20oY2hpbGROb2Rlcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG59O1xuY29uc3QgZ2V0U2xvdE5hbWUgPSAobm9kZSkgPT4gbm9kZVsncy1zbiddIHx8IChub2RlLm5vZGVUeXBlID09PSAxICYmIG5vZGUuZ2V0QXR0cmlidXRlKCdzbG90JykpIHx8ICcnO1xuY29uc3QgZ2V0SG9zdFNsb3ROb2RlID0gKGNoaWxkTm9kZXMsIHNsb3ROYW1lKSA9PiB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBjaGlsZE5vZGU7XG4gICAgZm9yICg7IGkgPCBjaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXNbaV07XG4gICAgICAgIGlmIChjaGlsZE5vZGVbJ3Mtc3InXSAmJiBjaGlsZE5vZGVbJ3Mtc24nXSA9PT0gc2xvdE5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGROb2RlID0gZ2V0SG9zdFNsb3ROb2RlKGNoaWxkTm9kZS5jaGlsZE5vZGVzLCBzbG90TmFtZSk7XG4gICAgICAgIGlmIChjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZE5vZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuY29uc3QgZ2V0SG9zdFNsb3RDaGlsZE5vZGVzID0gKG4sIHNsb3ROYW1lKSA9PiB7XG4gICAgY29uc3QgY2hpbGROb2RlcyA9IFtuXTtcbiAgICB3aGlsZSAoKG4gPSBuLm5leHRTaWJsaW5nKSAmJiBuWydzLXNuJ10gPT09IHNsb3ROYW1lKSB7XG4gICAgICAgIGNoaWxkTm9kZXMucHVzaChuKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkTm9kZXM7XG59O1xuY29uc3QgYm9vdHN0cmFwTGF6eSA9IChsYXp5QnVuZGxlcywgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgaWYgKEJVSUxELnByb2ZpbGUgJiYgcGVyZm9ybWFuY2UubWFyaykge1xuICAgICAgICBwZXJmb3JtYW5jZS5tYXJrKCdzdDphcHA6c3RhcnQnKTtcbiAgICB9XG4gICAgaW5zdGFsbERldlRvb2xzKCk7XG4gICAgY29uc3QgZW5kQm9vdHN0cmFwID0gY3JlYXRlVGltZSgnYm9vdHN0cmFwTGF6eScpO1xuICAgIGNvbnN0IGNtcFRhZ3MgPSBbXTtcbiAgICBjb25zdCBleGNsdWRlID0gb3B0aW9ucy5leGNsdWRlIHx8IFtdO1xuICAgIGNvbnN0IGN1c3RvbUVsZW1lbnRzID0gd2luLmN1c3RvbUVsZW1lbnRzO1xuICAgIGNvbnN0IGhlYWQgPSBkb2MuaGVhZDtcbiAgICBjb25zdCBtZXRhQ2hhcnNldCA9IC8qQF9fUFVSRV9fKi8gaGVhZC5xdWVyeVNlbGVjdG9yKCdtZXRhW2NoYXJzZXRdJyk7XG4gICAgY29uc3QgdmlzaWJpbGl0eVN0eWxlID0gLypAX19QVVJFX18qLyBkb2MuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICBjb25zdCBkZWZlcnJlZENvbm5lY3RlZENhbGxiYWNrcyA9IFtdO1xuICAgIGNvbnN0IHN0eWxlcyA9IC8qQF9fUFVSRV9fKi8gZG9jLnF1ZXJ5U2VsZWN0b3JBbGwoYFske0hZRFJBVEVEX1NUWUxFX0lEfV1gKTtcbiAgICBsZXQgYXBwTG9hZEZhbGxiYWNrO1xuICAgIGxldCBpc0Jvb3RzdHJhcHBpbmcgPSB0cnVlO1xuICAgIGxldCBpID0gMDtcbiAgICBPYmplY3QuYXNzaWduKHBsdCwgb3B0aW9ucyk7XG4gICAgcGx0LiRyZXNvdXJjZXNVcmwkID0gbmV3IFVSTChvcHRpb25zLnJlc291cmNlc1VybCB8fCAnLi8nLCBkb2MuYmFzZVVSSSkuaHJlZjtcbiAgICBpZiAoQlVJTEQuYXN5bmNRdWV1ZSkge1xuICAgICAgICBpZiAob3B0aW9ucy5zeW5jUXVldWUpIHtcbiAgICAgICAgICAgIHBsdC4kZmxhZ3MkIHw9IDQgLyogcXVldWVTeW5jICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChCVUlMRC5oeWRyYXRlQ2xpZW50U2lkZSkge1xuICAgICAgICAvLyBJZiB0aGUgYXBwIGlzIGFscmVhZHkgaHlkcmF0ZWQgdGhlcmUgaXMgbm90IHBvaW50IHRvIGRpc2FibGUgdGhlXG4gICAgICAgIC8vIGFzeW5jIHF1ZXVlLiBUaGlzIHdpbGwgaW1wcm92ZSB0aGUgZmlyc3QgaW5wdXQgZGVsYXlcbiAgICAgICAgcGx0LiRmbGFncyQgfD0gMiAvKiBhcHBMb2FkZWQgKi87XG4gICAgfVxuICAgIGlmIChCVUlMRC5oeWRyYXRlQ2xpZW50U2lkZSAmJiBCVUlMRC5zaGFkb3dEb20pIHtcbiAgICAgICAgZm9yICg7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlZ2lzdGVyU3R5bGUoc3R5bGVzW2ldLmdldEF0dHJpYnV0ZShIWURSQVRFRF9TVFlMRV9JRCksIGNvbnZlcnRTY29wZWRUb1NoYWRvdyhzdHlsZXNbaV0uaW5uZXJIVE1MKSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGF6eUJ1bmRsZXMubWFwKGxhenlCdW5kbGUgPT4gbGF6eUJ1bmRsZVsxXS5tYXAoY29tcGFjdE1ldGEgPT4ge1xuICAgICAgICBjb25zdCBjbXBNZXRhID0ge1xuICAgICAgICAgICAgJGZsYWdzJDogY29tcGFjdE1ldGFbMF0sXG4gICAgICAgICAgICAkdGFnTmFtZSQ6IGNvbXBhY3RNZXRhWzFdLFxuICAgICAgICAgICAgJG1lbWJlcnMkOiBjb21wYWN0TWV0YVsyXSxcbiAgICAgICAgICAgICRsaXN0ZW5lcnMkOiBjb21wYWN0TWV0YVszXSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKEJVSUxELm1lbWJlcikge1xuICAgICAgICAgICAgY21wTWV0YS4kbWVtYmVycyQgPSBjb21wYWN0TWV0YVsyXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQuaG9zdExpc3RlbmVyKSB7XG4gICAgICAgICAgICBjbXBNZXRhLiRsaXN0ZW5lcnMkID0gY29tcGFjdE1ldGFbM107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJVSUxELnJlZmxlY3QpIHtcbiAgICAgICAgICAgIGNtcE1ldGEuJGF0dHJzVG9SZWZsZWN0JCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC53YXRjaENhbGxiYWNrKSB7XG4gICAgICAgICAgICBjbXBNZXRhLiR3YXRjaGVycyQgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQuc2hhZG93RG9tICYmICFzdXBwb3J0c1NoYWRvdyAmJiBjbXBNZXRhLiRmbGFncyQgJiAxIC8qIHNoYWRvd0RvbUVuY2Fwc3VsYXRpb24gKi8pIHtcbiAgICAgICAgICAgIGNtcE1ldGEuJGZsYWdzJCB8PSA4IC8qIG5lZWRzU2hhZG93RG9tU2hpbSAqLztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YWdOYW1lID0gQlVJTEQudHJhbnNmb3JtVGFnTmFtZSAmJiBvcHRpb25zLnRyYW5zZm9ybVRhZ05hbWUgPyBvcHRpb25zLnRyYW5zZm9ybVRhZ05hbWUoY21wTWV0YS4kdGFnTmFtZSQpIDogY21wTWV0YS4kdGFnTmFtZSQ7XG4gICAgICAgIGNvbnN0IEhvc3RFbGVtZW50ID0gY2xhc3MgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgICAgICAgICAvLyBTdGVuY2lsTGF6eUhvc3RcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKHNlbGYpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgc3VwZXIoc2VsZik7XG4gICAgICAgICAgICAgICAgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJIb3N0KHNlbGYsIGNtcE1ldGEpO1xuICAgICAgICAgICAgICAgIGlmIChCVUlMRC5zaGFkb3dEb20gJiYgY21wTWV0YS4kZmxhZ3MkICYgMSAvKiBzaGFkb3dEb21FbmNhcHN1bGF0aW9uICovKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY29tcG9uZW50IGlzIHVzaW5nIHNoYWRvdyBkb21cbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHRoaXMgYnJvd3NlciBzdXBwb3J0cyBzaGFkb3cgZG9tXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCB0aGUgcmVhZC1vbmx5IHByb3BlcnR5IFwic2hhZG93Um9vdFwiIHRvIHRoZSBob3N0IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkaW5nIHRoZSBzaGFkb3cgcm9vdCBidWlsZCBjb25kaXRpb25hbHMgdG8gbWluaW1pemUgcnVudGltZVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydHNTaGFkb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChCVUlMRC5zaGFkb3dEZWxlZ2F0ZXNGb2N1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYXR0YWNoU2hhZG93KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZTogJ29wZW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0ZXNGb2N1czogISEoY21wTWV0YS4kZmxhZ3MkICYgMTYgLyogc2hhZG93RGVsZWdhdGVzRm9jdXMgKi8pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hdHRhY2hTaGFkb3coeyBtb2RlOiAnb3BlbicgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIUJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlICYmICEoJ3NoYWRvd1Jvb3QnIGluIHNlbGYpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNoYWRvd1Jvb3QgPSBzZWxmO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChCVUlMRC5zbG90Q2hpbGROb2Rlc0ZpeCkge1xuICAgICAgICAgICAgICAgICAgICBwYXRjaENoaWxkU2xvdE5vZGVzKHNlbGYsIGNtcE1ldGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICAgICAgICAgIGlmIChhcHBMb2FkRmFsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGFwcExvYWRGYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIGFwcExvYWRGYWxsYmFjayA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0Jvb3RzdHJhcHBpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29ubmVjdGVkQ2FsbGJhY2sgd2lsbCBiZSBwcm9jZXNzZWQgb25jZSBhbGwgY29tcG9uZW50cyBoYXZlIGJlZW4gcmVnaXN0ZXJlZFxuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZENvbm5lY3RlZENhbGxiYWNrcy5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGx0LmptcCgoKSA9PiBjb25uZWN0ZWRDYWxsYmFjayh0aGlzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICAgICAgcGx0LmptcCgoKSA9PiBkaXNjb25uZWN0ZWRDYWxsYmFjayh0aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21wb25lbnRPblJlYWR5KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRIb3N0UmVmKHRoaXMpLiRvblJlYWR5UHJvbWlzZSQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChCVUlMRC5jbG9uZU5vZGVGaXgpIHtcbiAgICAgICAgICAgIHBhdGNoQ2xvbmVOb2RlKEhvc3RFbGVtZW50LnByb3RvdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJVSUxELmFwcGVuZENoaWxkU2xvdEZpeCkge1xuICAgICAgICAgICAgcGF0Y2hTbG90QXBwZW5kQ2hpbGQoSG9zdEVsZW1lbnQucHJvdG90eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQuaG90TW9kdWxlUmVwbGFjZW1lbnQpIHtcbiAgICAgICAgICAgIEhvc3RFbGVtZW50LnByb3RvdHlwZVsncy1obXInXSA9IGZ1bmN0aW9uIChobXJWZXJzaW9uSWQpIHtcbiAgICAgICAgICAgICAgICBobXJTdGFydCh0aGlzLCBjbXBNZXRhLCBobXJWZXJzaW9uSWQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjbXBNZXRhLiRsYXp5QnVuZGxlSWQkID0gbGF6eUJ1bmRsZVswXTtcbiAgICAgICAgaWYgKCFleGNsdWRlLmluY2x1ZGVzKHRhZ05hbWUpICYmICFjdXN0b21FbGVtZW50cy5nZXQodGFnTmFtZSkpIHtcbiAgICAgICAgICAgIGNtcFRhZ3MucHVzaCh0YWdOYW1lKTtcbiAgICAgICAgICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSh0YWdOYW1lLCBwcm94eUNvbXBvbmVudChIb3N0RWxlbWVudCwgY21wTWV0YSwgMSAvKiBpc0VsZW1lbnRDb25zdHJ1Y3RvciAqLykpO1xuICAgICAgICB9XG4gICAgfSkpO1xuICAgIGlmIChCVUlMRC5oeWRyYXRlZENsYXNzIHx8IEJVSUxELmh5ZHJhdGVkQXR0cmlidXRlKSB7XG4gICAgICAgIHZpc2liaWxpdHlTdHlsZS5pbm5lckhUTUwgPSBjbXBUYWdzICsgSFlEUkFURURfQ1NTO1xuICAgICAgICB2aXNpYmlsaXR5U3R5bGUuc2V0QXR0cmlidXRlKCdkYXRhLXN0eWxlcycsICcnKTtcbiAgICAgICAgaGVhZC5pbnNlcnRCZWZvcmUodmlzaWJpbGl0eVN0eWxlLCBtZXRhQ2hhcnNldCA/IG1ldGFDaGFyc2V0Lm5leHRTaWJsaW5nIDogaGVhZC5maXJzdENoaWxkKTtcbiAgICB9XG4gICAgLy8gUHJvY2VzcyBkZWZlcnJlZCBjb25uZWN0ZWRDYWxsYmFja3Mgbm93IGFsbCBjb21wb25lbnRzIGhhdmUgYmVlbiByZWdpc3RlcmVkXG4gICAgaXNCb290c3RyYXBwaW5nID0gZmFsc2U7XG4gICAgaWYgKGRlZmVycmVkQ29ubmVjdGVkQ2FsbGJhY2tzLmxlbmd0aCkge1xuICAgICAgICBkZWZlcnJlZENvbm5lY3RlZENhbGxiYWNrcy5tYXAoaG9zdCA9PiBob3N0LmNvbm5lY3RlZENhbGxiYWNrKCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKEJVSUxELnByb2ZpbGUpIHtcbiAgICAgICAgICAgIHBsdC5qbXAoKCkgPT4gKGFwcExvYWRGYWxsYmFjayA9IHNldFRpbWVvdXQoYXBwRGlkTG9hZCwgMzAsICd0aW1lb3V0JykpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBsdC5qbXAoKCkgPT4gKGFwcExvYWRGYWxsYmFjayA9IHNldFRpbWVvdXQoYXBwRGlkTG9hZCwgMzApKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRmFsbGJhY2sgYXBwTG9hZCBldmVudFxuICAgIGVuZEJvb3RzdHJhcCgpO1xufTtcbmNvbnN0IGdldEFzc2V0UGF0aCA9IChwYXRoKSA9PiB7XG4gICAgY29uc3QgYXNzZXRVcmwgPSBuZXcgVVJMKHBhdGgsIHBsdC4kcmVzb3VyY2VzVXJsJCk7XG4gICAgcmV0dXJuIGFzc2V0VXJsLm9yaWdpbiAhPT0gd2luLmxvY2F0aW9uLm9yaWdpbiA/IGFzc2V0VXJsLmhyZWYgOiBhc3NldFVybC5wYXRobmFtZTtcbn07XG5jb25zdCBzZXRBc3NldFBhdGggPSAocGF0aCkgPT4gKHBsdC4kcmVzb3VyY2VzVXJsJCA9IHBhdGgpO1xuY29uc3QgZ2V0Q29ubmVjdCA9IChfcmVmLCB0YWdOYW1lKSA9PiB7XG4gICAgY29uc3QgY29tcG9uZW50T25SZWFkeSA9ICgpID0+IHtcbiAgICAgICAgbGV0IGVsbSA9IGRvYy5xdWVyeVNlbGVjdG9yKHRhZ05hbWUpO1xuICAgICAgICBpZiAoIWVsbSkge1xuICAgICAgICAgICAgZWxtID0gZG9jLmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gICAgICAgICAgICBkb2MuYm9keS5hcHBlbmRDaGlsZChlbG0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlb2YgZWxtLmNvbXBvbmVudE9uUmVhZHkgPT09ICdmdW5jdGlvbicgPyBlbG0uY29tcG9uZW50T25SZWFkeSgpIDogUHJvbWlzZS5yZXNvbHZlKGVsbSk7XG4gICAgfTtcbiAgICBjb25zdCBjcmVhdGUgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICByZXR1cm4gY29tcG9uZW50T25SZWFkeSgpLnRoZW4oZWwgPT4gZWwuY3JlYXRlKC4uLmFyZ3MpKTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGNyZWF0ZSxcbiAgICAgICAgY29tcG9uZW50T25SZWFkeSxcbiAgICB9O1xufTtcbmNvbnN0IGdldENvbnRleHQgPSAoX2VsbSwgY29udGV4dCkgPT4ge1xuICAgIGlmIChjb250ZXh0IGluIENvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIENvbnRleHRbY29udGV4dF07XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRleHQgPT09ICd3aW5kb3cnKSB7XG4gICAgICAgIHJldHVybiB3aW47XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRleHQgPT09ICdkb2N1bWVudCcpIHtcbiAgICAgICAgcmV0dXJuIGRvYztcbiAgICB9XG4gICAgZWxzZSBpZiAoY29udGV4dCA9PT0gJ2lzU2VydmVyJyB8fCBjb250ZXh0ID09PSAnaXNQcmVyZW5kZXInKSB7XG4gICAgICAgIHJldHVybiBCVUlMRC5oeWRyYXRlU2VydmVyU2lkZSA/IHRydWUgOiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29udGV4dCA9PT0gJ2lzQ2xpZW50Jykge1xuICAgICAgICByZXR1cm4gQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGUgPyBmYWxzZSA6IHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRleHQgPT09ICdyZXNvdXJjZXNVcmwnIHx8IGNvbnRleHQgPT09ICdwdWJsaWNQYXRoJykge1xuICAgICAgICByZXR1cm4gZ2V0QXNzZXRQYXRoKCcuJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRleHQgPT09ICdxdWV1ZScpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdyaXRlOiB3cml0ZVRhc2ssXG4gICAgICAgICAgICByZWFkOiByZWFkVGFzayxcbiAgICAgICAgICAgIHRpY2s6IHtcbiAgICAgICAgICAgICAgICB0aGVuKGNiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0VGljayhjYik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuY29uc3QgaW5zZXJ0VmRvbUFubm90YXRpb25zID0gKGRvYywgc3RhdGljQ29tcG9uZW50cykgPT4ge1xuICAgIGlmIChkb2MgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBkb2NEYXRhID0ge1xuICAgICAgICAgICAgaG9zdElkczogMCxcbiAgICAgICAgICAgIHJvb3RMZXZlbElkczogMCxcbiAgICAgICAgICAgIHN0YXRpY0NvbXBvbmVudHM6IG5ldyBTZXQoc3RhdGljQ29tcG9uZW50cyksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9yZ0xvY2F0aW9uTm9kZXMgPSBbXTtcbiAgICAgICAgcGFyc2VWTm9kZUFubm90YXRpb25zKGRvYywgZG9jLmJvZHksIGRvY0RhdGEsIG9yZ0xvY2F0aW9uTm9kZXMpO1xuICAgICAgICBvcmdMb2NhdGlvbk5vZGVzLmZvckVhY2gob3JnTG9jYXRpb25Ob2RlID0+IHtcbiAgICAgICAgICAgIGlmIChvcmdMb2NhdGlvbk5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVSZWYgPSBvcmdMb2NhdGlvbk5vZGVbJ3MtbnInXTtcbiAgICAgICAgICAgICAgICBsZXQgaG9zdElkID0gbm9kZVJlZlsncy1ob3N0LWlkJ107XG4gICAgICAgICAgICAgICAgbGV0IG5vZGVJZCA9IG5vZGVSZWZbJ3Mtbm9kZS1pZCddO1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZElkID0gYCR7aG9zdElkfS4ke25vZGVJZH1gO1xuICAgICAgICAgICAgICAgIGlmIChob3N0SWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBob3N0SWQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBkb2NEYXRhLnJvb3RMZXZlbElkcysrO1xuICAgICAgICAgICAgICAgICAgICBub2RlSWQgPSBkb2NEYXRhLnJvb3RMZXZlbElkcztcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRJZCA9IGAke2hvc3RJZH0uJHtub2RlSWR9YDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVSZWYubm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVSZWYuc2V0QXR0cmlidXRlKEhZRFJBVEVfQ0hJTERfSUQsIGNoaWxkSWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGVSZWYubm9kZVR5cGUgPT09IDMgLyogVGV4dE5vZGUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChob3N0SWQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0Q29udGVudCA9IG5vZGVSZWYubm9kZVZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGV4dENvbnRlbnQgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZWxlc3Mgd2hpdGVzcGFjZSBub2RlIGF0IHRoZSBkb2N1bWVudCByb290XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yZ0xvY2F0aW9uTm9kZS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbW1lbnRCZWZvcmVUZXh0Tm9kZSA9IGRvYy5jcmVhdGVDb21tZW50KGNoaWxkSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudEJlZm9yZVRleHROb2RlLm5vZGVWYWx1ZSA9IGAke1RFWFRfTk9ERV9JRH0uJHtjaGlsZElkfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlUmVmLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNvbW1lbnRCZWZvcmVUZXh0Tm9kZSwgbm9kZVJlZik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IG9yZ0xvY2F0aW9uTm9kZUlkID0gYCR7T1JHX0xPQ0FUSU9OX0lEfS4ke2NoaWxkSWR9YDtcbiAgICAgICAgICAgICAgICBjb25zdCBvcmdMb2NhdGlvblBhcmVudE5vZGUgPSBvcmdMb2NhdGlvbk5vZGUucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgICAgICBpZiAob3JnTG9jYXRpb25QYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcmdMb2NhdGlvblBhcmVudE5vZGVbJ3MtZW4nXSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVuZGluZyB3aXRoIGEgXCIuXCIgbWVhbnMgdGhhdCB0aGUgcGFyZW50IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mIHRoaXMgbm9kZSdzIG9yaWdpbmFsIGxvY2F0aW9uIGlzIGEgU0hBRE9XIGRvbSBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgdGhpcyBub2RlIGlzIGFwYXJ0IG9mIHRoZSByb290IGxldmVsIGxpZ2h0IGRvbVxuICAgICAgICAgICAgICAgICAgICAgICAgb3JnTG9jYXRpb25Ob2RlSWQgKz0gYC5gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9yZ0xvY2F0aW9uUGFyZW50Tm9kZVsncy1lbiddID09PSAnYycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVuZGluZyB3aXRoIGEgXCIuY1wiIG1lYW5zIHRoYXQgdGhlIHBhcmVudCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvZiB0aGlzIG5vZGUncyBvcmlnaW5hbCBsb2NhdGlvbiBpcyBhIFNDT1BFRCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgdGhpcyBub2RlIGlzIGFwYXJ0IG9mIHRoZSByb290IGxldmVsIGxpZ2h0IGRvbVxuICAgICAgICAgICAgICAgICAgICAgICAgb3JnTG9jYXRpb25Ob2RlSWQgKz0gYC5jYDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcmdMb2NhdGlvbk5vZGUubm9kZVZhbHVlID0gb3JnTG9jYXRpb25Ob2RlSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5jb25zdCBwYXJzZVZOb2RlQW5ub3RhdGlvbnMgPSAoZG9jLCBub2RlLCBkb2NEYXRhLCBvcmdMb2NhdGlvbk5vZGVzKSA9PiB7XG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChub2RlWydzLW5yJ10gIT0gbnVsbCkge1xuICAgICAgICBvcmdMb2NhdGlvbk5vZGVzLnB1c2gobm9kZSk7XG4gICAgfVxuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAxIC8qIEVsZW1lbnROb2RlICovKSB7XG4gICAgICAgIG5vZGUuY2hpbGROb2Rlcy5mb3JFYWNoKGNoaWxkTm9kZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBob3N0UmVmID0gZ2V0SG9zdFJlZihjaGlsZE5vZGUpO1xuICAgICAgICAgICAgaWYgKGhvc3RSZWYgIT0gbnVsbCAmJiAhZG9jRGF0YS5zdGF0aWNDb21wb25lbnRzLmhhcyhjaGlsZE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbXBEYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICBub2RlSWRzOiAwLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaW5zZXJ0Vk5vZGVBbm5vdGF0aW9ucyhkb2MsIGNoaWxkTm9kZSwgaG9zdFJlZi4kdm5vZGUkLCBkb2NEYXRhLCBjbXBEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnNlVk5vZGVBbm5vdGF0aW9ucyhkb2MsIGNoaWxkTm9kZSwgZG9jRGF0YSwgb3JnTG9jYXRpb25Ob2Rlcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5jb25zdCBpbnNlcnRWTm9kZUFubm90YXRpb25zID0gKGRvYywgaG9zdEVsbSwgdm5vZGUsIGRvY0RhdGEsIGNtcERhdGEpID0+IHtcbiAgICBpZiAodm5vZGUgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBob3N0SWQgPSArK2RvY0RhdGEuaG9zdElkcztcbiAgICAgICAgaG9zdEVsbS5zZXRBdHRyaWJ1dGUoSFlEUkFURV9JRCwgaG9zdElkKTtcbiAgICAgICAgaWYgKGhvc3RFbG1bJ3MtY3InXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBob3N0RWxtWydzLWNyJ10ubm9kZVZhbHVlID0gYCR7Q09OVEVOVF9SRUZfSUR9LiR7aG9zdElkfWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZub2RlLiRjaGlsZHJlbiQgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgZGVwdGggPSAwO1xuICAgICAgICAgICAgdm5vZGUuJGNoaWxkcmVuJC5mb3JFYWNoKCh2bm9kZUNoaWxkLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGluc2VydENoaWxkVk5vZGVBbm5vdGF0aW9ucyhkb2MsIHZub2RlQ2hpbGQsIGNtcERhdGEsIGhvc3RJZCwgZGVwdGgsIGluZGV4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChob3N0RWxtICYmIHZub2RlICYmIHZub2RlLiRlbG0kICYmICFob3N0RWxtLmhhc0F0dHJpYnV0ZSgnYy1pZCcpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBob3N0RWxtLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudC5jaGlsZE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50Q2hpbGROb2RlcyA9IEFycmF5LmZyb20ocGFyZW50LmNoaWxkTm9kZXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbW1lbnQgPSBwYXJlbnRDaGlsZE5vZGVzLmZpbmQobm9kZSA9PiBub2RlLm5vZGVUeXBlID09PSA4IC8qIENvbW1lbnROb2RlICovICYmIG5vZGVbJ3Mtc3InXSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwYXJlbnRDaGlsZE5vZGVzLmluZGV4T2YoaG9zdEVsbSkgLSAxO1xuICAgICAgICAgICAgICAgICAgICB2bm9kZS4kZWxtJC5zZXRBdHRyaWJ1dGUoSFlEUkFURV9DSElMRF9JRCwgYCR7Y29tbWVudFsncy1ob3N0LWlkJ119LiR7Y29tbWVudFsncy1ub2RlLWlkJ119LjAuJHtpbmRleH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgaW5zZXJ0Q2hpbGRWTm9kZUFubm90YXRpb25zID0gKGRvYywgdm5vZGVDaGlsZCwgY21wRGF0YSwgaG9zdElkLCBkZXB0aCwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBjaGlsZEVsbSA9IHZub2RlQ2hpbGQuJGVsbSQ7XG4gICAgaWYgKGNoaWxkRWxtID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBub2RlSWQgPSBjbXBEYXRhLm5vZGVJZHMrKztcbiAgICBjb25zdCBjaGlsZElkID0gYCR7aG9zdElkfS4ke25vZGVJZH0uJHtkZXB0aH0uJHtpbmRleH1gO1xuICAgIGNoaWxkRWxtWydzLWhvc3QtaWQnXSA9IGhvc3RJZDtcbiAgICBjaGlsZEVsbVsncy1ub2RlLWlkJ10gPSBub2RlSWQ7XG4gICAgaWYgKGNoaWxkRWxtLm5vZGVUeXBlID09PSAxIC8qIEVsZW1lbnROb2RlICovKSB7XG4gICAgICAgIGNoaWxkRWxtLnNldEF0dHJpYnV0ZShIWURSQVRFX0NISUxEX0lELCBjaGlsZElkKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2hpbGRFbG0ubm9kZVR5cGUgPT09IDMgLyogVGV4dE5vZGUgKi8pIHtcbiAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IGNoaWxkRWxtLnBhcmVudE5vZGU7XG4gICAgICAgIGNvbnN0IG5vZGVOYW1lID0gcGFyZW50Tm9kZS5ub2RlTmFtZTtcbiAgICAgICAgaWYgKG5vZGVOYW1lICE9PSAnU1RZTEUnICYmIG5vZGVOYW1lICE9PSAnU0NSSVBUJykge1xuICAgICAgICAgICAgY29uc3QgdGV4dE5vZGVJZCA9IGAke1RFWFRfTk9ERV9JRH0uJHtjaGlsZElkfWA7XG4gICAgICAgICAgICBjb25zdCBjb21tZW50QmVmb3JlVGV4dE5vZGUgPSBkb2MuY3JlYXRlQ29tbWVudCh0ZXh0Tm9kZUlkKTtcbiAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNvbW1lbnRCZWZvcmVUZXh0Tm9kZSwgY2hpbGRFbG0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGNoaWxkRWxtLm5vZGVUeXBlID09PSA4IC8qIENvbW1lbnROb2RlICovKSB7XG4gICAgICAgIGlmIChjaGlsZEVsbVsncy1zciddKSB7XG4gICAgICAgICAgICBjb25zdCBzbG90TmFtZSA9IGNoaWxkRWxtWydzLXNuJ10gfHwgJyc7XG4gICAgICAgICAgICBjb25zdCBzbG90Tm9kZUlkID0gYCR7U0xPVF9OT0RFX0lEfS4ke2NoaWxkSWR9LiR7c2xvdE5hbWV9YDtcbiAgICAgICAgICAgIGNoaWxkRWxtLm5vZGVWYWx1ZSA9IHNsb3ROb2RlSWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZub2RlQ2hpbGQuJGNoaWxkcmVuJCAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkRGVwdGggPSBkZXB0aCArIDE7XG4gICAgICAgIHZub2RlQ2hpbGQuJGNoaWxkcmVuJC5mb3JFYWNoKCh2bm9kZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGluc2VydENoaWxkVk5vZGVBbm5vdGF0aW9ucyhkb2MsIHZub2RlLCBjbXBEYXRhLCBob3N0SWQsIGNoaWxkRGVwdGgsIGluZGV4KTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbmNvbnN0IHNldFBsYXRmb3JtT3B0aW9ucyA9IChvcHRzKSA9PiBPYmplY3QuYXNzaWduKHBsdCwgb3B0cyk7XG5jb25zdCBGcmFnbWVudCA9IChfLCBjaGlsZHJlbikgPT4gY2hpbGRyZW47XG5jb25zdCBob3N0UmVmcyA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBnZXRIb3N0UmVmID0gKHJlZikgPT4gaG9zdFJlZnMuZ2V0KHJlZik7XG5jb25zdCByZWdpc3Rlckluc3RhbmNlID0gKGxhenlJbnN0YW5jZSwgaG9zdFJlZikgPT4gaG9zdFJlZnMuc2V0KChob3N0UmVmLiRsYXp5SW5zdGFuY2UkID0gbGF6eUluc3RhbmNlKSwgaG9zdFJlZik7XG5jb25zdCByZWdpc3Rlckhvc3QgPSAoZWxtLCBjbXBNZXRhKSA9PiB7XG4gICAgY29uc3QgaG9zdFJlZiA9IHtcbiAgICAgICAgJGZsYWdzJDogMCxcbiAgICAgICAgJGhvc3RFbGVtZW50JDogZWxtLFxuICAgICAgICAkY21wTWV0YSQ6IGNtcE1ldGEsXG4gICAgICAgICRpbnN0YW5jZVZhbHVlcyQ6IG5ldyBNYXAoKSxcbiAgICB9O1xuICAgIGlmIChCVUlMRC5pc0Rldikge1xuICAgICAgICBob3N0UmVmLiRyZW5kZXJDb3VudCQgPSAwO1xuICAgIH1cbiAgICBpZiAoQlVJTEQubWV0aG9kICYmIEJVSUxELmxhenlMb2FkKSB7XG4gICAgICAgIGhvc3RSZWYuJG9uSW5zdGFuY2VQcm9taXNlJCA9IG5ldyBQcm9taXNlKHIgPT4gKGhvc3RSZWYuJG9uSW5zdGFuY2VSZXNvbHZlJCA9IHIpKTtcbiAgICB9XG4gICAgaWYgKEJVSUxELmFzeW5jTG9hZGluZykge1xuICAgICAgICBob3N0UmVmLiRvblJlYWR5UHJvbWlzZSQgPSBuZXcgUHJvbWlzZShyID0+IChob3N0UmVmLiRvblJlYWR5UmVzb2x2ZSQgPSByKSk7XG4gICAgICAgIGVsbVsncy1wJ10gPSBbXTtcbiAgICAgICAgZWxtWydzLXJjJ10gPSBbXTtcbiAgICB9XG4gICAgYWRkSG9zdEV2ZW50TGlzdGVuZXJzKGVsbSwgaG9zdFJlZiwgY21wTWV0YS4kbGlzdGVuZXJzJCwgZmFsc2UpO1xuICAgIHJldHVybiBob3N0UmVmcy5zZXQoZWxtLCBob3N0UmVmKTtcbn07XG5jb25zdCBpc01lbWJlckluRWxlbWVudCA9IChlbG0sIG1lbWJlck5hbWUpID0+IG1lbWJlck5hbWUgaW4gZWxtO1xuY29uc3QgY29uc29sZUVycm9yID0gKGUsIGVsKSA9PiAoY3VzdG9tRXJyb3IgfHwgY29uc29sZS5lcnJvcikoZSwgZWwpO1xuY29uc3QgU1RFTkNJTF9ERVZfTU9ERSA9IEJVSUxELmlzVGVzdGluZ1xuICAgID8gWydTVEVOQ0lMOiddIC8vIEUyRSB0ZXN0aW5nXG4gICAgOiBbJyVjc3RlbmNpbCcsICdjb2xvcjogd2hpdGU7YmFja2dyb3VuZDojNGM0N2ZmO2ZvbnQtd2VpZ2h0OiBib2xkOyBmb250LXNpemU6MTBweDsgcGFkZGluZzoycHggNnB4OyBib3JkZXItcmFkaXVzOiA1cHgnXTtcbmNvbnN0IGNvbnNvbGVEZXZFcnJvciA9ICguLi5tKSA9PiBjb25zb2xlLmVycm9yKC4uLlNURU5DSUxfREVWX01PREUsIC4uLm0pO1xuY29uc3QgY29uc29sZURldldhcm4gPSAoLi4ubSkgPT4gY29uc29sZS53YXJuKC4uLlNURU5DSUxfREVWX01PREUsIC4uLm0pO1xuY29uc3QgY29uc29sZURldkluZm8gPSAoLi4ubSkgPT4gY29uc29sZS5pbmZvKC4uLlNURU5DSUxfREVWX01PREUsIC4uLm0pO1xuY29uc3Qgc2V0RXJyb3JIYW5kbGVyID0gKGhhbmRsZXIpID0+IGN1c3RvbUVycm9yID0gaGFuZGxlcjtcbmNvbnN0IGNtcE1vZHVsZXMgPSAvKkBfX1BVUkVfXyovIG5ldyBNYXAoKTtcbmNvbnN0IGxvYWRNb2R1bGUgPSAoY21wTWV0YSwgaG9zdFJlZiwgaG1yVmVyc2lvbklkKSA9PiB7XG4gICAgLy8gbG9hZE1vZHVsZUltcG9ydFxuICAgIGNvbnN0IGV4cG9ydE5hbWUgPSBjbXBNZXRhLiR0YWdOYW1lJC5yZXBsYWNlKC8tL2csICdfJyk7XG4gICAgY29uc3QgYnVuZGxlSWQgPSBjbXBNZXRhLiRsYXp5QnVuZGxlSWQkO1xuICAgIGlmIChCVUlMRC5pc0RldiAmJiB0eXBlb2YgYnVuZGxlSWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnNvbGVEZXZFcnJvcihgVHJ5aW5nIHRvIGxhemlseSBsb2FkIGNvbXBvbmVudCA8JHtjbXBNZXRhLiR0YWdOYW1lJH0+IHdpdGggc3R5bGUgbW9kZSBcIiR7aG9zdFJlZi4kbW9kZU5hbWUkfVwiLCBidXQgaXQgZG9lcyBub3QgZXhpc3QuYCk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IG1vZHVsZSA9ICFCVUlMRC5ob3RNb2R1bGVSZXBsYWNlbWVudCA/IGNtcE1vZHVsZXMuZ2V0KGJ1bmRsZUlkKSA6IGZhbHNlO1xuICAgIGlmIChtb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuIG1vZHVsZVtleHBvcnROYW1lXTtcbiAgICB9XG4gICAgcmV0dXJuIGltcG9ydChcbiAgICAvKiB3ZWJwYWNrSW5jbHVkZTogL1xcLmVudHJ5XFwuanMkLyAqL1xuICAgIC8qIHdlYnBhY2tFeGNsdWRlOiAvXFwuc3lzdGVtXFwuZW50cnlcXC5qcyQvICovXG4gICAgLyogd2VicGFja01vZGU6IFwibGF6eVwiICovXG4gICAgYC4vJHtidW5kbGVJZH0uZW50cnkuanMke0JVSUxELmhvdE1vZHVsZVJlcGxhY2VtZW50ICYmIGhtclZlcnNpb25JZCA/ICc/cy1obXI9JyArIGhtclZlcnNpb25JZCA6ICcnfWApLnRoZW4oaW1wb3J0ZWRNb2R1bGUgPT4ge1xuICAgICAgICBpZiAoIUJVSUxELmhvdE1vZHVsZVJlcGxhY2VtZW50KSB7XG4gICAgICAgICAgICBjbXBNb2R1bGVzLnNldChidW5kbGVJZCwgaW1wb3J0ZWRNb2R1bGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbXBvcnRlZE1vZHVsZVtleHBvcnROYW1lXTtcbiAgICB9LCBjb25zb2xlRXJyb3IpO1xufTtcbmNvbnN0IHN0eWxlcyA9IG5ldyBNYXAoKTtcbmNvbnN0IG1vZGVSZXNvbHV0aW9uQ2hhaW4gPSBbXTtcbmNvbnN0IHF1ZXVlRG9tUmVhZHMgPSBbXTtcbmNvbnN0IHF1ZXVlRG9tV3JpdGVzID0gW107XG5jb25zdCBxdWV1ZURvbVdyaXRlc0xvdyA9IFtdO1xuY29uc3QgcXVldWVUYXNrID0gKHF1ZXVlLCB3cml0ZSkgPT4gKGNiKSA9PiB7XG4gICAgcXVldWUucHVzaChjYik7XG4gICAgaWYgKCFxdWV1ZVBlbmRpbmcpIHtcbiAgICAgICAgcXVldWVQZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgaWYgKHdyaXRlICYmIHBsdC4kZmxhZ3MkICYgNCAvKiBxdWV1ZVN5bmMgKi8pIHtcbiAgICAgICAgICAgIG5leHRUaWNrKGZsdXNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBsdC5yYWYoZmx1c2gpO1xuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IGNvbnN1bWUgPSAocXVldWUpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBxdWV1ZVtpXShwZXJmb3JtYW5jZS5ub3coKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGVFcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5sZW5ndGggPSAwO1xufTtcbmNvbnN0IGNvbnN1bWVUaW1lb3V0ID0gKHF1ZXVlLCB0aW1lb3V0KSA9PiB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCB0cyA9IDA7XG4gICAgd2hpbGUgKGkgPCBxdWV1ZS5sZW5ndGggJiYgKHRzID0gcGVyZm9ybWFuY2Uubm93KCkpIDwgdGltZW91dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcXVldWVbaSsrXSh0cyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGVFcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaSA9PT0gcXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGkgIT09IDApIHtcbiAgICAgICAgcXVldWUuc3BsaWNlKDAsIGkpO1xuICAgIH1cbn07XG5jb25zdCBmbHVzaCA9ICgpID0+IHtcbiAgICBpZiAoQlVJTEQuYXN5bmNRdWV1ZSkge1xuICAgICAgICBxdWV1ZUNvbmdlc3Rpb24rKztcbiAgICB9XG4gICAgLy8gYWx3YXlzIGZvcmNlIGEgYnVuY2ggb2YgbWVkaXVtIGNhbGxiYWNrcyB0byBydW4sIGJ1dCBzdGlsbCBoYXZlXG4gICAgLy8gYSB0aHJvdHRsZSBvbiBob3cgbWFueSBjYW4gcnVuIGluIGEgY2VydGFpbiB0aW1lXG4gICAgLy8gRE9NIFJFQURTISEhXG4gICAgY29uc3VtZShxdWV1ZURvbVJlYWRzKTtcbiAgICAvLyBET00gV1JJVEVTISEhXG4gICAgaWYgKEJVSUxELmFzeW5jUXVldWUpIHtcbiAgICAgICAgY29uc3QgdGltZW91dCA9IChwbHQuJGZsYWdzJCAmIDYgLyogcXVldWVNYXNrICovKSA9PT0gMiAvKiBhcHBMb2FkZWQgKi8gPyBwZXJmb3JtYW5jZS5ub3coKSArIDE0ICogTWF0aC5jZWlsKHF1ZXVlQ29uZ2VzdGlvbiAqICgxLjAgLyAxMC4wKSkgOiBJbmZpbml0eTtcbiAgICAgICAgY29uc3VtZVRpbWVvdXQocXVldWVEb21Xcml0ZXMsIHRpbWVvdXQpO1xuICAgICAgICBjb25zdW1lVGltZW91dChxdWV1ZURvbVdyaXRlc0xvdywgdGltZW91dCk7XG4gICAgICAgIGlmIChxdWV1ZURvbVdyaXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBxdWV1ZURvbVdyaXRlc0xvdy5wdXNoKC4uLnF1ZXVlRG9tV3JpdGVzKTtcbiAgICAgICAgICAgIHF1ZXVlRG9tV3JpdGVzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChxdWV1ZVBlbmRpbmcgPSBxdWV1ZURvbVJlYWRzLmxlbmd0aCArIHF1ZXVlRG9tV3JpdGVzLmxlbmd0aCArIHF1ZXVlRG9tV3JpdGVzTG93Lmxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgICAvLyBzdGlsbCBtb3JlIHRvIGRvIHlldCwgYnV0IHdlJ3ZlIHJ1biBvdXQgb2YgdGltZVxuICAgICAgICAgICAgLy8gbGV0J3MgbGV0IHRoaXMgdGhpbmcgY29vbCBvZmYgYW5kIHRyeSBhZ2FpbiBpbiB0aGUgbmV4dCB0aWNrXG4gICAgICAgICAgICBwbHQucmFmKGZsdXNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHF1ZXVlQ29uZ2VzdGlvbiA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN1bWUocXVldWVEb21Xcml0ZXMpO1xuICAgICAgICBpZiAoKHF1ZXVlUGVuZGluZyA9IHF1ZXVlRG9tUmVhZHMubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgICAgIC8vIHN0aWxsIG1vcmUgdG8gZG8geWV0LCBidXQgd2UndmUgcnVuIG91dCBvZiB0aW1lXG4gICAgICAgICAgICAvLyBsZXQncyBsZXQgdGhpcyB0aGluZyBjb29sIG9mZiBhbmQgdHJ5IGFnYWluIGluIHRoZSBuZXh0IHRpY2tcbiAgICAgICAgICAgIHBsdC5yYWYoZmx1c2gpO1xuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IG5leHRUaWNrID0gLypAX19QVVJFX18qLyAoY2IpID0+IHByb21pc2VSZXNvbHZlKCkudGhlbihjYik7XG5jb25zdCByZWFkVGFzayA9IC8qQF9fUFVSRV9fKi8gcXVldWVUYXNrKHF1ZXVlRG9tUmVhZHMsIGZhbHNlKTtcbmNvbnN0IHdyaXRlVGFzayA9IC8qQF9fUFVSRV9fKi8gcXVldWVUYXNrKHF1ZXVlRG9tV3JpdGVzLCB0cnVlKTtcbmNvbnN0IEJ1aWxkID0ge1xuICAgIGlzRGV2OiBCVUlMRC5pc0RldiA/IHRydWUgOiBmYWxzZSxcbiAgICBpc0Jyb3dzZXI6IHRydWUsXG4gICAgaXNTZXJ2ZXI6IGZhbHNlLFxuICAgIGlzVGVzdGluZzogQlVJTEQuaXNUZXN0aW5nID8gdHJ1ZSA6IGZhbHNlLFxufTtcbmV4cG9ydCB7IEJVSUxELCBFbnYsIE5BTUVTUEFDRSB9IGZyb20gJ0BzdGVuY2lsL2NvcmUvaW50ZXJuYWwvYXBwLWRhdGEnO1xuZXhwb3J0IHsgQnVpbGQsIENTUywgQ29udGV4dCwgRnJhZ21lbnQsIEgsIEggYXMgSFRNTEVsZW1lbnQsIEhvc3QsIFNURU5DSUxfREVWX01PREUsIGFkZEhvc3RFdmVudExpc3RlbmVycywgYXR0YWNoU2hhZG93LCBib290c3RyYXBMYXp5LCBjbXBNb2R1bGVzLCBjb25uZWN0ZWRDYWxsYmFjaywgY29uc29sZURldkVycm9yLCBjb25zb2xlRGV2SW5mbywgY29uc29sZURldldhcm4sIGNvbnNvbGVFcnJvciwgY3JlYXRlRXZlbnQsIGRlZmluZUN1c3RvbUVsZW1lbnQsIGRpc2Nvbm5lY3RlZENhbGxiYWNrLCBkb2MsIGZvcmNlTW9kZVVwZGF0ZSwgZm9yY2VVcGRhdGUsIGdldEFzc2V0UGF0aCwgZ2V0Q29ubmVjdCwgZ2V0Q29udGV4dCwgZ2V0RWxlbWVudCwgZ2V0SG9zdFJlZiwgZ2V0TW9kZSwgZ2V0UmVuZGVyaW5nUmVmLCBnZXRWYWx1ZSwgaCwgaW5zZXJ0VmRvbUFubm90YXRpb25zLCBpc01lbWJlckluRWxlbWVudCwgbG9hZE1vZHVsZSwgbW9kZVJlc29sdXRpb25DaGFpbiwgbmV4dFRpY2ssIHBhcnNlUHJvcGVydHlWYWx1ZSwgcGx0LCBwb3N0VXBkYXRlQ29tcG9uZW50LCBwcm9taXNlUmVzb2x2ZSwgcHJveHlDb21wb25lbnQsIHByb3h5Q3VzdG9tRWxlbWVudCwgcmVhZFRhc2ssIHJlZ2lzdGVySG9zdCwgcmVnaXN0ZXJJbnN0YW5jZSwgcmVuZGVyVmRvbSwgc2V0QXNzZXRQYXRoLCBzZXRFcnJvckhhbmRsZXIsIHNldE1vZGUsIHNldFBsYXRmb3JtSGVscGVycywgc2V0UGxhdGZvcm1PcHRpb25zLCBzZXRWYWx1ZSwgc3R5bGVzLCBzdXBwb3J0c0NvbnN0cnVjdGlibGVTdHlsZXNoZWV0cywgc3VwcG9ydHNMaXN0ZW5lck9wdGlvbnMsIHN1cHBvcnRzU2hhZG93LCB3aW4sIHdyaXRlVGFzayB9O1xuIiwiLy8gYFNhbWVWYWx1ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNhbWV2YWx1ZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1pcyAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5pcyB8fCBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gIHJldHVybiB4ID09PSB5ID8geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkgOiB4ICE9IHggJiYgeSAhPSB5O1xufTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGZyb20gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktZnJvbScpO1xudmFyIGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jaGVjay1jb3JyZWN0bmVzcy1vZi1pdGVyYXRpb24nKTtcblxudmFyIElOQ09SUkVDVF9JVEVSQVRJT04gPSAhY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uKGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tYXJyYXktZnJvbSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICBBcnJheS5mcm9tKGl0ZXJhYmxlKTtcbn0pO1xuXG4vLyBgQXJyYXkuZnJvbWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LmZyb21cbiQoeyB0YXJnZXQ6ICdBcnJheScsIHN0YXQ6IHRydWUsIGZvcmNlZDogSU5DT1JSRUNUX0lURVJBVElPTiB9LCB7XG4gIGZyb206IGZyb21cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGZpeFJlZ0V4cFdlbGxLbm93blN5bWJvbExvZ2ljID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZpeC1yZWdleHAtd2VsbC1rbm93bi1zeW1ib2wtbG9naWMnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZScpO1xudmFyIHNhbWVWYWx1ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zYW1lLXZhbHVlJyk7XG52YXIgcmVnRXhwRXhlYyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWdleHAtZXhlYy1hYnN0cmFjdCcpO1xuXG4vLyBAQHNlYXJjaCBsb2dpY1xuZml4UmVnRXhwV2VsbEtub3duU3ltYm9sTG9naWMoJ3NlYXJjaCcsIDEsIGZ1bmN0aW9uIChTRUFSQ0gsIG5hdGl2ZVNlYXJjaCwgbWF5YmVDYWxsTmF0aXZlKSB7XG4gIHJldHVybiBbXG4gICAgLy8gYFN0cmluZy5wcm90b3R5cGUuc2VhcmNoYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuc2VhcmNoXG4gICAgZnVuY3Rpb24gc2VhcmNoKHJlZ2V4cCkge1xuICAgICAgdmFyIE8gPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHRoaXMpO1xuICAgICAgdmFyIHNlYXJjaGVyID0gcmVnZXhwID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJlZ2V4cFtTRUFSQ0hdO1xuICAgICAgcmV0dXJuIHNlYXJjaGVyICE9PSB1bmRlZmluZWQgPyBzZWFyY2hlci5jYWxsKHJlZ2V4cCwgTykgOiBuZXcgUmVnRXhwKHJlZ2V4cClbU0VBUkNIXShTdHJpbmcoTykpO1xuICAgIH0sXG4gICAgLy8gYFJlZ0V4cC5wcm90b3R5cGVbQEBzZWFyY2hdYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUtQEBzZWFyY2hcbiAgICBmdW5jdGlvbiAocmVnZXhwKSB7XG4gICAgICB2YXIgcmVzID0gbWF5YmVDYWxsTmF0aXZlKG5hdGl2ZVNlYXJjaCwgcmVnZXhwLCB0aGlzKTtcbiAgICAgIGlmIChyZXMuZG9uZSkgcmV0dXJuIHJlcy52YWx1ZTtcblxuICAgICAgdmFyIHJ4ID0gYW5PYmplY3QocmVnZXhwKTtcbiAgICAgIHZhciBTID0gU3RyaW5nKHRoaXMpO1xuXG4gICAgICB2YXIgcHJldmlvdXNMYXN0SW5kZXggPSByeC5sYXN0SW5kZXg7XG4gICAgICBpZiAoIXNhbWVWYWx1ZShwcmV2aW91c0xhc3RJbmRleCwgMCkpIHJ4Lmxhc3RJbmRleCA9IDA7XG4gICAgICB2YXIgcmVzdWx0ID0gcmVnRXhwRXhlYyhyeCwgUyk7XG4gICAgICBpZiAoIXNhbWVWYWx1ZShyeC5sYXN0SW5kZXgsIHByZXZpb3VzTGFzdEluZGV4KSkgcngubGFzdEluZGV4ID0gcHJldmlvdXNMYXN0SW5kZXg7XG4gICAgICByZXR1cm4gcmVzdWx0ID09PSBudWxsID8gLTEgOiByZXN1bHQuaW5kZXg7XG4gICAgfVxuICBdO1xufSk7XG4iLCJjb25zdCBCVUlMRCA9IHtcbiAgICBhbGxSZW5kZXJGbjogZmFsc2UsXG4gICAgY21wRGlkTG9hZDogdHJ1ZSxcbiAgICBjbXBEaWRVbmxvYWQ6IGZhbHNlLFxuICAgIGNtcERpZFVwZGF0ZTogdHJ1ZSxcbiAgICBjbXBEaWRSZW5kZXI6IHRydWUsXG4gICAgY21wV2lsbExvYWQ6IHRydWUsXG4gICAgY21wV2lsbFVwZGF0ZTogdHJ1ZSxcbiAgICBjbXBXaWxsUmVuZGVyOiB0cnVlLFxuICAgIGNvbm5lY3RlZENhbGxiYWNrOiB0cnVlLFxuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrOiB0cnVlLFxuICAgIGVsZW1lbnQ6IHRydWUsXG4gICAgZXZlbnQ6IHRydWUsXG4gICAgaGFzUmVuZGVyRm46IHRydWUsXG4gICAgbGlmZWN5Y2xlOiB0cnVlLFxuICAgIGhvc3RMaXN0ZW5lcjogdHJ1ZSxcbiAgICBob3N0TGlzdGVuZXJUYXJnZXRXaW5kb3c6IHRydWUsXG4gICAgaG9zdExpc3RlbmVyVGFyZ2V0RG9jdW1lbnQ6IHRydWUsXG4gICAgaG9zdExpc3RlbmVyVGFyZ2V0Qm9keTogdHJ1ZSxcbiAgICBob3N0TGlzdGVuZXJUYXJnZXRQYXJlbnQ6IGZhbHNlLFxuICAgIGhvc3RMaXN0ZW5lclRhcmdldDogdHJ1ZSxcbiAgICBtZW1iZXI6IHRydWUsXG4gICAgbWV0aG9kOiB0cnVlLFxuICAgIG1vZGU6IHRydWUsXG4gICAgb2JzZXJ2ZUF0dHJpYnV0ZTogdHJ1ZSxcbiAgICBwcm9wOiB0cnVlLFxuICAgIHByb3BNdXRhYmxlOiB0cnVlLFxuICAgIHJlZmxlY3Q6IHRydWUsXG4gICAgc2NvcGVkOiB0cnVlLFxuICAgIHNoYWRvd0RvbTogdHJ1ZSxcbiAgICBzbG90OiB0cnVlLFxuICAgIGNzc0Fubm90YXRpb25zOiB0cnVlLFxuICAgIHN0YXRlOiB0cnVlLFxuICAgIHN0eWxlOiB0cnVlLFxuICAgIHN2ZzogdHJ1ZSxcbiAgICB1cGRhdGFibGU6IHRydWUsXG4gICAgdmRvbUF0dHJpYnV0ZTogdHJ1ZSxcbiAgICB2ZG9tWGxpbms6IHRydWUsXG4gICAgdmRvbUNsYXNzOiB0cnVlLFxuICAgIHZkb21GdW5jdGlvbmFsOiB0cnVlLFxuICAgIHZkb21LZXk6IHRydWUsXG4gICAgdmRvbUxpc3RlbmVyOiB0cnVlLFxuICAgIHZkb21SZWY6IHRydWUsXG4gICAgdmRvbVByb3BPckF0dHI6IHRydWUsXG4gICAgdmRvbVJlbmRlcjogdHJ1ZSxcbiAgICB2ZG9tU3R5bGU6IHRydWUsXG4gICAgdmRvbVRleHQ6IHRydWUsXG4gICAgd2F0Y2hDYWxsYmFjazogdHJ1ZSxcbiAgICB0YXNrUXVldWU6IHRydWUsXG4gICAgaG90TW9kdWxlUmVwbGFjZW1lbnQ6IGZhbHNlLFxuICAgIGlzRGVidWc6IGZhbHNlLFxuICAgIGlzRGV2OiBmYWxzZSxcbiAgICBpc1Rlc3Rpbmc6IGZhbHNlLFxuICAgIGh5ZHJhdGVTZXJ2ZXJTaWRlOiBmYWxzZSxcbiAgICBoeWRyYXRlQ2xpZW50U2lkZTogZmFsc2UsXG4gICAgbGlmZWN5Y2xlRE9NRXZlbnRzOiBmYWxzZSxcbiAgICBsYXp5TG9hZDogZmFsc2UsXG4gICAgcHJvZmlsZTogZmFsc2UsXG4gICAgc2xvdFJlbG9jYXRpb246IHRydWUsXG4gICAgYXBwZW5kQ2hpbGRTbG90Rml4OiBmYWxzZSxcbiAgICBjbG9uZU5vZGVGaXg6IGZhbHNlLFxuICAgIGh5ZHJhdGVkQXR0cmlidXRlOiBmYWxzZSxcbiAgICBoeWRyYXRlZENsYXNzOiB0cnVlLFxuICAgIHNhZmFyaTEwOiBmYWxzZSxcbiAgICBzY3JpcHREYXRhT3B0czogZmFsc2UsXG4gICAgc2hhZG93RG9tU2hpbTogZmFsc2UsXG4gICAgc2xvdENoaWxkTm9kZXNGaXg6IGZhbHNlLFxuICAgIHByb3BCb29sZWFuOiB0cnVlLFxuICAgIHByb3BOdW1iZXI6IHRydWUsXG4gICAgcHJvcFN0cmluZzogdHJ1ZSxcbiAgICBjc3NWYXJTaGltOiBmYWxzZSxcbiAgICBjb25zdHJ1Y3RhYmxlQ1NTOiB0cnVlLFxuICAgIGNtcFNob3VsZFVwZGF0ZTogdHJ1ZSxcbiAgICBkZXZUb29sczogZmFsc2UsXG4gICAgZHluYW1pY0ltcG9ydFNoaW06IGZhbHNlLFxuICAgIHNoYWRvd0RlbGVnYXRlc0ZvY3VzOiB0cnVlLFxuICAgIGluaXRpYWxpemVOZXh0VGljazogZmFsc2UsXG4gICAgYXN5bmNMb2FkaW5nOiBmYWxzZSxcbiAgICBhc3luY1F1ZXVlOiBmYWxzZSxcbiAgICB0cmFuc2Zvcm1UYWdOYW1lOiBmYWxzZSxcbiAgICBhdHRhY2hTdHlsZXM6IHRydWUsXG59O1xuY29uc3QgRW52ID0ge307XG5jb25zdCBOQU1FU1BBQ0UgPSAvKiBkZWZhdWx0ICovICdhcHAnO1xuXG5leHBvcnQgeyBCVUlMRCwgRW52LCBOQU1FU1BBQ0UgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==